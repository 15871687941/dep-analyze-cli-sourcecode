var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var require_index_001 = __commonJS({
  "assets/index-2b2bf081.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity)
          fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy)
          fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    function makeMap(str, expectsLowerCase) {
      const map2 = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i2 = 0; i2 < list.length; i2++) {
        map2[list[i2]] = true;
      }
      return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const onRE = /^on[^a-z]/;
    const isOn = (key) => onRE.test(key);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend$2 = Object.assign;
    const remove$2 = (arr, el) => {
      const i2 = arr.indexOf(el);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    const hasOwnProperty$e = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$e.call(val, key);
    const isArray$3 = Array.isArray;
    const isMap$2 = (val) => toTypeString(val) === "[object Map]";
    const isSet$2 = (val) => toTypeString(val) === "[object Set]";
    const isFunction$3 = (val) => typeof val === "function";
    const isString$2 = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$2 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return isObject$2(val) && isFunction$3(val.then) && isFunction$3(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn2) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn2(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize$1 = cacheStringFunction(
      (str) => str.charAt(0).toUpperCase() + str.slice(1)
    );
    const toHandlerKey = cacheStringFunction(
      (str) => str ? `on${capitalize$1(str)}` : ``
    );
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](arg);
      }
    };
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber$1 = (val) => {
      const n = isString$2(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$3(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$2(value)) {
        return value;
      } else if (isObject$2(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$2(value)) {
        res = value;
      } else if (isArray$3(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$2(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    const toDisplayString = (val) => {
      return isString$2(val) ? val : val == null ? "" : isArray$3(val) || isObject$2(val) && (val.toString === objectToString$1 || !isFunction$3(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap$2(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
            entries[`${key} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet$2(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject$2(val) && !isArray$3(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn2) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn2();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i2, l;
          for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
            this.effects[i2].stop();
          }
          for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
            this.cleanups[i2]();
          }
          if (this.scopes) {
            for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
              this.scopes[i2].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function recordEffectScope(effect, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn2) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn2);
      }
    }
    const createDep = (effects) => {
      const dep = new Set(effects);
      dep.w = 0;
      dep.n = 0;
      return dep;
    };
    const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
    const newTracked = (dep) => (dep.n & trackOpBit) > 0;
    const initDepMarkers = ({ deps }) => {
      if (deps.length) {
        for (let i2 = 0; i2 < deps.length; i2++) {
          deps[i2].w |= trackOpBit;
        }
      }
    };
    const finalizeDepMarkers = (effect) => {
      const { deps } = effect;
      if (deps.length) {
        let ptr = 0;
        for (let i2 = 0; i2 < deps.length; i2++) {
          const dep = deps[i2];
          if (wasTracked(dep) && !newTracked(dep)) {
            dep.delete(effect);
          } else {
            deps[ptr++] = dep;
          }
          dep.w &= ~trackOpBit;
          dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
      }
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    let effectTrackDepth = 0;
    let trackOpBit = 1;
    const maxMarkerBits = 30;
    let activeEffect;
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    class ReactiveEffect {
      constructor(fn2, scheduler = null, scope) {
        this.fn = fn2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
      }
      run() {
        if (!this.active) {
          return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
          if (parent === this) {
            return;
          }
          parent = parent.parent;
        }
        try {
          this.parent = activeEffect;
          activeEffect = this;
          shouldTrack = true;
          trackOpBit = 1 << ++effectTrackDepth;
          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }
          trackOpBit = 1 << --effectTrackDepth;
          activeEffect = this.parent;
          shouldTrack = lastShouldTrack;
          this.parent = void 0;
          if (this.deferStop) {
            this.stop();
          }
        }
      }
      stop() {
        if (activeEffect === this) {
          this.deferStop = true;
        } else if (this.active) {
          cleanupEffect(this);
          if (this.onStop) {
            this.onStop();
          }
          this.active = false;
        }
      }
    }
    function cleanupEffect(effect2) {
      const { deps } = effect2;
      if (deps.length) {
        for (let i2 = 0; i2 < deps.length; i2++) {
          deps[i2].delete(effect2);
        }
        deps.length = 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep());
        }
        trackEffects(dep);
      }
    }
    function trackEffects(dep, debuggerEventExtraInfo) {
      let shouldTrack2 = false;
      if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
          dep.n |= trackOpBit;
          shouldTrack2 = !wasTracked(dep);
        }
      } else {
        shouldTrack2 = !dep.has(activeEffect);
      }
      if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$3(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!isArray$3(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$2(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$3(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap$2(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      if (deps.length === 1) {
        if (deps[0]) {
          {
            triggerEffects(deps[0]);
          }
        }
      } else {
        const effects = [];
        for (const dep of deps) {
          if (dep) {
            effects.push(...dep);
          }
        }
        {
          triggerEffects(createDep(effects));
        }
      }
    }
    function triggerEffects(dep, debuggerEventExtraInfo) {
      const effects = isArray$3(dep) ? dep : [...dep];
      for (const effect2 of effects) {
        if (effect2.computed) {
          triggerEffect(effect2);
        }
      }
      for (const effect2 of effects) {
        if (!effect2.computed) {
          triggerEffect(effect2);
        }
      }
    }
    function triggerEffect(effect2, debuggerEventExtraInfo) {
      if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (effect2.scheduler) {
          effect2.scheduler();
        } else {
          effect2.run();
        }
      }
    }
    function getDepFromReactive(object2, key) {
      var _a2;
      return (_a2 = targetMap.get(object2)) == null ? void 0 : _a2.get(key);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
    );
    const get$1$1 = /* @__PURE__ */ createGetter();
    const shallowGet = /* @__PURE__ */ createGetter(false, true);
    const readonlyGet = /* @__PURE__ */ createGetter(true);
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i2 = 0, l = this.length; i2 < l; i2++) {
            track(arr, "get", i2 + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          const res = toRaw(this)[key].apply(this, args);
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$d(key) {
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    function createGetter(isReadonly2 = false, shallow = false) {
      return function get2(target, key, receiver) {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
          return target;
        }
        const targetIsArray = isArray$3(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$d;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$2(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      };
    }
    const set$1$1 = /* @__PURE__ */ createSetter();
    const shallowSet = /* @__PURE__ */ createSetter(true);
    function createSetter(shallow = false) {
      return function set2(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
          return false;
        }
        if (!shallow) {
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$3(target) && isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          }
        }
        const hadKey = isArray$3(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      };
    }
    function deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function has$1(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    function ownKeys(target) {
      track(target, "iterate", isArray$3(target) ? "length" : ITERATE_KEY);
      return Reflect.ownKeys(target);
    }
    const mutableHandlers = {
      get: get$1$1,
      set: set$1$1,
      deleteProperty,
      has: has$1,
      ownKeys
    };
    const readonlyHandlers = {
      get: readonlyGet,
      set(target, key) {
        return true;
      },
      deleteProperty(target, key) {
        return true;
      }
    };
    const shallowReactiveHandlers = /* @__PURE__ */ extend$2(
      {},
      mutableHandlers,
      {
        get: shallowGet,
        set: shallowSet
      }
    );
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function get$3(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (key !== rawKey) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (key !== rawKey) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add$1(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto2 = getProto(target);
      const hadKey = proto2.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$2(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach2(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap$2(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$3(this, key);
        },
        get size() {
          return size(this);
        },
        has,
        add: add$1,
        set: set$2,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$3(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has,
        add: add$1,
        set: set$2,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(
          method,
          false,
          false
        );
        readonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          false
        );
        shallowInstrumentations2[method] = createIterableMethod(
          method,
          false,
          true
        );
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$2(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      def(value, "__v_skip", true);
      return value;
    }
    const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
    function trackRefValue(ref2) {
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        {
          trackEffects(ref2.dep || (ref2.dep = createDep()));
        }
      }
    }
    function triggerRefValue(ref2, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        {
          triggerEffects(dep);
        }
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this);
        }
      }
    }
    function triggerRef(ref2) {
      triggerRefValue(ref2);
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    function toRefs(object2) {
      const ret = isArray$3(object2) ? new Array(object2.length) : {};
      for (const key in object2) {
        ret[key] = propertyToRef(object2, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
      }
      get value() {
        return this._getter();
      }
    }
    function toRef(source, key, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$3(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$2(source) && arguments.length > 1) {
        return propertyToRef(source, key, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(
        source,
        key,
        defaultValue
      );
    }
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
          if (!this._dirty) {
            this._dirty = true;
            triggerRefValue(this);
          }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        trackRefValue(self2);
        if (self2._dirty || !self2._cacheable) {
          self2._dirty = false;
          self2._value = self2.effect.run();
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$3(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function warn(msg, ...args) {
      return;
    }
    function callWithErrorHandling(fn2, instance, type, args) {
      let res;
      try {
        res = args ? fn2(...args) : fn2();
      } catch (err) {
        handleError(err, instance, type);
      }
      return res;
    }
    function callWithAsyncErrorHandling(fn2, instance, type, args) {
      if (isFunction$3(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      const values = [];
      for (let i2 = 0; i2 < fn2.length; i2++) {
        values.push(callWithAsyncErrorHandling(fn2[i2], instance, type, args));
      }
      return values;
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = type;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
              if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn2) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
    }
    function findInsertionIndex(id2) {
      let start2 = flushIndex + 1;
      let end = queue.length;
      while (start2 < end) {
        const middle = start2 + end >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id2 ? start2 = middle + 1 : end = middle;
      }
      return start2;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i2 = queue.indexOf(job);
      if (i2 > flushIndex) {
        queue.splice(i2, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$3(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(seen, i2 = isFlushing ? flushIndex + 1 : 0) {
      for (; i2 < queue.length; i2++) {
        const cb = queue[i2];
        if (cb && cb.pre) {
          queue.splice(i2, 1);
          i2--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        activePostFlushCbs.sort((a2, b) => getId(a2) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a2, b) => {
      const diff = getId(a2) - getId(b);
      if (diff === 0) {
        if (a2.pre && !b.pre)
          return -1;
        if (b.pre && !a2.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      const check = NOOP;
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
        if (trim2) {
          args = rawArgs.map((a2) => isString$2(a2) ? a2.trim() : a2);
        }
        if (number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$3(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend$2(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$2(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray$3(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend$2(normalized, raw);
      }
      if (isObject$2(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id2) {
      currentScopeId = id2;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn2;
      if (fn2._n) {
        return fn2;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn2(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        props,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          result = normalizeVNode(
            render2.call(
              proxyToUse,
              proxyToUse,
              renderCache,
              props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (false)
            ;
          result = normalizeVNode(
            render22.length > 1 ? render22(
              props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return attrs;
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              props,
              null
              /* we know it doesn't need it */
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root2.transition = vnode.transition;
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i2 = 0; i2 < dynamicProps.length; i2++) {
            const key = dynamicProps[i2];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i2 = 0; i2 < nextKeys.length; i2++) {
        const key = nextKeys[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      }
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn2, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$3(fn2)) {
          suspense.effects.push(...fn2);
        } else {
          suspense.effects.push(fn2);
        }
      } else {
        queuePostFlushCb(fn2);
      }
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
      var _a2;
      const instance = getCurrentScope() === ((_a2 = currentInstance) == null ? void 0 : _a2.scope) ? currentInstance : null;
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => source;
        deep = true;
      } else if (isArray$3(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return traverse(s);
          } else if (isFunction$3(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else
            ;
        });
      } else if (isFunction$3(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (instance && instance.isUnmounted) {
              return;
            }
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn2) => {
        cleanup = effect.onStop = () => {
          callWithErrorHandling(fn2, instance, 4);
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect.active) {
          return;
        }
        if (cb) {
          const newValue = effect.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some(
            (v, i2) => hasChanged(v, oldValue[i2])
          ) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect = new ReactiveEffect(getter, scheduler);
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect.run.bind(effect),
          instance && instance.suspense
        );
      } else {
        effect.run();
      }
      const unwatch = () => {
        effect.stop();
        if (instance && instance.scope) {
          remove$2(instance.scope.effects, effect);
        }
      };
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$3(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const cur = currentInstance;
      setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      if (cur) {
        setCurrentInstance(cur);
      } else {
        unsetCurrentInstance();
      }
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i2 = 0; i2 < segments.length && cur; i2++) {
          cur = cur[segments[i2]];
        }
        return cur;
      };
    }
    function traverse(value, seen) {
      if (!isObject$2(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse(value.value, seen);
      } else if (isArray$3(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          traverse(value[i2], seen);
        }
      } else if (isSet$2(value) || isMap$2(value)) {
        value.forEach((v) => {
          traverse(v, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], seen);
        }
      }
      return value;
    }
    function withDirectives(vnode, directives) {
      const internalInstance = currentRenderingInstance;
      if (internalInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i2 = 0; i2 < directives.length; i2++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
        if (dir) {
          if (isFunction$3(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        const binding = bindings[i2];
        if (oldBindings) {
          binding.oldValue = oldBindings[i2].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children2 = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children2 || !children2.length) {
            return;
          }
          let child = children2[0];
          if (children2.length > 1) {
            for (const c2 of children2) {
              if (c2.type !== Comment) {
                child = c2;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el._leaveCb = () => {
                  earlyRemove();
                  el._leaveCb = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$3(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el._leaveCb) {
            el._leaveCb(
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
            leavingVNode.el._leaveCb();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el._enterCb = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el._enterCb = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el._enterCb) {
            el._enterCb(
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el._leaveCb = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el._leaveCb = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children2, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i2 = 0; i2 < children2.length; i2++) {
        let child = children2[i2];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i2 = 0; i2 < ret.length; i2++) {
          ret[i2].patchFlag = -2;
        }
      }
      return ret;
    }
    function defineComponent(options, extraOptions) {
      return isFunction$3(options) ? (
        // #8326: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend$2({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove$2(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          unsetCurrentInstance();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
    );
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$2(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
            /* do not include inferred name to avoid breaking existing code */
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
    }
    function renderList(source, renderItem, cache, index2) {
      let ret;
      const cached = cache && cache[index2];
      if (isArray$3(source) || isString$2(source)) {
        ret = new Array(source.length);
        for (let i2 = 0, l = source.length; i2 < l; i2++) {
          ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i2 = 0; i2 < source; i2++) {
          ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
        }
      } else if (isObject$2(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
            const key = keys2[i2];
            ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index2] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
        const slot = dynamicSlots[i2];
        if (isArray$3(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res)
              res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    const getPublicInstance = (i2) => {
      if (!i2)
        return null;
      if (isStatefulComponent(i2))
        return getExposeProxy(i2) || i2.proxy;
      return getPublicInstance(i2.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
        $: (i2) => i2,
        $el: (i2) => i2.vnode.el,
        $data: (i2) => i2.data,
        $props: (i2) => i2.props,
        $attrs: (i2) => i2.attrs,
        $slots: (i2) => i2.slots,
        $refs: (i2) => i2.refs,
        $parent: (i2) => getPublicInstance(i2.parent),
        $root: (i2) => getPublicInstance(i2.root),
        $emit: (i2) => i2.emit,
        $options: (i2) => resolveMergedOptions(i2),
        $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
        $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
        $watch: (i2) => instanceWatch.bind(i2)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function useSlots() {
      return getContext().slots;
    }
    function useAttrs$1() {
      return getContext().attrs;
    }
    function getContext() {
      const i2 = getCurrentInstance();
      return i2.setupContext || (i2.setupContext = createSetupContext(i2));
    }
    function normalizePropsOrEmits(props) {
      return isArray$3(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$3(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$2(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v) => c2.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$3(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$3(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$3(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$2(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
              /* treat default function as factory */
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$3(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$2(raw)) {
        const handler = ctx[raw];
        if (isFunction$3(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$3(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$2(raw)) {
        if (isArray$3(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$3(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base2 = instance.type;
      const { mixins, extends: extendsOptions } = base2;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base2);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base2;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base2, optionMergeStrategies);
      }
      if (isObject$2(base2)) {
        cache.set(base2, resolved);
      }
      return resolved;
    }
    function mergeOptions(to, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m2) => mergeOptions(to, m2, strats, true)
        );
      }
      for (const key in from) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
      }
      return to;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to, from) {
      if (!from) {
        return to;
      }
      if (!to) {
        return from;
      }
      return function mergedDataFn() {
        return extend$2(
          isFunction$3(to) ? to.call(this, this) : to,
          isFunction$3(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to, from) {
      return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$3(raw)) {
        const res = {};
        for (let i2 = 0; i2 < raw.length; i2++) {
          res[raw[i2]] = raw[i2];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to, from) {
      return to ? [...new Set([].concat(to, from))] : from;
    }
    function mergeObjectOptions(to, from) {
      return to ? extend$2(/* @__PURE__ */ Object.create(null), to, from) : from;
    }
    function mergeEmitsOrPropsOptions(to, from) {
      if (to) {
        if (isArray$3(to) && isArray$3(from)) {
          return [.../* @__PURE__ */ new Set([...to, ...from])];
        }
        return extend$2(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to, from) {
      if (!to)
        return from;
      if (!from)
        return to;
      const merged = extend$2(/* @__PURE__ */ Object.create(null), to);
      for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$3(rootComponent)) {
          rootComponent = extend$2({}, rootComponent);
        }
        if (rootProps != null && !isObject$2(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new Set();
        let isMounted = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$3(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app, ...options);
            } else if (isFunction$3(plugin)) {
              installedPlugins.add(plugin);
              plugin(app, ...options);
            } else
              ;
            return app;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, isSVG2) {
            if (!isMounted) {
              const vnode = createVNode(
                rootComponent,
                rootProps
              );
              vnode.appContext = context;
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render2(vnode, rootContainer, isSVG2);
              }
              isMounted = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted) {
              render2(null, app._container);
              delete app._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app;
          },
          runWithContext(fn2) {
            currentApp = app;
            try {
              return fn2();
            } finally {
              currentApp = null;
            }
          }
        };
        return app;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            let key = propsToUpdate[i2];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                  /* isAbsent */
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                  /* isAbsent */
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i2 = 0; i2 < needCastKeys.length; i2++) {
          const key = needCastKeys[i2];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$3(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              unsetCurrentInstance();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$3(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend$2(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$2(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$3(raw)) {
        for (let i2 = 0; i2 < raw.length; i2++) {
          const normalizedKey = camelize(raw[i2]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$3(opt) || isFunction$3(opt) ? { type: opt } : extend$2({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[
                0
                /* shouldCast */
              ] = booleanIndex > -1;
              prop[
                1
                /* shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$2(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$") {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
      return match ? match[2] : ctor === null ? "null" : "";
    }
    function isSameType(a2, b) {
      return getType(a2) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
      if (isArray$3(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type));
      } else if (isFunction$3(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$3(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$3(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children2) => {
      const normalized = normalizeSlotValue(children2);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children2) => {
      if (instance.vnode.shapeFlag & 32) {
        const type = children2._;
        if (type) {
          instance.slots = toRaw(children2);
          def(children2, "_", type);
        } else {
          normalizeObjectSlots(
            children2,
            instance.slots = {}
          );
        }
      } else {
        instance.slots = {};
        if (children2) {
          normalizeVNodeSlots(instance, children2);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children2, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children2._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            extend$2(slots, children2);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children2.$stable;
          normalizeObjectSlots(children2, slots);
        }
        deletionComparisonTarget = children2;
      } else if (children2) {
        normalizeVNodeSlots(instance, children2);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$3(rawRef)) {
        rawRef.forEach(
          (r, i2) => setRef(
            r,
            oldRawRef && (isArray$3(oldRawRef) ? oldRawRef[i2] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref2 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref2) {
        if (isString$2(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$3(ref2)) {
        callWithErrorHandling(ref2, owner, 12, [value, refs]);
      } else {
        const _isString = isString$2(ref2);
        const _isRef = isRef(ref2);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
              if (isUnmount) {
                isArray$3(existing) && remove$2(existing, refValue);
              } else {
                if (!isArray$3(existing)) {
                  if (_isString) {
                    refs[ref2] = [refValue];
                    if (hasOwn(setupState, ref2)) {
                      setupState[ref2] = refs[ref2];
                    }
                  } else {
                    ref2.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref2.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref2] = value;
              if (hasOwn(setupState, ref2)) {
                setupState[ref2] = value;
              }
            } else if (_isRef) {
              ref2.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG2 = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref2, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, isSVG2);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized,
                internals
              );
            } else
              ;
        }
        if (ref2 != null && parentComponent) {
          setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, isSVG2) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          isSVG2,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        isSVG2 = isSVG2 || n2.type === "svg";
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          isSVG2,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            isSVG2 && type !== "foreignObject",
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(
                el,
                key,
                null,
                props[key],
                isSVG2,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
            hostSetScopeId(el, slotScopeIds[i2]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, start2 = 0) => {
        for (let i2 = start2; i2 < children2.length; i2++) {
          const child = children2[i2] = optimized ? cloneIfMounted(children2[i2]) : normalizeVNode(children2[i2]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        const areChildrenSVG = isSVG2 && n2.type !== "foreignObject";
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            areChildrenSVG,
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            areChildrenSVG,
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              isSVG2
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, isSVG2);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG2);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                const key = propsToUpdate[i2];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(
                    el,
                    key,
                    prev,
                    next,
                    isSVG2,
                    n1.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            isSVG2
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG2, slotScopeIds) => {
        for (let i2 = 0; i2 < newChildren.length; i2++) {
          const oldVNode = oldChildren[i2];
          const newVNode = newChildren[i2];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG2) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  isSVG2,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG2,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            n2.children,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              isSVG2,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG2, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
          return;
        }
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          isSVG2,
          optimized
        );
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG2, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m: m2, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                isSVG2
              );
              initialVNode.el = subTree.el;
            }
            if (m2) {
              queuePostRenderEffect(m2, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u: u2, parent, vnode } = instance;
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              isSVG2
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u2) {
              queuePostRenderEffect(u2, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => effect.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs();
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i2;
        for (i2 = 0; i2 < commonLength; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          patch(
            c1[i2],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG2,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized) => {
        let i2 = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e22 = l2 - 1;
        while (i2 <= e1 && i2 <= e22) {
          const n1 = c1[i2];
          const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i2++;
        }
        while (i2 <= e1 && i2 <= e22) {
          const n1 = c1[e1];
          const n2 = c2[e22] = optimized ? cloneIfMounted(c2[e22]) : normalizeVNode(c2[e22]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e22--;
        }
        if (i2 > e1) {
          if (i2 <= e22) {
            const nextPos = e22 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i2 <= e22) {
              patch(
                null,
                c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
              i2++;
            }
          }
        } else if (i2 > e22) {
          while (i2 <= e1) {
            unmount(c1[i2], parentComponent, parentSuspense, true);
            i2++;
          }
        } else {
          const s1 = i2;
          const s2 = i2;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i2 = s2; i2 <= e22; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i2);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e22 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i2 = 0; i2 < toBePatched; i2++)
            newIndexToOldIndexMap[i2] = 0;
          for (i2 = s1; i2 <= e1; i2++) {
            const prevChild = c1[i2];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e22; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i2 = toBePatched - 1; i2 >= 0; i2--) {
            const nextIndex = s2 + i2;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i2] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children: children2, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i2 = 0; i2 < children2.length; i2++) {
            move(children2[i2], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref2,
          children: children2,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs
        } = vnode;
        if (ref2 != null) {
          setRef(ref2, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children2, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end) => {
        let next;
        while (cur !== end) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children2, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
        for (let i2 = start2; i2 < children2.length; i2++) {
          unmount(children2[i2], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      const render2 = (vnode, container, isSVG2) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(container._vnode || null, vnode, container, null, null, null, isSVG2);
        }
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render: render2,
        hydrate,
        createApp: createAppAPI(render2, hydrate)
      };
    }
    function toggleRecurse({ effect, update }, allowed) {
      effect.allowRecurse = update.allowRecurse = allowed;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$3(ch1) && isArray$3(ch2)) {
        for (let i2 = 0; i2 < ch1.length; i2++) {
          const c1 = ch1[i2];
          let c2 = ch2[i2];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i2, j, u2, v, c2;
      const len = arr.length;
      for (i2 = 0; i2 < len; i2++) {
        const arrI = arr[i2];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i2] = j;
            result.push(i2);
            continue;
          }
          u2 = 0;
          v = result.length - 1;
          while (u2 < v) {
            c2 = u2 + v >> 1;
            if (arr[result[c2]] < arrI) {
              u2 = c2 + 1;
            } else {
              v = c2;
            }
          }
          if (arrI < arr[result[u2]]) {
            if (u2 > 0) {
              p2[i2] = result[u2 - 1];
            }
            result[u2] = i2;
          }
        }
      }
      u2 = result.length;
      v = result[u2 - 1];
      while (u2-- > 0) {
        result[u2] = v;
        v = p2[v];
      }
      return result;
    }
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const resolveTarget = (props, select2) => {
      const targetSelector = props && props.to;
      if (isString$2(targetSelector)) {
        if (!select2) {
          return null;
        } else {
          const target = select2(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG2, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children: children2, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            isSVG2 = isSVG2 || isTargetSVG(target);
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children2,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                isSVG2,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          isSVG2 = isSVG2 || isTargetSVG(target);
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              isSVG2,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children: children2, anchor, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        if (doRemove || !isTeleportDisabled(props)) {
          hostRemove(anchor);
          if (shapeFlag & 16) {
            for (let i2 = 0; i2 < children2.length; i2++) {
              const child = children2[i2];
              unmount(
                child,
                parentComponent,
                parentSuspense,
                true,
                !!child.dynamicChildren
              );
            }
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children: children2, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i2 = 0; i2 < children2.length; i2++) {
            move(
              children2[i2],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(
              targetNode,
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children2, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children2,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
          /* isBlock */
        )
      );
    }
    function createBlock(type, props, children2, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children2,
          patchFlag,
          dynamicProps,
          true
          /* isBlock: prevent a block from tracking itself */
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref2,
      ref_key,
      ref_for
    }) => {
      if (typeof ref2 === "number") {
        ref2 = "" + ref2;
      }
      return ref2 != null ? isString$2(ref2) || isRef(ref2) || isFunction$3(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
    };
    function createBaseVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children: children2,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children2);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children2) {
        vnode.shapeFlag |= isString$2(children2) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children2) {
          normalizeChildren(cloned, children2);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$2(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$2(style)) {
          if (isProxy(style) && !isArray$3(style)) {
            style = extend$2({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$3(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children2,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend$2({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref2, patchFlag, children: children2 } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref2 ? isArray$3(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref2,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: children2,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$3(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children2) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children2 == null) {
        children2 = null;
      } else if (isArray$3(children2)) {
        type = 16;
      } else if (typeof children2 === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children2.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children2._;
          if (!slotFlag && !(InternalObjectKey in children2)) {
            children2._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children2._ = 1;
            } else {
              children2._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$3(children2)) {
        children2 = { default: children2, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children2 = String(children2);
        if (shapeFlag & 64) {
          type = 16;
          children2 = [createTextVNode(children2)];
        } else {
          type = 8;
        }
      }
      vnode.children = children2;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i2 = 0; i2 < args.length; i2++) {
        const toMerge = args[i2];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$3(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let globalCurrentInstanceSetters;
    let settersKey = "__VUE_INSTANCE_SETTERS__";
    {
      if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
        globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
      }
      globalCurrentInstanceSetters.push((i2) => currentInstance = i2);
      internalSetCurrentInstance = (instance) => {
        if (globalCurrentInstanceSetters.length > 1) {
          globalCurrentInstanceSetters.forEach((s) => s(instance));
        } else {
          globalCurrentInstanceSetters[0](instance);
        }
      };
    }
    const setCurrentInstance = (instance) => {
      internalSetCurrentInstance(instance);
      instance.scope.on();
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isInSSRComponentSetup = isSSR;
      const { props, children: children2 } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children2);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isInSSRComponentSetup = false;
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [instance.props, setupContext]
        );
        resetTracking();
        unsetCurrentInstance();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e3) => {
              handleError(e3, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$3(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$2(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement: isCustomElement2, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend$2(
              extend$2(
                {
                  isCustomElement: isCustomElement2,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        setCurrentInstance(instance);
        pauseTracking();
        applyOptions(instance);
        resetTracking();
        unsetCurrentInstance();
      }
    }
    function getAttrsProxy(instance) {
      return instance.attrsProxy || (instance.attrsProxy = new Proxy(
        instance.attrs,
        {
          get(target, key) {
            track(instance, "get", "$attrs");
            return target[key];
          }
        }
      ));
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          get attrs() {
            return getAttrsProxy(instance);
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      }
    }
    function getComponentName(Component, includeInferred = true) {
      return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function isClassComponent(value) {
      return isFunction$3(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function h(type, propsOrChildren, children2) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$2(propsOrChildren) && !isArray$3(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children2 = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children2)) {
          children2 = [children2];
        }
        return createVNode(type, propsOrChildren, children2);
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        return ctx;
      }
    };
    const version = "3.3.4";
    const svgNS = "http://www.w3.org/2000/svg";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, isSVG2, is, props) => {
        const el = isSVG2 ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector2) => doc.querySelector(selector2),
      setScopeId(el, id2) {
        el.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content2, parent, anchor, isSVG2, start2, end) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start2 && (start2 === end || start2.nextSibling)) {
          while (true) {
            parent.insertBefore(start2.cloneNode(true), anchor);
            if (start2 === end || !(start2 = start2.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = isSVG2 ? `<svg>${content2}</svg>` : content2;
          const template = templateContainer.content;
          if (isSVG2) {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    function patchClass(el, value, isSVG2) {
      const transitionClasses = el._vtc;
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG2) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString$2(next);
      if (next && !isCssString) {
        if (prev && !isString$2(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
        for (const key in next) {
          setStyle(style, key, next[key]);
        }
      } else {
        const currentDisplay = style.display;
        if (isCssString) {
          if (prev !== next) {
            style.cssText = next;
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
        if ("_vod" in el) {
          style.display = currentDisplay;
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$3(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes$1 = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize$1(name);
      for (let i2 = 0; i2 < prefixes$1.length; i2++) {
        const prefixed = prefixes$1[i2] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG2, instance) {
      if (isSVG2 && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean2 = isSpecialBooleanAttr(key);
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean2 ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e3) {
      }
      needRemove && el.removeAttribute(key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el._vei || (el._vei = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m2;
        while (m2 = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m2[0].length);
          options[m2[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e3) => {
        if (!e3._vts) {
          e3._vts = Date.now();
        } else if (e3._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e3, invoker.value),
          instance,
          5,
          [e3]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e3, value) {
      if (isArray$3(value)) {
        const originalStop = e3.stopImmediatePropagation;
        e3.stopImmediatePropagation = () => {
          originalStop.call(e3);
          e3._stopped = true;
        };
        return value.map((fn2) => (e22) => !e22._stopped && fn2 && fn2(e22));
      } else {
        return value;
      }
    }
    const nativeOnRE = /^on[a-z]/;
    const patchProp = (el, key, prevValue, nextValue, isSVG2 = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      if (key === "class") {
        patchClass(el, nextValue, isSVG2);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG2)) {
        patchDOMProp(
          el,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG2);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG2) {
      if (isSVG2) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && nativeOnRE.test(key) && isFunction$3(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (nativeOnRE.test(key) && isString$2(value)) {
        return false;
      }
      return key in el;
    }
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const Transition$1 = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
    Transition$1.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition$1.props = /* @__PURE__ */ extend$2(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook, args = []) => {
      if (isArray$3(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$3(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration: duration2,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration2);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend$2(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration2) {
      if (duration2 == null) {
        return null;
      } else if (isObject$2(duration2)) {
        return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
      } else {
        const n = NumberOf(duration2);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber$1(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
      (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
      const { _vtc } = el;
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el._vtc = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id2 = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout: timeout2, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e3) => {
        if (e3.target === el && ++ended >= propCount) {
          end();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end();
        }
      }, timeout2 + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout2 = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout2 = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout2 = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout2 = Math.max(transitionTimeout, animationTimeout);
        type = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout: timeout2,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
    }
    function toMs(s) {
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend$2({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children2;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c2) => {
            const el = c2.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el._moveCb = (e3) => {
              if (e3 && e3.target !== el) {
                return;
              }
              if (!e3 || /transform$/.test(e3.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el._moveCb = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children2;
          children2 = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i2 = 0; i2 < children2.length; i2++) {
            const child = children2[i2];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          if (prevChildren) {
            for (let i2 = 0; i2 < prevChildren.length; i2++) {
              const child = prevChildren[i2];
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children2);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c2) {
      const el = c2.el;
      if (el._moveCb) {
        el._moveCb();
      }
      if (el._enterCb) {
        el._enterCb();
      }
    }
    function recordPosition(c2) {
      newPositionMap.set(c2, c2.el.getBoundingClientRect());
    }
    function applyTranslation(c2) {
      const oldPos = positionMap.get(c2);
      const newPos = newPositionMap.get(c2);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c2.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c2;
      }
    }
    function hasCSSTransform(el, root2, moveClass) {
      const clone = el.cloneNode();
      if (el._vtc) {
        el._vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
        });
      }
      moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
      clone.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone);
      const { hasTransform } = getTransitionInfo(clone);
      container.removeChild(clone);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn2 = vnode.props["onUpdate:modelValue"] || false;
      return isArray$3(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
    };
    function onCompositionStart(e3) {
      e3.target.composing = true;
    }
    function onCompositionEnd(e3) {
      const target = e3.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const vModelText = {
      created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e3) => {
          if (e3.target.composing)
            return;
          let domValue = el.value;
          if (trim2) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el._assign(domValue);
        });
        if (trim2) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (el.composing)
          return;
        if (document.activeElement === el && el.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim2 && el.value.trim() === value) {
            return;
          }
          if ((number || el.type === "number") && looseToNumber(el.value) === value) {
            return;
          }
        }
        const newValue = value == null ? "" : value;
        if (el.value !== newValue) {
          el.value = newValue;
        }
      }
    };
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e3) => e3.stopPropagation(),
      prevent: (e3) => e3.preventDefault(),
      self: (e3) => e3.target !== e3.currentTarget,
      ctrl: (e3) => !e3.ctrlKey,
      shift: (e3) => !e3.shiftKey,
      alt: (e3) => !e3.altKey,
      meta: (e3) => !e3.metaKey,
      left: (e3) => "button" in e3 && e3.button !== 0,
      middle: (e3) => "button" in e3 && e3.button !== 1,
      right: (e3) => "button" in e3 && e3.button !== 2,
      exact: (e3, modifiers) => systemModifiers.some((m2) => e3[`${m2}Key`] && !modifiers.includes(m2))
    };
    const withModifiers = (fn2, modifiers) => {
      return (event, ...args) => {
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const guard = modifierGuards[modifiers[i2]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn2(event, ...args);
      };
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn2, modifiers) => {
      return (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn2(event);
        }
      };
    };
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el._vod : "none";
    }
    const rendererOptions = /* @__PURE__ */ extend$2({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const render = (...args) => {
      ensureRenderer().render(...args);
    };
    const createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app._component;
        if (!isFunction$3(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    function normalizeContainer(container) {
      if (isString$2(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
      const handleEvent = (event) => {
        const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
        if (checkForDefaultPrevented === false || !shouldPrevent) {
          return oursHandler == null ? void 0 : oursHandler(event);
        }
      };
      return handleEvent;
    };
    var _a;
    const isClient = typeof window !== "undefined";
    const isDef = (val) => typeof val !== "undefined";
    const isFunction$2 = (val) => typeof val === "function";
    const isString$1 = (val) => typeof val === "string";
    const noop$2 = () => {
    };
    const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
    function resolveUnref(r) {
      return typeof r === "function" ? r() : unref(r);
    }
    function identity$4(arg) {
      return arg;
    }
    function tryOnScopeDispose(fn2) {
      if (getCurrentScope()) {
        onScopeDispose(fn2);
        return true;
      }
      return false;
    }
    function tryOnMounted(fn2, sync = true) {
      if (getCurrentInstance())
        onMounted(fn2);
      else if (sync)
        fn2();
      else
        nextTick(fn2);
    }
    function useTimeoutFn(cb, interval2, options = {}) {
      const {
        immediate = true
      } = options;
      const isPending = ref(false);
      let timer2 = null;
      function clear2() {
        if (timer2) {
          clearTimeout(timer2);
          timer2 = null;
        }
      }
      function stop() {
        isPending.value = false;
        clear2();
      }
      function start2(...args) {
        clear2();
        isPending.value = true;
        timer2 = setTimeout(() => {
          isPending.value = false;
          timer2 = null;
          cb(...args);
        }, resolveUnref(interval2));
      }
      if (immediate) {
        isPending.value = true;
        if (isClient)
          start2();
      }
      tryOnScopeDispose(stop);
      return {
        isPending: readonly(isPending),
        start: start2,
        stop
      };
    }
    function unrefElement(elRef) {
      var _a2;
      const plain = resolveUnref(elRef);
      return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
    }
    const defaultWindow = isClient ? window : void 0;
    function useEventListener(...args) {
      let target;
      let events;
      let listeners;
      let options;
      if (isString$1(args[0]) || Array.isArray(args[0])) {
        [events, listeners, options] = args;
        target = defaultWindow;
      } else {
        [target, events, listeners, options] = args;
      }
      if (!target)
        return noop$2;
      if (!Array.isArray(events))
        events = [events];
      if (!Array.isArray(listeners))
        listeners = [listeners];
      const cleanups = [];
      const cleanup = () => {
        cleanups.forEach((fn2) => fn2());
        cleanups.length = 0;
      };
      const register = (el, event, listener, options2) => {
        el.addEventListener(event, listener, options2);
        return () => el.removeEventListener(event, listener, options2);
      };
      const stopWatch = watch(() => [unrefElement(target), resolveUnref(options)], ([el, options2]) => {
        cleanup();
        if (!el)
          return;
        cleanups.push(...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, options2));
        }));
      }, { immediate: true, flush: "post" });
      const stop = () => {
        stopWatch();
        cleanup();
      };
      tryOnScopeDispose(stop);
      return stop;
    }
    let _iOSWorkaround = false;
    function onClickOutside(target, handler, options = {}) {
      const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
      if (!window2)
        return;
      if (isIOS && !_iOSWorkaround) {
        _iOSWorkaround = true;
        Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop$2));
      }
      let shouldListen = true;
      const shouldIgnore = (event) => {
        return ignore.some((target2) => {
          if (typeof target2 === "string") {
            return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
          } else {
            const el = unrefElement(target2);
            return el && (event.target === el || event.composedPath().includes(el));
          }
        });
      };
      const listener = (event) => {
        const el = unrefElement(target);
        if (!el || el === event.target || event.composedPath().includes(el))
          return;
        if (event.detail === 0)
          shouldListen = !shouldIgnore(event);
        if (!shouldListen) {
          shouldListen = true;
          return;
        }
        handler(event);
      };
      const cleanup = [
        useEventListener(window2, "click", listener, { passive: true, capture }),
        useEventListener(window2, "pointerdown", (e3) => {
          const el = unrefElement(target);
          if (el)
            shouldListen = !e3.composedPath().includes(el) && !shouldIgnore(e3);
        }, { passive: true }),
        detectIframe && useEventListener(window2, "blur", (event) => {
          var _a2;
          const el = unrefElement(target);
          if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
            handler(event);
        })
      ].filter(Boolean);
      const stop = () => cleanup.forEach((fn2) => fn2());
      return stop;
    }
    function useSupported(callback, sync = false) {
      const isSupported = ref();
      const update = () => isSupported.value = Boolean(callback());
      update();
      tryOnMounted(update, sync);
      return isSupported;
    }
    function cloneFnJSON(source) {
      return JSON.parse(JSON.stringify(source));
    }
    const _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    const globalKey = "__vueuse_ssr_handlers__";
    _global$1[globalKey] = _global$1[globalKey] || {};
    var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
    var __hasOwnProp$g = Object.prototype.hasOwnProperty;
    var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
    var __objRest$2 = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$g.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$g)
        for (var prop of __getOwnPropSymbols$g(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$g.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    function useResizeObserver(target, callback, options = {}) {
      const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
      let observer;
      const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
      const cleanup = () => {
        if (observer) {
          observer.disconnect();
          observer = void 0;
        }
      };
      const stopWatch = watch(() => unrefElement(target), (el) => {
        cleanup();
        if (isSupported.value && window2 && el) {
          observer = new ResizeObserver(callback);
          observer.observe(el, observerOptions);
        }
      }, { immediate: true, flush: "post" });
      const stop = () => {
        cleanup();
        stopWatch();
      };
      tryOnScopeDispose(stop);
      return {
        isSupported,
        stop
      };
    }
    var SwipeDirection;
    (function(SwipeDirection2) {
      SwipeDirection2["UP"] = "UP";
      SwipeDirection2["RIGHT"] = "RIGHT";
      SwipeDirection2["DOWN"] = "DOWN";
      SwipeDirection2["LEFT"] = "LEFT";
      SwipeDirection2["NONE"] = "NONE";
    })(SwipeDirection || (SwipeDirection = {}));
    var __defProp2 = Object.defineProperty;
    var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues2 = (a2, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp2(a2, prop, b[prop]);
      if (__getOwnPropSymbols2)
        for (var prop of __getOwnPropSymbols2(b)) {
          if (__propIsEnum2.call(b, prop))
            __defNormalProp2(a2, prop, b[prop]);
        }
      return a2;
    };
    const _TransitionPresets = {
      easeInSine: [0.12, 0, 0.39, 0],
      easeOutSine: [0.61, 1, 0.88, 1],
      easeInOutSine: [0.37, 0, 0.63, 1],
      easeInQuad: [0.11, 0, 0.5, 0],
      easeOutQuad: [0.5, 1, 0.89, 1],
      easeInOutQuad: [0.45, 0, 0.55, 1],
      easeInCubic: [0.32, 0, 0.67, 0],
      easeOutCubic: [0.33, 1, 0.68, 1],
      easeInOutCubic: [0.65, 0, 0.35, 1],
      easeInQuart: [0.5, 0, 0.75, 0],
      easeOutQuart: [0.25, 1, 0.5, 1],
      easeInOutQuart: [0.76, 0, 0.24, 1],
      easeInQuint: [0.64, 0, 0.78, 0],
      easeOutQuint: [0.22, 1, 0.36, 1],
      easeInOutQuint: [0.83, 0, 0.17, 1],
      easeInExpo: [0.7, 0, 0.84, 0],
      easeOutExpo: [0.16, 1, 0.3, 1],
      easeInOutExpo: [0.87, 0, 0.13, 1],
      easeInCirc: [0.55, 0, 1, 0.45],
      easeOutCirc: [0, 0.55, 0.45, 1],
      easeInOutCirc: [0.85, 0, 0.15, 1],
      easeInBack: [0.36, 0, 0.66, -0.56],
      easeOutBack: [0.34, 1.56, 0.64, 1],
      easeInOutBack: [0.68, -0.6, 0.32, 1.6]
    };
    __spreadValues2({
      linear: identity$4
    }, _TransitionPresets);
    function useVModel(props, key, emit2, options = {}) {
      var _a2, _b, _c;
      const {
        clone = false,
        passive = false,
        eventName,
        deep = false,
        defaultValue
      } = options;
      const vm = getCurrentInstance();
      const _emit = emit2 || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
      let event = eventName;
      if (!key) {
        {
          key = "modelValue";
        }
      }
      event = eventName || event || `update:${key.toString()}`;
      const cloneFn = (val) => !clone ? val : isFunction$2(clone) ? clone(val) : cloneFnJSON(val);
      const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
      if (passive) {
        const initialValue = getValue2();
        const proxy = ref(initialValue);
        watch(() => props[key], (v) => proxy.value = cloneFn(v));
        watch(proxy, (v) => {
          if (v !== props[key] || deep)
            _emit(event, v);
        }, { deep });
        return proxy;
      } else {
        return computed({
          get() {
            return getValue2();
          },
          set(value) {
            _emit(event, value);
          }
        });
      }
    }
    const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    const freeGlobal$1 = freeGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root$2 = freeGlobal$1 || freeSelf || Function("return this")();
    const root$3 = root$2;
    var Symbol$1 = root$3.Symbol;
    const Symbol$2 = Symbol$1;
    var objectProto$e = Object.prototype;
    var hasOwnProperty$c = objectProto$e.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$e.toString;
    var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e3) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$d = Object.prototype;
    var nativeObjectToString = objectProto$d.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag$3 = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
    }
    function arrayMap(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    var isArray$1 = Array.isArray;
    const isArray$2 = isArray$1;
    var INFINITY$1 = 1 / 0;
    var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray$2(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function isObject$1(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject$1(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject$1(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction$1(value) {
      if (!isObject$1(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$3["__core-js_shared__"];
    const coreJsData$1 = coreJsData;
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$1 = Function.prototype;
    var funcToString$1 = funcProto$1.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e3) {
        }
        try {
          return func + "";
        } catch (e3) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto$c = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$b = objectProto$c.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$1(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var WeakMap$1 = getNative(root$3, "WeakMap");
    const WeakMap$2 = WeakMap$1;
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object2() {
      }
      return function(proto2) {
        if (!isObject$1(proto2)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto2);
        }
        object2.prototype = proto2;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    const baseCreate$1 = baseCreate;
    function copyArray(source, array2) {
      var index2 = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index2 < length) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e3) {
      }
    }();
    const defineProperty$1 = defineProperty;
    function arrayEach(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty$1) {
        defineProperty$1(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$b = Object.prototype;
    var hasOwnProperty$a = objectProto$b.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$a.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key = props[index2];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength$1(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength$1(value.length) && !isFunction$1(value);
    }
    var objectProto$a = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
      return value === proto2;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var argsTag$3 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$3;
    }
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    const isArguments$1 = isArguments;
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$2 = moduleExports$2 ? root$3.Buffer : void 0;
    var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
    var isBuffer$1 = nativeIsBuffer || stubFalse;
    const isBuffer$2 = isBuffer$1;
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal$1.process;
    var nodeUtil = function() {
      try {
        var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    const nodeUtil$1 = nodeUtil;
    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
    var isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    const isTypedArray$2 = isTypedArray$1;
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray$2(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    const nativeKeys$1 = nativeKeys;
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys$1(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$7.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject$1(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray$2(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    var nativeCreate = getNative(Object, "create");
    const nativeCreate$1 = nativeCreate;
    function hashClear() {
      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate$1) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$2 = getNative(root$3, "Map");
    const Map$3 = Map$2;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$3 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    const stringToPath$1 = stringToPath;
    function toString$1(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object2) {
      if (isArray$2(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath$1(toString$1(value));
    }
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseGet(object2, path) {
      path = castPath(path, object2);
      var index2 = 0, length = path.length;
      while (object2 != null && index2 < length) {
        object2 = object2[toKey(path[index2++])];
      }
      return index2 && index2 == length ? object2 : void 0;
    }
    function get$2(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    function arrayPush(array2, values) {
      var index2 = -1, length = values.length, offset = array2.length;
      while (++index2 < length) {
        array2[offset + index2] = values[index2];
      }
      return array2;
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    const getPrototype$1 = getPrototype;
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$3 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys(source), object2);
    }
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn(source), object2);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer$1 = moduleExports ? root$3.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function arrayFilter(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$3 = Object.prototype;
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    const getSymbols$1 = getSymbols;
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols$1(source), object2);
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush(result, getSymbols$1(object2));
        object2 = getPrototype$1(object2);
      }
      return result;
    };
    const getSymbolsIn$1 = getSymbolsIn;
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn$1(source), object2);
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray$2(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols$1);
    }
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn, getSymbolsIn$1);
    }
    var DataView$1 = getNative(root$3, "DataView");
    const DataView$2 = DataView$1;
    var Promise$1 = getNative(root$3, "Promise");
    const Promise$2 = Promise$1;
    var Set$2 = getNative(root$3, "Set");
    const Set$3 = Set$2;
    var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$3 = "[object DataView]";
    var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$3), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$3), weakMapCtorString = toSource(WeakMap$2);
    var getTag = baseGetTag;
    if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$3 || Map$3 && getTag(new Map$3()) != mapTag$4 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$3 && getTag(new Set$3()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$3;
            case mapCtorString:
              return mapTag$4;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$4;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    const getTag$1 = getTag;
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
    function initCloneArray(array2) {
      var length = array2.length, result = new array2.constructor(length);
      if (length && typeof array2[0] == "string" && hasOwnProperty$3.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    var Uint8Array$1 = root$3.Uint8Array;
    const Uint8Array$2 = Uint8Array$1;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag$2:
          return cloneArrayBuffer(object2);
        case boolTag$2:
        case dateTag$2:
          return new Ctor(+object2);
        case dataViewTag$2:
          return cloneDataView(object2, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object2, isDeep);
        case mapTag$3:
          return new Ctor();
        case numberTag$2:
        case stringTag$2:
          return new Ctor(object2);
        case regexpTag$2:
          return cloneRegExp(object2);
        case setTag$3:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object2);
      }
    }
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
    }
    var mapTag$2 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag$1(value) == mapTag$2;
    }
    var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    const isMap$1 = isMap;
    var setTag$2 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag$1(value) == setTag$2;
    }
    var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    const isSet$1 = isSet;
    var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object2, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
      if (customizer) {
        result = object2 ? customizer(value, key, object2, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject$1(value)) {
        return value;
      }
      var isArr = isArray$2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer$2(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet$1(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap$1(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object2), new Uint8Array$2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var COMPARE_PARTIAL_FLAG$1 = 1;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty$1 = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray$2(object2), othIsArr = isArray$2(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer$2(object2)) {
        if (!isBuffer$2(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray$2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty$1.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    var now$1 = function() {
      return root$3.Date.now();
    };
    const now$2 = now$1;
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject$1(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now$2();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now$2());
      }
      function debounced() {
        var time2 = now$2(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function fromPairs(pairs) {
      var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
      while (++index2 < length) {
        var pair = pairs[index2];
        result[pair[0]] = pair[1];
      }
      return result;
    }
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isNil(value) {
      return value == null;
    }
    function isUndefined$2(value) {
      return value === void 0;
    }
    const isUndefined$1 = (val) => val === void 0;
    const isBoolean$1 = (val) => typeof val === "boolean";
    const isNumber$1 = (val) => typeof val === "number";
    const isElement = (e3) => {
      if (typeof Element === "undefined")
        return false;
      return e3 instanceof Element;
    };
    const isStringNumber = (val) => {
      if (!isString$2(val)) {
        return false;
      }
      return !Number.isNaN(Number(val));
    };
    const escapeStringRegexp = (string = "") => string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    const keysOf = (arr) => Object.keys(arr);
    const entriesOf = (arr) => Object.entries(arr);
    class ElementPlusError extends Error {
      constructor(m2) {
        super(m2);
        this.name = "ElementPlusError";
      }
    }
    function throwError(scope, m2) {
      throw new ElementPlusError(`[${scope}] ${m2}`);
    }
    function debugWarn(scope, message2) {
    }
    const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
    const addClass = (el, cls) => {
      if (!el || !cls.trim())
        return;
      el.classList.add(...classNameToArray(cls));
    };
    const removeClass = (el, cls) => {
      if (!el || !cls.trim())
        return;
      el.classList.remove(...classNameToArray(cls));
    };
    const getStyle = (element2, styleName) => {
      var _a2;
      if (!isClient || !element2 || !styleName)
        return "";
      let key = camelize(styleName);
      if (key === "float")
        key = "cssFloat";
      try {
        const style = element2.style[key];
        if (style)
          return style;
        const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element2, "");
        return computed2 ? computed2[key] : "";
      } catch (e3) {
        return element2.style[key];
      }
    };
    function addUnit(value, defaultUnit = "px") {
      if (!value)
        return "";
      if (isNumber$1(value) || isStringNumber(value)) {
        return `${value}${defaultUnit}`;
      } else if (isString$2(value)) {
        return value;
      }
    }
    function scrollIntoView(container, selected) {
      if (!isClient)
        return;
      if (!selected) {
        container.scrollTop = 0;
        return;
      }
      const offsetParents = [];
      let pointer2 = selected.offsetParent;
      while (pointer2 !== null && container !== pointer2 && container.contains(pointer2)) {
        offsetParents.push(pointer2);
        pointer2 = pointer2.offsetParent;
      }
      const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
      const bottom = top + selected.offsetHeight;
      const viewRectTop = container.scrollTop;
      const viewRectBottom = viewRectTop + container.clientHeight;
      if (top < viewRectTop) {
        container.scrollTop = top;
      } else if (bottom > viewRectBottom) {
        container.scrollTop = bottom - container.clientHeight;
      }
    }
    /*! Element Plus Icons Vue v2.1.0 */
    var export_helper_default = (sfc, props) => {
      let target = sfc.__vccOpts || sfc;
      for (let [key, val] of props)
        target[key] = val;
      return target;
    };
    var arrow_down_vue_vue_type_script_lang_default = {
      name: "ArrowDown"
    };
    var _hoisted_16$1 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_26 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_36 = [
      _hoisted_26
    ];
    function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_16$1, _hoisted_36);
    }
    var arrow_down_default = /* @__PURE__ */ export_helper_default(arrow_down_vue_vue_type_script_lang_default, [["render", _sfc_render6], ["__file", "arrow-down.vue"]]);
    var check_vue_vue_type_script_lang_default = {
      name: "Check"
    };
    var _hoisted_143 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_243 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_342 = [
      _hoisted_243
    ];
    function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_143, _hoisted_342);
    }
    var check_default = /* @__PURE__ */ export_helper_default(check_vue_vue_type_script_lang_default, [["render", _sfc_render43], ["__file", "check.vue"]]);
    var circle_check_vue_vue_type_script_lang_default = {
      name: "CircleCheck"
    };
    var _hoisted_149 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_249 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_348 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_415 = [
      _hoisted_249,
      _hoisted_348
    ];
    function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_149, _hoisted_415);
    }
    var circle_check_default = /* @__PURE__ */ export_helper_default(circle_check_vue_vue_type_script_lang_default, [["render", _sfc_render49], ["__file", "circle-check.vue"]]);
    var circle_close_filled_vue_vue_type_script_lang_default = {
      name: "CircleCloseFilled"
    };
    var _hoisted_150 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_250 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_349 = [
      _hoisted_250
    ];
    function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_150, _hoisted_349);
    }
    var circle_close_filled_default = /* @__PURE__ */ export_helper_default(circle_close_filled_vue_vue_type_script_lang_default, [["render", _sfc_render50], ["__file", "circle-close-filled.vue"]]);
    var circle_close_vue_vue_type_script_lang_default = {
      name: "CircleClose"
    };
    var _hoisted_151 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_251 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_350 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_416 = [
      _hoisted_251,
      _hoisted_350
    ];
    function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_151, _hoisted_416);
    }
    var circle_close_default = /* @__PURE__ */ export_helper_default(circle_close_vue_vue_type_script_lang_default, [["render", _sfc_render51], ["__file", "circle-close.vue"]]);
    var close_vue_vue_type_script_lang_default = {
      name: "Close"
    };
    var _hoisted_156 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_256 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_355 = [
      _hoisted_256
    ];
    function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_156, _hoisted_355);
    }
    var close_default = /* @__PURE__ */ export_helper_default(close_vue_vue_type_script_lang_default, [["render", _sfc_render56], ["__file", "close.vue"]]);
    var delete_vue_vue_type_script_lang_default = {
      name: "Delete"
    };
    var _hoisted_180 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_280 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_379 = [
      _hoisted_280
    ];
    function _sfc_render80(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_180, _hoisted_379);
    }
    var delete_default = /* @__PURE__ */ export_helper_default(delete_vue_vue_type_script_lang_default, [["render", _sfc_render80], ["__file", "delete.vue"]]);
    var document_vue_vue_type_script_lang_default = {
      name: "Document"
    };
    var _hoisted_190 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_290 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_389 = [
      _hoisted_290
    ];
    function _sfc_render90(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_190, _hoisted_389);
    }
    var document_default = /* @__PURE__ */ export_helper_default(document_vue_vue_type_script_lang_default, [["render", _sfc_render90], ["__file", "document.vue"]]);
    var hide_vue_vue_type_script_lang_default = {
      name: "Hide"
    };
    var _hoisted_1133 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_2133 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_3132 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_438 = [
      _hoisted_2133,
      _hoisted_3132
    ];
    function _sfc_render133(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1133, _hoisted_438);
    }
    var hide_default = /* @__PURE__ */ export_helper_default(hide_vue_vue_type_script_lang_default, [["render", _sfc_render133], ["__file", "hide.vue"]]);
    var info_filled_vue_vue_type_script_lang_default = {
      name: "InfoFilled"
    };
    var _hoisted_1143 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_2143 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_3142 = [
      _hoisted_2143
    ];
    function _sfc_render143(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1143, _hoisted_3142);
    }
    var info_filled_default = /* @__PURE__ */ export_helper_default(info_filled_vue_vue_type_script_lang_default, [["render", _sfc_render143], ["__file", "info-filled.vue"]]);
    var loading_vue_vue_type_script_lang_default = {
      name: "Loading"
    };
    var _hoisted_1150 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_2150 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_3149 = [
      _hoisted_2150
    ];
    function _sfc_render150(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1150, _hoisted_3149);
    }
    var loading_default = /* @__PURE__ */ export_helper_default(loading_vue_vue_type_script_lang_default, [["render", _sfc_render150], ["__file", "loading.vue"]]);
    var success_filled_vue_vue_type_script_lang_default = {
      name: "SuccessFilled"
    };
    var _hoisted_1249 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_2249 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_3248 = [
      _hoisted_2249
    ];
    function _sfc_render249(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1249, _hoisted_3248);
    }
    var success_filled_default = /* @__PURE__ */ export_helper_default(success_filled_vue_vue_type_script_lang_default, [["render", _sfc_render249], ["__file", "success-filled.vue"]]);
    var view_vue_vue_type_script_lang_default = {
      name: "View"
    };
    var _hoisted_1283 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_2283 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_3282 = [
      _hoisted_2283
    ];
    function _sfc_render283(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1283, _hoisted_3282);
    }
    var view_default = /* @__PURE__ */ export_helper_default(view_vue_vue_type_script_lang_default, [["render", _sfc_render283], ["__file", "view.vue"]]);
    var warning_filled_vue_vue_type_script_lang_default = {
      name: "WarningFilled"
    };
    var _hoisted_1287 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_2287 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_3286 = [
      _hoisted_2287
    ];
    function _sfc_render287(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1287, _hoisted_3286);
    }
    var warning_filled_default = /* @__PURE__ */ export_helper_default(warning_filled_vue_vue_type_script_lang_default, [["render", _sfc_render287], ["__file", "warning-filled.vue"]]);
    var zoom_in_vue_vue_type_script_lang_default = {
      name: "ZoomIn"
    };
    var _hoisted_1292 = {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, _hoisted_2292 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
      },
      null,
      -1
      /* HOISTED */
    ), _hoisted_3291 = [
      _hoisted_2292
    ];
    function _sfc_render292(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1292, _hoisted_3291);
    }
    var zoom_in_default = /* @__PURE__ */ export_helper_default(zoom_in_vue_vue_type_script_lang_default, [["render", _sfc_render292], ["__file", "zoom-in.vue"]]);
    const epPropKey = "__epPropKey";
    const definePropType = (val) => val;
    const isEpProp = (val) => isObject$2(val) && !!val[epPropKey];
    const buildProp = (prop, key) => {
      if (!isObject$2(prop) || isEpProp(prop))
        return prop;
      const { values, required, default: defaultValue, type, validator: validator2 } = prop;
      const _validator = values || validator2 ? (val) => {
        let valid = false;
        let allowedValues = [];
        if (values) {
          allowedValues = Array.from(values);
          if (hasOwn(prop, "default")) {
            allowedValues.push(defaultValue);
          }
          valid || (valid = allowedValues.includes(val));
        }
        if (validator2)
          valid || (valid = validator2(val));
        if (!valid && allowedValues.length > 0) {
          const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
          warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
        }
        return valid;
      } : void 0;
      const epProp = {
        type,
        required: !!required,
        validator: _validator,
        [epPropKey]: true
      };
      if (hasOwn(prop, "default"))
        epProp.default = defaultValue;
      return epProp;
    };
    const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
      key,
      buildProp(option, key)
    ]));
    const iconPropType = definePropType([
      String,
      Object,
      Function
    ]);
    const TypeComponents = {
      Close: close_default,
      SuccessFilled: success_filled_default,
      InfoFilled: info_filled_default,
      WarningFilled: warning_filled_default,
      CircleCloseFilled: circle_close_filled_default
    };
    const TypeComponentsMap = {
      success: success_filled_default,
      warning: warning_filled_default,
      error: circle_close_filled_default,
      info: info_filled_default
    };
    const ValidateComponentsMap = {
      validating: loading_default,
      success: circle_check_default,
      error: circle_close_default
    };
    const withInstall = (main, extra) => {
      main.install = (app) => {
        for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
          app.component(comp.name, comp);
        }
      };
      if (extra) {
        for (const [key, comp] of Object.entries(extra)) {
          main[key] = comp;
        }
      }
      return main;
    };
    const withInstallFunction = (fn2, name) => {
      fn2.install = (app) => {
        fn2._context = app._context;
        app.config.globalProperties[name] = fn2;
      };
      return fn2;
    };
    const withNoopInstall = (component) => {
      component.install = NOOP;
      return component;
    };
    const EVENT_CODE = {
      tab: "Tab",
      enter: "Enter",
      space: "Space",
      left: "ArrowLeft",
      up: "ArrowUp",
      right: "ArrowRight",
      down: "ArrowDown",
      esc: "Escape",
      delete: "Delete",
      backspace: "Backspace",
      numpadEnter: "NumpadEnter",
      pageUp: "PageUp",
      pageDown: "PageDown",
      home: "Home",
      end: "End"
    };
    const UPDATE_MODEL_EVENT = "update:modelValue";
    const CHANGE_EVENT = "change";
    const INPUT_EVENT = "input";
    const componentSizes = ["", "default", "small", "large"];
    const componentSizeMap = {
      large: 40,
      default: 32,
      small: 24
    };
    const getComponentSize = (size2) => {
      return componentSizeMap[size2 || "default"];
    };
    const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
    const getNormalizedProps = (node) => {
      if (!isVNode(node)) {
        return {};
      }
      const raw = node.props || {};
      const type = (isVNode(node.type) ? node.type.props : void 0) || {};
      const props = {};
      Object.keys(type).forEach((key) => {
        if (hasOwn(type[key], "default")) {
          props[key] = type[key].default;
        }
      });
      Object.keys(raw).forEach((key) => {
        props[camelize(key)] = raw[key];
      });
      return props;
    };
    const flattedChildren = (children2) => {
      const vNodes = isArray$3(children2) ? children2 : [children2];
      const result = [];
      vNodes.forEach((child) => {
        var _a2;
        if (isArray$3(child)) {
          result.push(...flattedChildren(child));
        } else if (isVNode(child) && isArray$3(child.children)) {
          result.push(...flattedChildren(child.children));
        } else {
          result.push(child);
          if (isVNode(child) && ((_a2 = child.component) == null ? void 0 : _a2.subTree)) {
            result.push(...flattedChildren(child.component.subTree));
          }
        }
      });
      return result;
    };
    const isKorean = (text) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(text);
    const generateId = () => Math.floor(Math.random() * 1e4);
    const mutable = (val) => val;
    const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
    const LISTENER_PREFIX = /^on[A-Z]/;
    const useAttrs = (params = {}) => {
      const { excludeListeners = false, excludeKeys } = params;
      const allExcludeKeys = computed(() => {
        return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
      });
      const instance = getCurrentInstance();
      if (!instance) {
        return computed(() => ({}));
      }
      return computed(() => {
        var _a2;
        return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
      });
    };
    const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
      watch(() => unref(condition), (val) => {
      }, {
        immediate: true
      });
    };
    var English = {
      name: "en",
      el: {
        colorpicker: {
          confirm: "OK",
          clear: "Clear",
          defaultLabel: "color picker",
          description: "current color is {color}. press enter to select a new color."
        },
        datepicker: {
          now: "Now",
          today: "Today",
          cancel: "Cancel",
          clear: "Clear",
          confirm: "OK",
          dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
          monthTablePrompt: "Use the arrow keys and enter to select the month",
          yearTablePrompt: "Use the arrow keys and enter to select the year",
          selectedDate: "Selected date",
          selectDate: "Select date",
          selectTime: "Select time",
          startDate: "Start Date",
          startTime: "Start Time",
          endDate: "End Date",
          endTime: "End Time",
          prevYear: "Previous Year",
          nextYear: "Next Year",
          prevMonth: "Previous Month",
          nextMonth: "Next Month",
          year: "",
          month1: "January",
          month2: "February",
          month3: "March",
          month4: "April",
          month5: "May",
          month6: "June",
          month7: "July",
          month8: "August",
          month9: "September",
          month10: "October",
          month11: "November",
          month12: "December",
          week: "week",
          weeks: {
            sun: "Sun",
            mon: "Mon",
            tue: "Tue",
            wed: "Wed",
            thu: "Thu",
            fri: "Fri",
            sat: "Sat"
          },
          weeksFull: {
            sun: "Sunday",
            mon: "Monday",
            tue: "Tuesday",
            wed: "Wednesday",
            thu: "Thursday",
            fri: "Friday",
            sat: "Saturday"
          },
          months: {
            jan: "Jan",
            feb: "Feb",
            mar: "Mar",
            apr: "Apr",
            may: "May",
            jun: "Jun",
            jul: "Jul",
            aug: "Aug",
            sep: "Sep",
            oct: "Oct",
            nov: "Nov",
            dec: "Dec"
          }
        },
        inputNumber: {
          decrease: "decrease number",
          increase: "increase number"
        },
        select: {
          loading: "Loading",
          noMatch: "No matching data",
          noData: "No data",
          placeholder: "Select"
        },
        dropdown: {
          toggleDropdown: "Toggle Dropdown"
        },
        cascader: {
          noMatch: "No matching data",
          loading: "Loading",
          placeholder: "Select",
          noData: "No data"
        },
        pagination: {
          goto: "Go to",
          pagesize: "/page",
          total: "Total {total}",
          pageClassifier: "",
          page: "Page",
          prev: "Go to previous page",
          next: "Go to next page",
          currentPage: "page {pager}",
          prevPages: "Previous {pager} pages",
          nextPages: "Next {pager} pages",
          deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
        },
        dialog: {
          close: "Close this dialog"
        },
        drawer: {
          close: "Close this dialog"
        },
        messagebox: {
          title: "Message",
          confirm: "OK",
          cancel: "Cancel",
          error: "Illegal input",
          close: "Close this dialog"
        },
        upload: {
          deleteTip: "press delete to remove",
          delete: "Delete",
          preview: "Preview",
          continue: "Continue"
        },
        slider: {
          defaultLabel: "slider between {min} and {max}",
          defaultRangeStartLabel: "pick start value",
          defaultRangeEndLabel: "pick end value"
        },
        table: {
          emptyText: "No Data",
          confirmFilter: "Confirm",
          resetFilter: "Reset",
          clearFilter: "All",
          sumText: "Sum"
        },
        tree: {
          emptyText: "No Data"
        },
        transfer: {
          noMatch: "No matching data",
          noData: "No data",
          titles: ["List 1", "List 2"],
          filterPlaceholder: "Enter keyword",
          noCheckedFormat: "{total} items",
          hasCheckedFormat: "{checked}/{total} checked"
        },
        image: {
          error: "FAILED"
        },
        pageHeader: {
          title: "Back"
        },
        popconfirm: {
          confirmButtonText: "Yes",
          cancelButtonText: "No"
        }
      }
    };
    const buildTranslator = (locale2) => (path, option) => translate(path, option, unref(locale2));
    const translate = (path, option, locale2) => get$2(locale2, path, path).replace(/\{(\w+)\}/g, (_, key) => {
      var _a2;
      return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
    });
    const buildLocaleContext = (locale2) => {
      const lang = computed(() => unref(locale2).name);
      const localeRef = isRef(locale2) ? locale2 : ref(locale2);
      return {
        lang,
        locale: localeRef,
        t: buildTranslator(locale2)
      };
    };
    const localeContextKey = Symbol("localeContextKey");
    const useLocale = (localeOverrides) => {
      const locale2 = localeOverrides || inject(localeContextKey, ref());
      return buildLocaleContext(computed(() => locale2.value || English));
    };
    const defaultNamespace = "el";
    const statePrefix = "is-";
    const _bem = (namespace2, block, blockSuffix, element2, modifier) => {
      let cls = `${namespace2}-${block}`;
      if (blockSuffix) {
        cls += `-${blockSuffix}`;
      }
      if (element2) {
        cls += `__${element2}`;
      }
      if (modifier) {
        cls += `--${modifier}`;
      }
      return cls;
    };
    const namespaceContextKey = Symbol("namespaceContextKey");
    const useGetDerivedNamespace = (namespaceOverrides) => {
      const derivedNamespace = namespaceOverrides || (getCurrentInstance() ? inject(namespaceContextKey, ref(defaultNamespace)) : ref(defaultNamespace));
      const namespace2 = computed(() => {
        return unref(derivedNamespace) || defaultNamespace;
      });
      return namespace2;
    };
    const useNamespace = (block, namespaceOverrides) => {
      const namespace2 = useGetDerivedNamespace(namespaceOverrides);
      const b = (blockSuffix = "") => _bem(namespace2.value, block, blockSuffix, "", "");
      const e3 = (element2) => element2 ? _bem(namespace2.value, block, "", element2, "") : "";
      const m2 = (modifier) => modifier ? _bem(namespace2.value, block, "", "", modifier) : "";
      const be2 = (blockSuffix, element2) => blockSuffix && element2 ? _bem(namespace2.value, block, blockSuffix, element2, "") : "";
      const em = (element2, modifier) => element2 && modifier ? _bem(namespace2.value, block, "", element2, modifier) : "";
      const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace2.value, block, blockSuffix, "", modifier) : "";
      const bem = (blockSuffix, element2, modifier) => blockSuffix && element2 && modifier ? _bem(namespace2.value, block, blockSuffix, element2, modifier) : "";
      const is = (name, ...args) => {
        const state = args.length >= 1 ? args[0] : true;
        return name && state ? `${statePrefix}${name}` : "";
      };
      const cssVar = (object2) => {
        const styles = {};
        for (const key in object2) {
          if (object2[key]) {
            styles[`--${namespace2.value}-${key}`] = object2[key];
          }
        }
        return styles;
      };
      const cssVarBlock = (object2) => {
        const styles = {};
        for (const key in object2) {
          if (object2[key]) {
            styles[`--${namespace2.value}-${block}-${key}`] = object2[key];
          }
        }
        return styles;
      };
      const cssVarName = (name) => `--${namespace2.value}-${name}`;
      const cssVarBlockName = (name) => `--${namespace2.value}-${block}-${name}`;
      return {
        namespace: namespace2,
        b,
        e: e3,
        m: m2,
        be: be2,
        em,
        bm,
        bem,
        is,
        cssVar,
        cssVarName,
        cssVarBlock,
        cssVarBlockName
      };
    };
    const _prop = buildProp({
      type: definePropType(Boolean),
      default: null
    });
    const _event = buildProp({
      type: definePropType(Function)
    });
    const createModelToggleComposable = (name) => {
      const updateEventKey = `update:${name}`;
      const updateEventKeyRaw = `onUpdate:${name}`;
      const useModelToggleEmits2 = [updateEventKey];
      const useModelToggleProps2 = {
        [name]: _prop,
        [updateEventKeyRaw]: _event
      };
      const useModelToggle2 = ({
        indicator,
        toggleReason,
        shouldHideWhenRouteChanges,
        shouldProceed,
        onShow,
        onHide
      }) => {
        const instance = getCurrentInstance();
        const { emit: emit2 } = instance;
        const props = instance.props;
        const hasUpdateHandler = computed(() => isFunction$3(props[updateEventKeyRaw]));
        const isModelBindingAbsent = computed(() => props[name] === null);
        const doShow = (event) => {
          if (indicator.value === true) {
            return;
          }
          indicator.value = true;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$3(onShow)) {
            onShow(event);
          }
        };
        const doHide = (event) => {
          if (indicator.value === false) {
            return;
          }
          indicator.value = false;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (isFunction$3(onHide)) {
            onHide(event);
          }
        };
        const show = (event) => {
          if (props.disabled === true || isFunction$3(shouldProceed) && !shouldProceed())
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit2(updateEventKey, true);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doShow(event);
          }
        };
        const hide = (event) => {
          if (props.disabled === true || !isClient)
            return;
          const shouldEmit = hasUpdateHandler.value && isClient;
          if (shouldEmit) {
            emit2(updateEventKey, false);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doHide(event);
          }
        };
        const onChange = (val) => {
          if (!isBoolean$1(val))
            return;
          if (props.disabled && val) {
            if (hasUpdateHandler.value) {
              emit2(updateEventKey, false);
            }
          } else if (indicator.value !== val) {
            if (val) {
              doShow();
            } else {
              doHide();
            }
          }
        };
        const toggle = () => {
          if (indicator.value) {
            hide();
          } else {
            show();
          }
        };
        watch(() => props[name], onChange);
        if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
          watch(() => __spreadValues({}, instance.proxy.$route), () => {
            if (shouldHideWhenRouteChanges.value && indicator.value) {
              hide();
            }
          });
        }
        onMounted(() => {
          onChange(props[name]);
        });
        return {
          hide,
          show,
          toggle,
          hasUpdateHandler
        };
      };
      return {
        useModelToggle: useModelToggle2,
        useModelToggleProps: useModelToggleProps2,
        useModelToggleEmits: useModelToggleEmits2
      };
    };
    createModelToggleComposable("modelValue");
    const useProp = (name) => {
      const vm = getCurrentInstance();
      return computed(() => {
        var _a2, _b;
        return (_b = (_a2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _a2.$props) == null ? void 0 : _b[name];
      });
    };
    var E$2 = "top", R = "bottom", W = "right", P = "left", me = "auto", G = [E$2, R, W, P], U$1 = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e3) {
      return t.concat([e3 + "-" + U$1, e3 + "-" + J]);
    }, []), Ee = [].concat(G, [me]).reduce(function(t, e3) {
      return t.concat([e3, e3 + "-" + U$1, e3 + "-" + J]);
    }, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
    function C$1(t) {
      return t ? (t.nodeName || "").toLowerCase() : null;
    }
    function H(t) {
      if (t == null)
        return window;
      if (t.toString() !== "[object Window]") {
        var e3 = t.ownerDocument;
        return e3 && e3.defaultView || window;
      }
      return t;
    }
    function Q(t) {
      var e3 = H(t).Element;
      return t instanceof e3 || t instanceof Element;
    }
    function B$1(t) {
      var e3 = H(t).HTMLElement;
      return t instanceof e3 || t instanceof HTMLElement;
    }
    function Pe(t) {
      if (typeof ShadowRoot == "undefined")
        return false;
      var e3 = H(t).ShadowRoot;
      return t instanceof e3 || t instanceof ShadowRoot;
    }
    function Mt(t) {
      var e3 = t.state;
      Object.keys(e3.elements).forEach(function(n) {
        var r = e3.styles[n] || {}, o = e3.attributes[n] || {}, i2 = e3.elements[n];
        !B$1(i2) || !C$1(i2) || (Object.assign(i2.style, r), Object.keys(o).forEach(function(a2) {
          var s = o[a2];
          s === false ? i2.removeAttribute(a2) : i2.setAttribute(a2, s === true ? "" : s);
        }));
      });
    }
    function Rt(t) {
      var e3 = t.state, n = { popper: { position: e3.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
      return Object.assign(e3.elements.popper.style, n.popper), e3.styles = n, e3.elements.arrow && Object.assign(e3.elements.arrow.style, n.arrow), function() {
        Object.keys(e3.elements).forEach(function(r) {
          var o = e3.elements[r], i2 = e3.attributes[r] || {}, a2 = Object.keys(e3.styles.hasOwnProperty(r) ? e3.styles[r] : n[r]), s = a2.reduce(function(f2, c2) {
            return f2[c2] = "", f2;
          }, {});
          !B$1(o) || !C$1(o) || (Object.assign(o.style, s), Object.keys(i2).forEach(function(f2) {
            o.removeAttribute(f2);
          }));
        });
      };
    }
    var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
    function q(t) {
      return t.split("-")[0];
    }
    var X = Math.max, ve = Math.min, Z$1 = Math.round;
    function ee(t, e3) {
      e3 === void 0 && (e3 = false);
      var n = t.getBoundingClientRect(), r = 1, o = 1;
      if (B$1(t) && e3) {
        var i2 = t.offsetHeight, a2 = t.offsetWidth;
        a2 > 0 && (r = Z$1(n.width) / a2 || 1), i2 > 0 && (o = Z$1(n.height) / i2 || 1);
      }
      return { width: n.width / r, height: n.height / o, top: n.top / o, right: n.right / r, bottom: n.bottom / o, left: n.left / r, x: n.left / r, y: n.top / o };
    }
    function ke(t) {
      var e3 = ee(t), n = t.offsetWidth, r = t.offsetHeight;
      return Math.abs(e3.width - n) <= 1 && (n = e3.width), Math.abs(e3.height - r) <= 1 && (r = e3.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
    }
    function it(t, e3) {
      var n = e3.getRootNode && e3.getRootNode();
      if (t.contains(e3))
        return true;
      if (n && Pe(n)) {
        var r = e3;
        do {
          if (r && t.isSameNode(r))
            return true;
          r = r.parentNode || r.host;
        } while (r);
      }
      return false;
    }
    function N(t) {
      return H(t).getComputedStyle(t);
    }
    function Wt(t) {
      return ["table", "td", "th"].indexOf(C$1(t)) >= 0;
    }
    function I(t) {
      return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
    }
    function ge(t) {
      return C$1(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I(t);
    }
    function at(t) {
      return !B$1(t) || N(t).position === "fixed" ? null : t.offsetParent;
    }
    function Bt(t) {
      var e3 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
      if (n && B$1(t)) {
        var r = N(t);
        if (r.position === "fixed")
          return null;
      }
      var o = ge(t);
      for (Pe(o) && (o = o.host); B$1(o) && ["html", "body"].indexOf(C$1(o)) < 0; ) {
        var i2 = N(o);
        if (i2.transform !== "none" || i2.perspective !== "none" || i2.contain === "paint" || ["transform", "perspective"].indexOf(i2.willChange) !== -1 || e3 && i2.willChange === "filter" || e3 && i2.filter && i2.filter !== "none")
          return o;
        o = o.parentNode;
      }
      return null;
    }
    function se(t) {
      for (var e3 = H(t), n = at(t); n && Wt(n) && N(n).position === "static"; )
        n = at(n);
      return n && (C$1(n) === "html" || C$1(n) === "body" && N(n).position === "static") ? e3 : n || Bt(t) || e3;
    }
    function Le(t) {
      return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
    }
    function fe(t, e3, n) {
      return X(t, ve(e3, n));
    }
    function St(t, e3, n) {
      var r = fe(t, e3, n);
      return r > n ? n : r;
    }
    function st() {
      return { top: 0, right: 0, bottom: 0, left: 0 };
    }
    function ft(t) {
      return Object.assign({}, st(), t);
    }
    function ct(t, e3) {
      return e3.reduce(function(n, r) {
        return n[r] = t, n;
      }, {});
    }
    var Tt = function(t, e3) {
      return t = typeof t == "function" ? t(Object.assign({}, e3.rects, { placement: e3.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
    };
    function Ht(t) {
      var e3, n = t.state, r = t.name, o = t.options, i2 = n.elements.arrow, a2 = n.modifiersData.popperOffsets, s = q(n.placement), f2 = Le(s), c2 = [P, W].indexOf(s) >= 0, u2 = c2 ? "height" : "width";
      if (!(!i2 || !a2)) {
        var m2 = Tt(o.padding, n), v = ke(i2), l = f2 === "y" ? E$2 : P, h2 = f2 === "y" ? R : W, p2 = n.rects.reference[u2] + n.rects.reference[f2] - a2[f2] - n.rects.popper[u2], g = a2[f2] - n.rects.reference[f2], x2 = se(i2), y2 = x2 ? f2 === "y" ? x2.clientHeight || 0 : x2.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d = m2[l], b = y2 - v[u2] - m2[h2], w = y2 / 2 - v[u2] / 2 + $, O = fe(d, w, b), j = f2;
        n.modifiersData[r] = (e3 = {}, e3[j] = O, e3.centerOffset = O - w, e3);
      }
    }
    function Ct(t) {
      var e3 = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
      o != null && (typeof o == "string" && (o = e3.elements.popper.querySelector(o), !o) || !it(e3.elements.popper, o) || (e3.elements.arrow = o));
    }
    var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
    function te(t) {
      return t.split("-")[1];
    }
    var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
    function Vt(t) {
      var e3 = t.x, n = t.y, r = window, o = r.devicePixelRatio || 1;
      return { x: Z$1(e3 * o) / o || 0, y: Z$1(n * o) / o || 0 };
    }
    function ut(t) {
      var e3, n = t.popper, r = t.popperRect, o = t.placement, i2 = t.variation, a2 = t.offsets, s = t.position, f2 = t.gpuAcceleration, c2 = t.adaptive, u2 = t.roundOffsets, m2 = t.isFixed, v = a2.x, l = v === void 0 ? 0 : v, h2 = a2.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u2 == "function" ? u2({ x: l, y: p2 }) : { x: l, y: p2 };
      l = g.x, p2 = g.y;
      var x2 = a2.hasOwnProperty("x"), y2 = a2.hasOwnProperty("y"), $ = P, d = E$2, b = window;
      if (c2) {
        var w = se(n), O = "clientHeight", j = "clientWidth";
        if (w === H(n) && (w = I(n), N(w).position !== "static" && s === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o === E$2 || (o === P || o === W) && i2 === J) {
          d = R;
          var A2 = m2 && w === b && b.visualViewport ? b.visualViewport.height : w[O];
          p2 -= A2 - r.height, p2 *= f2 ? 1 : -1;
        }
        if (o === P || (o === E$2 || o === R) && i2 === J) {
          $ = W;
          var k = m2 && w === b && b.visualViewport ? b.visualViewport.width : w[j];
          l -= k - r.width, l *= f2 ? 1 : -1;
        }
      }
      var D2 = Object.assign({ position: s }, c2 && qt), S = u2 === true ? Vt({ x: l, y: p2 }) : { x: l, y: p2 };
      if (l = S.x, p2 = S.y, f2) {
        var L2;
        return Object.assign({}, D2, (L2 = {}, L2[d] = y2 ? "0" : "", L2[$] = x2 ? "0" : "", L2.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p2 + "px)" : "translate3d(" + l + "px, " + p2 + "px, 0)", L2));
      }
      return Object.assign({}, D2, (e3 = {}, e3[d] = y2 ? p2 + "px" : "", e3[$] = x2 ? l + "px" : "", e3.transform = "", e3));
    }
    function Nt(t) {
      var e3 = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i2 = n.adaptive, a2 = i2 === void 0 ? true : i2, s = n.roundOffsets, f2 = s === void 0 ? true : s, c2 = { placement: q(e3.placement), variation: te(e3.placement), popper: e3.elements.popper, popperRect: e3.rects.popper, gpuAcceleration: o, isFixed: e3.options.strategy === "fixed" };
      e3.modifiersData.popperOffsets != null && (e3.styles.popper = Object.assign({}, e3.styles.popper, ut(Object.assign({}, c2, { offsets: e3.modifiersData.popperOffsets, position: e3.options.strategy, adaptive: a2, roundOffsets: f2 })))), e3.modifiersData.arrow != null && (e3.styles.arrow = Object.assign({}, e3.styles.arrow, ut(Object.assign({}, c2, { offsets: e3.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f2 })))), e3.attributes.popper = Object.assign({}, e3.attributes.popper, { "data-popper-placement": e3.placement });
    }
    var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
    function It(t) {
      var e3 = t.state, n = t.instance, r = t.options, o = r.scroll, i2 = o === void 0 ? true : o, a2 = r.resize, s = a2 === void 0 ? true : a2, f2 = H(e3.elements.popper), c2 = [].concat(e3.scrollParents.reference, e3.scrollParents.popper);
      return i2 && c2.forEach(function(u2) {
        u2.addEventListener("scroll", n.update, ye);
      }), s && f2.addEventListener("resize", n.update, ye), function() {
        i2 && c2.forEach(function(u2) {
          u2.removeEventListener("scroll", n.update, ye);
        }), s && f2.removeEventListener("resize", n.update, ye);
      };
    }
    var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
    }, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
    function be(t) {
      return t.replace(/left|right|bottom|top/g, function(e3) {
        return _t[e3];
      });
    }
    var zt = { start: "end", end: "start" };
    function lt(t) {
      return t.replace(/start|end/g, function(e3) {
        return zt[e3];
      });
    }
    function We(t) {
      var e3 = H(t), n = e3.pageXOffset, r = e3.pageYOffset;
      return { scrollLeft: n, scrollTop: r };
    }
    function Be(t) {
      return ee(I(t)).left + We(t).scrollLeft;
    }
    function Ft(t) {
      var e3 = H(t), n = I(t), r = e3.visualViewport, o = n.clientWidth, i2 = n.clientHeight, a2 = 0, s = 0;
      return r && (o = r.width, i2 = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a2 = r.offsetLeft, s = r.offsetTop)), { width: o, height: i2, x: a2 + Be(t), y: s };
    }
    function Ut(t) {
      var e3, n = I(t), r = We(t), o = (e3 = t.ownerDocument) == null ? void 0 : e3.body, i2 = X(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a2 = X(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), s = -r.scrollLeft + Be(t), f2 = -r.scrollTop;
      return N(o || n).direction === "rtl" && (s += X(n.clientWidth, o ? o.clientWidth : 0) - i2), { width: i2, height: a2, x: s, y: f2 };
    }
    function Se(t) {
      var e3 = N(t), n = e3.overflow, r = e3.overflowX, o = e3.overflowY;
      return /auto|scroll|overlay|hidden/.test(n + o + r);
    }
    function dt(t) {
      return ["html", "body", "#document"].indexOf(C$1(t)) >= 0 ? t.ownerDocument.body : B$1(t) && Se(t) ? t : dt(ge(t));
    }
    function ce(t, e3) {
      var n;
      e3 === void 0 && (e3 = []);
      var r = dt(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i2 = H(r), a2 = o ? [i2].concat(i2.visualViewport || [], Se(r) ? r : []) : r, s = e3.concat(a2);
      return o ? s : s.concat(ce(ge(a2)));
    }
    function Te(t) {
      return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
    }
    function Xt(t) {
      var e3 = ee(t);
      return e3.top = e3.top + t.clientTop, e3.left = e3.left + t.clientLeft, e3.bottom = e3.top + t.clientHeight, e3.right = e3.left + t.clientWidth, e3.width = t.clientWidth, e3.height = t.clientHeight, e3.x = e3.left, e3.y = e3.top, e3;
    }
    function ht(t, e3) {
      return e3 === je ? Te(Ft(t)) : Q(e3) ? Xt(e3) : Te(Ut(I(t)));
    }
    function Yt(t) {
      var e3 = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N(t).position) >= 0, r = n && B$1(t) ? se(t) : t;
      return Q(r) ? e3.filter(function(o) {
        return Q(o) && it(o, r) && C$1(o) !== "body";
      }) : [];
    }
    function Gt(t, e3, n) {
      var r = e3 === "clippingParents" ? Yt(t) : [].concat(e3), o = [].concat(r, [n]), i2 = o[0], a2 = o.reduce(function(s, f2) {
        var c2 = ht(t, f2);
        return s.top = X(c2.top, s.top), s.right = ve(c2.right, s.right), s.bottom = ve(c2.bottom, s.bottom), s.left = X(c2.left, s.left), s;
      }, ht(t, i2));
      return a2.width = a2.right - a2.left, a2.height = a2.bottom - a2.top, a2.x = a2.left, a2.y = a2.top, a2;
    }
    function mt(t) {
      var e3 = t.reference, n = t.element, r = t.placement, o = r ? q(r) : null, i2 = r ? te(r) : null, a2 = e3.x + e3.width / 2 - n.width / 2, s = e3.y + e3.height / 2 - n.height / 2, f2;
      switch (o) {
        case E$2:
          f2 = { x: a2, y: e3.y - n.height };
          break;
        case R:
          f2 = { x: a2, y: e3.y + e3.height };
          break;
        case W:
          f2 = { x: e3.x + e3.width, y: s };
          break;
        case P:
          f2 = { x: e3.x - n.width, y: s };
          break;
        default:
          f2 = { x: e3.x, y: e3.y };
      }
      var c2 = o ? Le(o) : null;
      if (c2 != null) {
        var u2 = c2 === "y" ? "height" : "width";
        switch (i2) {
          case U$1:
            f2[c2] = f2[c2] - (e3[u2] / 2 - n[u2] / 2);
            break;
          case J:
            f2[c2] = f2[c2] + (e3[u2] / 2 - n[u2] / 2);
            break;
        }
      }
      return f2;
    }
    function ne(t, e3) {
      e3 === void 0 && (e3 = {});
      var n = e3, r = n.placement, o = r === void 0 ? t.placement : r, i2 = n.boundary, a2 = i2 === void 0 ? Xe : i2, s = n.rootBoundary, f2 = s === void 0 ? je : s, c2 = n.elementContext, u2 = c2 === void 0 ? K : c2, m2 = n.altBoundary, v = m2 === void 0 ? false : m2, l = n.padding, h2 = l === void 0 ? 0 : l, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u2 === K ? Ye : K, x2 = t.rects.popper, y2 = t.elements[v ? g : u2], $ = Gt(Q(y2) ? y2 : y2.contextElement || I(t.elements.popper), a2, f2), d = ee(t.elements.reference), b = mt({ reference: d, element: x2, strategy: "absolute", placement: o }), w = Te(Object.assign({}, x2, b)), O = u2 === K ? w : d, j = { top: $.top - O.top + p2.top, bottom: O.bottom - $.bottom + p2.bottom, left: $.left - O.left + p2.left, right: O.right - $.right + p2.right }, A2 = t.modifiersData.offset;
      if (u2 === K && A2) {
        var k = A2[o];
        Object.keys(j).forEach(function(D2) {
          var S = [W, R].indexOf(D2) >= 0 ? 1 : -1, L2 = [E$2, R].indexOf(D2) >= 0 ? "y" : "x";
          j[D2] += k[L2] * S;
        });
      }
      return j;
    }
    function Jt(t, e3) {
      e3 === void 0 && (e3 = {});
      var n = e3, r = n.placement, o = n.boundary, i2 = n.rootBoundary, a2 = n.padding, s = n.flipVariations, f2 = n.allowedAutoPlacements, c2 = f2 === void 0 ? Ee : f2, u2 = te(r), m2 = u2 ? s ? De : De.filter(function(h2) {
        return te(h2) === u2;
      }) : G, v = m2.filter(function(h2) {
        return c2.indexOf(h2) >= 0;
      });
      v.length === 0 && (v = m2);
      var l = v.reduce(function(h2, p2) {
        return h2[p2] = ne(t, { placement: p2, boundary: o, rootBoundary: i2, padding: a2 })[q(p2)], h2;
      }, {});
      return Object.keys(l).sort(function(h2, p2) {
        return l[h2] - l[p2];
      });
    }
    function Kt(t) {
      if (q(t) === me)
        return [];
      var e3 = be(t);
      return [lt(t), e3, lt(e3)];
    }
    function Qt(t) {
      var e3 = t.state, n = t.options, r = t.name;
      if (!e3.modifiersData[r]._skip) {
        for (var o = n.mainAxis, i2 = o === void 0 ? true : o, a2 = n.altAxis, s = a2 === void 0 ? true : a2, f2 = n.fallbackPlacements, c2 = n.padding, u2 = n.boundary, m2 = n.rootBoundary, v = n.altBoundary, l = n.flipVariations, h2 = l === void 0 ? true : l, p2 = n.allowedAutoPlacements, g = e3.options.placement, x2 = q(g), y2 = x2 === g, $ = f2 || (y2 || !h2 ? [be(g)] : Kt(g)), d = [g].concat($).reduce(function(z2, V2) {
          return z2.concat(q(V2) === me ? Jt(e3, { placement: V2, boundary: u2, rootBoundary: m2, padding: c2, flipVariations: h2, allowedAutoPlacements: p2 }) : V2);
        }, []), b = e3.rects.reference, w = e3.rects.popper, O = /* @__PURE__ */ new Map(), j = true, A2 = d[0], k = 0; k < d.length; k++) {
          var D2 = d[k], S = q(D2), L2 = te(D2) === U$1, re2 = [E$2, R].indexOf(S) >= 0, oe = re2 ? "width" : "height", M = ne(e3, { placement: D2, boundary: u2, rootBoundary: m2, altBoundary: v, padding: c2 }), T2 = re2 ? L2 ? W : P : L2 ? R : E$2;
          b[oe] > w[oe] && (T2 = be(T2));
          var pe = be(T2), _ = [];
          if (i2 && _.push(M[S] <= 0), s && _.push(M[T2] <= 0, M[pe] <= 0), _.every(function(z2) {
            return z2;
          })) {
            A2 = D2, j = false;
            break;
          }
          O.set(D2, _);
        }
        if (j)
          for (var ue = h2 ? 3 : 1, xe = function(z2) {
            var V2 = d.find(function(de) {
              var ae = O.get(de);
              if (ae)
                return ae.slice(0, z2).every(function(Y) {
                  return Y;
                });
            });
            if (V2)
              return A2 = V2, "break";
          }, ie = ue; ie > 0; ie--) {
            var le = xe(ie);
            if (le === "break")
              break;
          }
        e3.placement !== A2 && (e3.modifiersData[r]._skip = true, e3.placement = A2, e3.reset = true);
      }
    }
    var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
    function gt(t, e3, n) {
      return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e3.height - n.y, right: t.right - e3.width + n.x, bottom: t.bottom - e3.height + n.y, left: t.left - e3.width - n.x };
    }
    function yt(t) {
      return [E$2, W, R, P].some(function(e3) {
        return t[e3] >= 0;
      });
    }
    function Zt(t) {
      var e3 = t.state, n = t.name, r = e3.rects.reference, o = e3.rects.popper, i2 = e3.modifiersData.preventOverflow, a2 = ne(e3, { elementContext: "reference" }), s = ne(e3, { altBoundary: true }), f2 = gt(a2, r), c2 = gt(s, o, i2), u2 = yt(f2), m2 = yt(c2);
      e3.modifiersData[n] = { referenceClippingOffsets: f2, popperEscapeOffsets: c2, isReferenceHidden: u2, hasPopperEscaped: m2 }, e3.attributes.popper = Object.assign({}, e3.attributes.popper, { "data-popper-reference-hidden": u2, "data-popper-escaped": m2 });
    }
    var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
    function en(t, e3, n) {
      var r = q(t), o = [P, E$2].indexOf(r) >= 0 ? -1 : 1, i2 = typeof n == "function" ? n(Object.assign({}, e3, { placement: t })) : n, a2 = i2[0], s = i2[1];
      return a2 = a2 || 0, s = (s || 0) * o, [P, W].indexOf(r) >= 0 ? { x: s, y: a2 } : { x: a2, y: s };
    }
    function tn(t) {
      var e3 = t.state, n = t.options, r = t.name, o = n.offset, i2 = o === void 0 ? [0, 0] : o, a2 = Ee.reduce(function(u2, m2) {
        return u2[m2] = en(m2, e3.rects, i2), u2;
      }, {}), s = a2[e3.placement], f2 = s.x, c2 = s.y;
      e3.modifiersData.popperOffsets != null && (e3.modifiersData.popperOffsets.x += f2, e3.modifiersData.popperOffsets.y += c2), e3.modifiersData[r] = a2;
    }
    var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
    function nn(t) {
      var e3 = t.state, n = t.name;
      e3.modifiersData[n] = mt({ reference: e3.rects.reference, element: e3.rects.popper, strategy: "absolute", placement: e3.placement });
    }
    var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
    function rn(t) {
      return t === "x" ? "y" : "x";
    }
    function on(t) {
      var e3 = t.state, n = t.options, r = t.name, o = n.mainAxis, i2 = o === void 0 ? true : o, a2 = n.altAxis, s = a2 === void 0 ? false : a2, f2 = n.boundary, c2 = n.rootBoundary, u2 = n.altBoundary, m2 = n.padding, v = n.tether, l = v === void 0 ? true : v, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e3, { boundary: f2, rootBoundary: c2, padding: m2, altBoundary: u2 }), x2 = q(e3.placement), y2 = te(e3.placement), $ = !y2, d = Le(x2), b = rn(d), w = e3.modifiersData.popperOffsets, O = e3.rects.reference, j = e3.rects.popper, A2 = typeof p2 == "function" ? p2(Object.assign({}, e3.rects, { placement: e3.placement })) : p2, k = typeof A2 == "number" ? { mainAxis: A2, altAxis: A2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, A2), D2 = e3.modifiersData.offset ? e3.modifiersData.offset[e3.placement] : null, S = { x: 0, y: 0 };
      if (w) {
        if (i2) {
          var L2, re2 = d === "y" ? E$2 : P, oe = d === "y" ? R : W, M = d === "y" ? "height" : "width", T2 = w[d], pe = T2 + g[re2], _ = T2 - g[oe], ue = l ? -j[M] / 2 : 0, xe = y2 === U$1 ? O[M] : j[M], ie = y2 === U$1 ? -j[M] : -O[M], le = e3.elements.arrow, z2 = l && le ? ke(le) : { width: 0, height: 0 }, V2 = e3.modifiersData["arrow#persistent"] ? e3.modifiersData["arrow#persistent"].padding : st(), de = V2[re2], ae = V2[oe], Y = fe(0, O[M], z2[M]), jt = $ ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis, Dt = $ ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie + Y + ae + k.mainAxis, Oe = e3.elements.arrow && se(e3.elements.arrow), Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L2 = D2 == null ? void 0 : D2[d]) != null ? L2 : 0, Pt = T2 + jt - Ce - Et, At = T2 + Dt - Ce, qe = fe(l ? ve(pe, Pt) : pe, T2, l ? X(_, At) : _);
          w[d] = qe, S[d] = qe - T2;
        }
        if (s) {
          var Ve, kt = d === "x" ? E$2 : P, Lt = d === "x" ? R : W, F2 = w[b], he = b === "y" ? "height" : "width", Ne = F2 + g[kt], Ie = F2 - g[Lt], $e = [E$2, P].indexOf(x2) !== -1, _e = (Ve = D2 == null ? void 0 : D2[b]) != null ? Ve : 0, ze = $e ? Ne : F2 - O[he] - j[he] - _e + k.altAxis, Fe = $e ? F2 + O[he] + j[he] - _e - k.altAxis : Ie, Ue = l && $e ? St(ze, F2, Fe) : fe(l ? ze : Ne, F2, l ? Fe : Ie);
          w[b] = Ue, S[b] = Ue - F2;
        }
        e3.modifiersData[r] = S;
      }
    }
    var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
    function an(t) {
      return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
    }
    function sn(t) {
      return t === H(t) || !B$1(t) ? We(t) : an(t);
    }
    function fn(t) {
      var e3 = t.getBoundingClientRect(), n = Z$1(e3.width) / t.offsetWidth || 1, r = Z$1(e3.height) / t.offsetHeight || 1;
      return n !== 1 || r !== 1;
    }
    function cn(t, e3, n) {
      n === void 0 && (n = false);
      var r = B$1(e3), o = B$1(e3) && fn(e3), i2 = I(e3), a2 = ee(t, o), s = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 0, y: 0 };
      return (r || !r && !n) && ((C$1(e3) !== "body" || Se(i2)) && (s = sn(e3)), B$1(e3) ? (f2 = ee(e3, true), f2.x += e3.clientLeft, f2.y += e3.clientTop) : i2 && (f2.x = Be(i2))), { x: a2.left + s.scrollLeft - f2.x, y: a2.top + s.scrollTop - f2.y, width: a2.width, height: a2.height };
    }
    function pn(t) {
      var e3 = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
      t.forEach(function(i2) {
        e3.set(i2.name, i2);
      });
      function o(i2) {
        n.add(i2.name);
        var a2 = [].concat(i2.requires || [], i2.requiresIfExists || []);
        a2.forEach(function(s) {
          if (!n.has(s)) {
            var f2 = e3.get(s);
            f2 && o(f2);
          }
        }), r.push(i2);
      }
      return t.forEach(function(i2) {
        n.has(i2.name) || o(i2);
      }), r;
    }
    function un(t) {
      var e3 = pn(t);
      return ot.reduce(function(n, r) {
        return n.concat(e3.filter(function(o) {
          return o.phase === r;
        }));
      }, []);
    }
    function ln(t) {
      var e3;
      return function() {
        return e3 || (e3 = new Promise(function(n) {
          Promise.resolve().then(function() {
            e3 = void 0, n(t());
          });
        })), e3;
      };
    }
    function dn(t) {
      var e3 = t.reduce(function(n, r) {
        var o = n[r.name];
        return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n;
      }, {});
      return Object.keys(e3).map(function(n) {
        return e3[n];
      });
    }
    var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
    function $t() {
      for (var t = arguments.length, e3 = new Array(t), n = 0; n < t; n++)
        e3[n] = arguments[n];
      return !e3.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function");
      });
    }
    function we(t) {
      t === void 0 && (t = {});
      var e3 = t, n = e3.defaultModifiers, r = n === void 0 ? [] : n, o = e3.defaultOptions, i2 = o === void 0 ? Ot : o;
      return function(a2, s, f2) {
        f2 === void 0 && (f2 = i2);
        var c2 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i2), modifiersData: {}, elements: { reference: a2, popper: s }, attributes: {}, styles: {} }, u2 = [], m2 = false, v = { state: c2, setOptions: function(p2) {
          var g = typeof p2 == "function" ? p2(c2.options) : p2;
          h2(), c2.options = Object.assign({}, i2, c2.options, g), c2.scrollParents = { reference: Q(a2) ? ce(a2) : a2.contextElement ? ce(a2.contextElement) : [], popper: ce(s) };
          var x2 = un(dn([].concat(r, c2.options.modifiers)));
          return c2.orderedModifiers = x2.filter(function(y2) {
            return y2.enabled;
          }), l(), v.update();
        }, forceUpdate: function() {
          if (!m2) {
            var p2 = c2.elements, g = p2.reference, x2 = p2.popper;
            if ($t(g, x2)) {
              c2.rects = { reference: cn(g, se(x2), c2.options.strategy === "fixed"), popper: ke(x2) }, c2.reset = false, c2.placement = c2.options.placement, c2.orderedModifiers.forEach(function(j) {
                return c2.modifiersData[j.name] = Object.assign({}, j.data);
              });
              for (var y2 = 0; y2 < c2.orderedModifiers.length; y2++) {
                if (c2.reset === true) {
                  c2.reset = false, y2 = -1;
                  continue;
                }
                var $ = c2.orderedModifiers[y2], d = $.fn, b = $.options, w = b === void 0 ? {} : b, O = $.name;
                typeof d == "function" && (c2 = d({ state: c2, options: w, name: O, instance: v }) || c2);
              }
            }
          }
        }, update: ln(function() {
          return new Promise(function(p2) {
            v.forceUpdate(), p2(c2);
          });
        }), destroy: function() {
          h2(), m2 = true;
        } };
        if (!$t(a2, s))
          return v;
        v.setOptions(f2).then(function(p2) {
          !m2 && f2.onFirstUpdate && f2.onFirstUpdate(p2);
        });
        function l() {
          c2.orderedModifiers.forEach(function(p2) {
            var g = p2.name, x2 = p2.options, y2 = x2 === void 0 ? {} : x2, $ = p2.effect;
            if (typeof $ == "function") {
              var d = $({ state: c2, name: g, instance: v, options: y2 }), b = function() {
              };
              u2.push(d || b);
            }
          });
        }
        function h2() {
          u2.forEach(function(p2) {
            return p2();
          }), u2 = [];
        }
        return v;
      };
    }
    we();
    var mn = [Re, He, Me, Ae];
    we({ defaultModifiers: mn });
    var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
    const usePopper = (referenceElementRef, popperElementRef, opts = {}) => {
      const stateUpdater = {
        name: "updateState",
        enabled: true,
        phase: "write",
        fn: ({ state }) => {
          const derivedState = deriveState(state);
          Object.assign(states.value, derivedState);
        },
        requires: ["computeStyles"]
      };
      const options = computed(() => {
        const { onFirstUpdate, placement, strategy, modifiers } = unref(opts);
        return {
          onFirstUpdate,
          placement: placement || "bottom",
          strategy: strategy || "absolute",
          modifiers: [
            ...modifiers || [],
            stateUpdater,
            { name: "applyStyles", enabled: false }
          ]
        };
      });
      const instanceRef = shallowRef();
      const states = ref({
        styles: {
          popper: {
            position: unref(options).strategy,
            left: "0",
            top: "0"
          },
          arrow: {
            position: "absolute"
          }
        },
        attributes: {}
      });
      const destroy = () => {
        if (!instanceRef.value)
          return;
        instanceRef.value.destroy();
        instanceRef.value = void 0;
      };
      watch(options, (newOptions) => {
        const instance = unref(instanceRef);
        if (instance) {
          instance.setOptions(newOptions);
        }
      }, {
        deep: true
      });
      watch([referenceElementRef, popperElementRef], ([referenceElement, popperElement]) => {
        destroy();
        if (!referenceElement || !popperElement)
          return;
        instanceRef.value = yn(referenceElement, popperElement, unref(options));
      });
      onBeforeUnmount(() => {
        destroy();
      });
      return {
        state: computed(() => {
          var _a2;
          return __spreadValues({}, ((_a2 = unref(instanceRef)) == null ? void 0 : _a2.state) || {});
        }),
        styles: computed(() => unref(states).styles),
        attributes: computed(() => unref(states).attributes),
        update: () => {
          var _a2;
          return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.update();
        },
        forceUpdate: () => {
          var _a2;
          return (_a2 = unref(instanceRef)) == null ? void 0 : _a2.forceUpdate();
        },
        instanceRef: computed(() => unref(instanceRef))
      };
    };
    function deriveState(state) {
      const elements = Object.keys(state.elements);
      const styles = fromPairs(elements.map((element2) => [element2, state.styles[element2] || {}]));
      const attributes = fromPairs(elements.map((element2) => [element2, state.attributes[element2]]));
      return {
        styles,
        attributes
      };
    }
    function useTimeout() {
      let timeoutHandle;
      const registerTimeout = (fn2, delay) => {
        cancelTimeout();
        timeoutHandle = window.setTimeout(fn2, delay);
      };
      const cancelTimeout = () => window.clearTimeout(timeoutHandle);
      tryOnScopeDispose(() => cancelTimeout());
      return {
        registerTimeout,
        cancelTimeout
      };
    }
    const defaultIdInjection = {
      prefix: Math.floor(Math.random() * 1e4),
      current: 0
    };
    const ID_INJECTION_KEY = Symbol("elIdInjection");
    const useIdInjection = () => {
      return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;
    };
    const useId = (deterministicId) => {
      const idInjection = useIdInjection();
      const namespace2 = useGetDerivedNamespace();
      const idRef = computed(() => unref(deterministicId) || `${namespace2.value}-id-${idInjection.prefix}-${idInjection.current++}`);
      return idRef;
    };
    let registeredEscapeHandlers = [];
    const cachedHandler = (e3) => {
      const event = e3;
      if (event.key === EVENT_CODE.esc) {
        registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
      }
    };
    const useEscapeKeydown = (handler) => {
      onMounted(() => {
        if (registeredEscapeHandlers.length === 0) {
          document.addEventListener("keydown", cachedHandler);
        }
        if (isClient)
          registeredEscapeHandlers.push(handler);
      });
      onBeforeUnmount(() => {
        registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
        if (registeredEscapeHandlers.length === 0) {
          if (isClient)
            document.removeEventListener("keydown", cachedHandler);
        }
      });
    };
    let cachedContainer;
    const usePopperContainerId = () => {
      const namespace2 = useGetDerivedNamespace();
      const idInjection = useIdInjection();
      const id2 = computed(() => {
        return `${namespace2.value}-popper-container-${idInjection.prefix}`;
      });
      const selector2 = computed(() => `#${id2.value}`);
      return {
        id: id2,
        selector: selector2
      };
    };
    const createContainer$1 = (id2) => {
      const container = document.createElement("div");
      container.id = id2;
      document.body.appendChild(container);
      return container;
    };
    const usePopperContainer = () => {
      const { id: id2, selector: selector2 } = usePopperContainerId();
      onBeforeMount(() => {
        if (!isClient)
          return;
        if (!cachedContainer && !document.body.querySelector(selector2.value)) {
          cachedContainer = createContainer$1(id2.value);
        }
      });
      return {
        id: id2,
        selector: selector2
      };
    };
    const useDelayedToggleProps = buildProps({
      showAfter: {
        type: Number,
        default: 0
      },
      hideAfter: {
        type: Number,
        default: 200
      },
      autoClose: {
        type: Number,
        default: 0
      }
    });
    const useDelayedToggle = ({
      showAfter,
      hideAfter,
      autoClose,
      open,
      close
    }) => {
      const { registerTimeout } = useTimeout();
      const {
        registerTimeout: registerTimeoutForAutoClose,
        cancelTimeout: cancelTimeoutForAutoClose
      } = useTimeout();
      const onOpen = (event) => {
        registerTimeout(() => {
          open(event);
          const _autoClose = unref(autoClose);
          if (isNumber$1(_autoClose) && _autoClose > 0) {
            registerTimeoutForAutoClose(() => {
              close(event);
            }, _autoClose);
          }
        }, unref(showAfter));
      };
      const onClose = (event) => {
        cancelTimeoutForAutoClose();
        registerTimeout(() => {
          close(event);
        }, unref(hideAfter));
      };
      return {
        onOpen,
        onClose
      };
    };
    const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
    const useForwardRef = (forwardRef) => {
      const setForwardRef = (el) => {
        forwardRef.value = el;
      };
      provide(FORWARD_REF_INJECTION_KEY, {
        setForwardRef
      });
    };
    const useForwardRefDirective = (setForwardRef) => {
      return {
        mounted(el) {
          setForwardRef(el);
        },
        updated(el) {
          setForwardRef(el);
        },
        unmounted() {
          setForwardRef(null);
        }
      };
    };
    const zIndex$1 = ref(0);
    const defaultInitialZIndex = 2e3;
    const zIndexContextKey = Symbol("zIndexContextKey");
    const useZIndex = (zIndexOverrides) => {
      const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);
      const initialZIndex = computed(() => {
        const zIndexFromInjection = unref(zIndexInjection);
        return isNumber$1(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;
      });
      const currentZIndex = computed(() => initialZIndex.value + zIndex$1.value);
      const nextZIndex = () => {
        zIndex$1.value++;
        return currentZIndex.value;
      };
      return {
        initialZIndex,
        currentZIndex,
        nextZIndex
      };
    };
    function useCursor(input) {
      const selectionRef = ref();
      function recordCursor() {
        if (input.value == void 0)
          return;
        const { selectionStart, selectionEnd, value } = input.value;
        if (selectionStart == null || selectionEnd == null)
          return;
        const beforeTxt = value.slice(0, Math.max(0, selectionStart));
        const afterTxt = value.slice(Math.max(0, selectionEnd));
        selectionRef.value = {
          selectionStart,
          selectionEnd,
          value,
          beforeTxt,
          afterTxt
        };
      }
      function setCursor() {
        if (input.value == void 0 || selectionRef.value == void 0)
          return;
        const { value } = input.value;
        const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
        if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
          return;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          const beforeLastChar = beforeTxt[selectionStart - 1];
          const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.value.setSelectionRange(startPos, startPos);
      }
      return [recordCursor, setCursor];
    }
    const useSizeProp = buildProp({
      type: String,
      values: componentSizes,
      required: false
    });
    const SIZE_INJECTION_KEY = Symbol("size");
    const useGlobalSize = () => {
      const injectedSize = inject(SIZE_INJECTION_KEY, {});
      return computed(() => {
        return unref(injectedSize.size) || "";
      });
    };
    function useFocusController(target, { afterFocus, afterBlur } = {}) {
      const instance = getCurrentInstance();
      const { emit: emit2 } = instance;
      const wrapperRef = shallowRef();
      const isFocused = ref(false);
      const handleFocus = (event) => {
        if (isFocused.value)
          return;
        isFocused.value = true;
        emit2("focus", event);
        afterFocus == null ? void 0 : afterFocus();
      };
      const handleBlur = (event) => {
        var _a2;
        if (event.relatedTarget && ((_a2 = wrapperRef.value) == null ? void 0 : _a2.contains(event.relatedTarget)))
          return;
        isFocused.value = false;
        emit2("blur", event);
        afterBlur == null ? void 0 : afterBlur();
      };
      const handleClick = () => {
        var _a2;
        (_a2 = target.value) == null ? void 0 : _a2.focus();
      };
      watch(wrapperRef, (el) => {
        if (el) {
          el.setAttribute("tabindex", "-1");
        }
      });
      useEventListener(wrapperRef, "click", handleClick);
      return {
        wrapperRef,
        isFocused,
        handleFocus,
        handleBlur
      };
    }
    const configProviderContextKey = Symbol();
    const globalConfig = ref();
    function useGlobalConfig(key, defaultValue = void 0) {
      const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
      if (key) {
        return computed(() => {
          var _a2, _b;
          return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
        });
      } else {
        return config;
      }
    }
    function useGlobalComponentSettings(block, sizeFallback) {
      const config = useGlobalConfig();
      const ns = useNamespace(block, computed(() => {
        var _a2;
        return ((_a2 = config.value) == null ? void 0 : _a2.namespace) || defaultNamespace;
      }));
      const locale2 = useLocale(computed(() => {
        var _a2;
        return (_a2 = config.value) == null ? void 0 : _a2.locale;
      }));
      const zIndex2 = useZIndex(computed(() => {
        var _a2;
        return ((_a2 = config.value) == null ? void 0 : _a2.zIndex) || defaultInitialZIndex;
      }));
      const size2 = computed(() => {
        var _a2;
        return unref(sizeFallback) || ((_a2 = config.value) == null ? void 0 : _a2.size) || "";
      });
      provideGlobalConfig(computed(() => unref(config) || {}));
      return {
        ns,
        locale: locale2,
        zIndex: zIndex2,
        size: size2
      };
    }
    const provideGlobalConfig = (config, app, global2 = false) => {
      var _a2;
      const inSetup = !!getCurrentInstance();
      const oldConfig = inSetup ? useGlobalConfig() : void 0;
      const provideFn = (_a2 = app == null ? void 0 : app.provide) != null ? _a2 : inSetup ? provide : void 0;
      if (!provideFn) {
        return;
      }
      const context = computed(() => {
        const cfg = unref(config);
        if (!(oldConfig == null ? void 0 : oldConfig.value))
          return cfg;
        return mergeConfig$1(oldConfig.value, cfg);
      });
      provideFn(configProviderContextKey, context);
      provideFn(localeContextKey, computed(() => context.value.locale));
      provideFn(namespaceContextKey, computed(() => context.value.namespace));
      provideFn(zIndexContextKey, computed(() => context.value.zIndex));
      provideFn(SIZE_INJECTION_KEY, {
        size: computed(() => context.value.size || "")
      });
      if (global2 || !globalConfig.value) {
        globalConfig.value = context.value;
      }
      return context;
    };
    const mergeConfig$1 = (a2, b) => {
      var _a2;
      const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b)])];
      const obj = {};
      for (const key of keys2) {
        obj[key] = (_a2 = b[key]) != null ? _a2 : a2[key];
      }
      return obj;
    };
    const messageConfig = {};
    var _export_sfc$1 = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const iconProps = buildProps({
      size: {
        type: definePropType([Number, String])
      },
      color: {
        type: String
      }
    });
    const __default__$v = defineComponent({
      name: "ElIcon",
      inheritAttrs: false
    });
    const _sfc_main$F = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$v), {
      props: iconProps,
      setup(__props) {
        const props = __props;
        const ns = useNamespace("icon");
        const style = computed(() => {
          const { size: size2, color: color2 } = props;
          if (!size2 && !color2)
            return {};
          return {
            fontSize: isUndefined$1(size2) ? void 0 : addUnit(size2),
            "--color": color2
          };
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("i", mergeProps({
            class: unref(ns).b(),
            style: unref(style)
          }, _ctx.$attrs), [
            renderSlot(_ctx.$slots, "default")
          ], 16);
        };
      }
    }));
    var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
    const ElIcon = withInstall(Icon);
    const formContextKey = Symbol("formContextKey");
    const formItemContextKey = Symbol("formItemContextKey");
    const useFormSize = (fallback, ignore = {}) => {
      const emptyRef = ref(void 0);
      const size2 = ignore.prop ? emptyRef : useProp("size");
      const globalConfig2 = ignore.global ? emptyRef : useGlobalSize();
      const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
      const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
      return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
    };
    const useFormDisabled = (fallback) => {
      const disabled = useProp("disabled");
      const form = inject(formContextKey, void 0);
      return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
    };
    const useFormItem = () => {
      const form = inject(formContextKey, void 0);
      const formItem = inject(formItemContextKey, void 0);
      return {
        form,
        formItem
      };
    };
    const useFormItemInputId = (props, {
      formItemContext,
      disableIdGeneration,
      disableIdManagement
    }) => {
      if (!disableIdGeneration) {
        disableIdGeneration = ref(false);
      }
      if (!disableIdManagement) {
        disableIdManagement = ref(false);
      }
      const inputId = ref();
      let idUnwatch = void 0;
      const isLabeledByFormItem = computed(() => {
        var _a2;
        return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
      });
      onMounted(() => {
        idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id2, disableIdGeneration2]) => {
          const newId2 = id2 != null ? id2 : !disableIdGeneration2 ? useId().value : void 0;
          if (newId2 !== inputId.value) {
            if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
              inputId.value && formItemContext.removeInputId(inputId.value);
              if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId2) {
                formItemContext.addInputId(newId2);
              }
            }
            inputId.value = newId2;
          }
        }, { immediate: true });
      });
      onUnmounted(() => {
        idUnwatch && idUnwatch();
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
        }
      });
      return {
        isLabeledByFormItem,
        inputId
      };
    };
    let hiddenTextarea = void 0;
    const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  ${isFirefox() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
    const CONTEXT_STYLE = [
      "letter-spacing",
      "line-height",
      "padding-top",
      "padding-bottom",
      "font-family",
      "font-weight",
      "font-size",
      "text-rendering",
      "text-transform",
      "width",
      "text-indent",
      "padding-left",
      "padding-right",
      "border-width",
      "box-sizing"
    ];
    function calculateNodeStyling(targetElement) {
      const style = window.getComputedStyle(targetElement);
      const boxSizing = style.getPropertyValue("box-sizing");
      const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
      const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
      const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
      return { contextStyle, paddingSize, borderSize, boxSizing };
    }
    function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
      var _a2;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        document.body.appendChild(hiddenTextarea);
      }
      const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
      hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
      hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
      let height = hiddenTextarea.scrollHeight;
      const result = {};
      if (boxSizing === "border-box") {
        height = height + borderSize;
      } else if (boxSizing === "content-box") {
        height = height - paddingSize;
      }
      hiddenTextarea.value = "";
      const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
      if (isNumber$1(minRows)) {
        let minHeight = singleRowHeight * minRows;
        if (boxSizing === "border-box") {
          minHeight = minHeight + paddingSize + borderSize;
        }
        height = Math.max(minHeight, height);
        result.minHeight = `${minHeight}px`;
      }
      if (isNumber$1(maxRows)) {
        let maxHeight = singleRowHeight * maxRows;
        if (boxSizing === "border-box") {
          maxHeight = maxHeight + paddingSize + borderSize;
        }
        height = Math.min(maxHeight, height);
      }
      result.height = `${height}px`;
      (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
      hiddenTextarea = void 0;
      return result;
    }
    const inputProps = buildProps({
      id: {
        type: String,
        default: void 0
      },
      size: useSizeProp,
      disabled: Boolean,
      modelValue: {
        type: definePropType([
          String,
          Number,
          Object
        ]),
        default: ""
      },
      type: {
        type: String,
        default: "text"
      },
      resize: {
        type: String,
        values: ["none", "both", "horizontal", "vertical"]
      },
      autosize: {
        type: definePropType([Boolean, Object]),
        default: false
      },
      autocomplete: {
        type: String,
        default: "off"
      },
      formatter: {
        type: Function
      },
      parser: {
        type: Function
      },
      placeholder: {
        type: String
      },
      form: {
        type: String
      },
      readonly: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: false
      },
      showPassword: {
        type: Boolean,
        default: false
      },
      showWordLimit: {
        type: Boolean,
        default: false
      },
      suffixIcon: {
        type: iconPropType
      },
      prefixIcon: {
        type: iconPropType
      },
      containerRole: {
        type: String,
        default: void 0
      },
      label: {
        type: String,
        default: void 0
      },
      tabindex: {
        type: [String, Number],
        default: 0
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      inputStyle: {
        type: definePropType([Object, Array, String]),
        default: () => mutable({})
      }
    });
    const inputEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isString$2(value),
      input: (value) => isString$2(value),
      change: (value) => isString$2(value),
      focus: (evt) => evt instanceof FocusEvent,
      blur: (evt) => evt instanceof FocusEvent,
      clear: () => true,
      mouseleave: (evt) => evt instanceof MouseEvent,
      mouseenter: (evt) => evt instanceof MouseEvent,
      keydown: (evt) => evt instanceof Event,
      compositionstart: (evt) => evt instanceof CompositionEvent,
      compositionupdate: (evt) => evt instanceof CompositionEvent,
      compositionend: (evt) => evt instanceof CompositionEvent
    };
    const _hoisted_1$f = ["role"];
    const _hoisted_2$b = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form"];
    const _hoisted_3$8 = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form"];
    const __default__$u = defineComponent({
      name: "ElInput",
      inheritAttrs: false
    });
    const _sfc_main$E = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$u), {
      props: inputProps,
      emits: inputEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const rawAttrs = useAttrs$1();
        const slots = useSlots();
        const containerAttrs = computed(() => {
          const comboBoxAttrs = {};
          if (props.containerRole === "combobox") {
            comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
            comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
            comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
          }
          return comboBoxAttrs;
        });
        const containerKls = computed(() => [
          props.type === "textarea" ? nsTextarea.b() : nsInput.b(),
          nsInput.m(inputSize.value),
          nsInput.is("disabled", inputDisabled.value),
          nsInput.is("exceed", inputExceed.value),
          {
            [nsInput.b("group")]: slots.prepend || slots.append,
            [nsInput.bm("group", "append")]: slots.append,
            [nsInput.bm("group", "prepend")]: slots.prepend,
            [nsInput.m("prefix")]: slots.prefix || props.prefixIcon,
            [nsInput.m("suffix")]: slots.suffix || props.suffixIcon || props.clearable || props.showPassword,
            [nsInput.bm("suffix", "password-clear")]: showClear.value && showPwdVisible.value
          },
          rawAttrs.class
        ]);
        const wrapperKls = computed(() => [
          nsInput.e("wrapper"),
          nsInput.is("focus", isFocused.value)
        ]);
        const attrs = useAttrs({
          excludeKeys: computed(() => {
            return Object.keys(containerAttrs.value);
          })
        });
        const { form, formItem } = useFormItem();
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const inputSize = useFormSize();
        const inputDisabled = useFormDisabled();
        const nsInput = useNamespace("input");
        const nsTextarea = useNamespace("textarea");
        const input = shallowRef();
        const textarea = shallowRef();
        const hovering = ref(false);
        const isComposing = ref(false);
        const passwordVisible = ref(false);
        const countStyle = ref();
        const textareaCalcStyle = shallowRef(props.inputStyle);
        const _ref = computed(() => input.value || textarea.value);
        const { wrapperRef, isFocused, handleFocus, handleBlur } = useFocusController(_ref, {
          afterBlur() {
            var _a2;
            if (props.validateEvent) {
              (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
            }
          }
        });
        const needStatusIcon = computed(() => {
          var _a2;
          return (_a2 = form == null ? void 0 : form.statusIcon) != null ? _a2 : false;
        });
        const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
        const validateIcon = computed(() => validateState.value && ValidateComponentsMap[validateState.value]);
        const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
        const containerStyle = computed(() => [
          rawAttrs.style,
          props.inputStyle
        ]);
        const textareaStyle = computed(() => [
          props.inputStyle,
          textareaCalcStyle.value,
          { resize: props.resize }
        ]);
        const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
        const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (isFocused.value || hovering.value));
        const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || isFocused.value));
        const isWordLimitVisible = computed(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
        const textLength = computed(() => nativeInputValue.value.length);
        const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
        const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
        const [recordCursor, setCursor] = useCursor(input);
        useResizeObserver(textarea, (entries) => {
          onceInitSizeTextarea();
          if (!isWordLimitVisible.value || props.resize !== "both")
            return;
          const entry = entries[0];
          const { width } = entry.contentRect;
          countStyle.value = {
            right: `calc(100% - ${width + 15 + 6}px)`
          };
        });
        const resizeTextarea = () => {
          const { type, autosize } = props;
          if (!isClient || type !== "textarea" || !textarea.value)
            return;
          if (autosize) {
            const minRows = isObject$2(autosize) ? autosize.minRows : void 0;
            const maxRows = isObject$2(autosize) ? autosize.maxRows : void 0;
            const textareaStyle2 = calcTextareaHeight(textarea.value, minRows, maxRows);
            textareaCalcStyle.value = __spreadValues({
              overflowY: "hidden"
            }, textareaStyle2);
            nextTick(() => {
              textarea.value.offsetHeight;
              textareaCalcStyle.value = textareaStyle2;
            });
          } else {
            textareaCalcStyle.value = {
              minHeight: calcTextareaHeight(textarea.value).minHeight
            };
          }
        };
        const createOnceInitResize = (resizeTextarea2) => {
          let isInit = false;
          return () => {
            var _a2;
            if (isInit || !props.autosize)
              return;
            const isElHidden = ((_a2 = textarea.value) == null ? void 0 : _a2.offsetParent) === null;
            if (!isElHidden) {
              resizeTextarea2();
              isInit = true;
            }
          };
        };
        const onceInitSizeTextarea = createOnceInitResize(resizeTextarea);
        const setNativeInputValue = () => {
          const input2 = _ref.value;
          const formatterValue = props.formatter ? props.formatter(nativeInputValue.value) : nativeInputValue.value;
          if (!input2 || input2.value === formatterValue)
            return;
          input2.value = formatterValue;
        };
        const handleInput = (event) => __async(this, null, function* () {
          recordCursor();
          let { value } = event.target;
          if (props.formatter) {
            value = props.parser ? props.parser(value) : value;
          }
          if (isComposing.value)
            return;
          if (value === nativeInputValue.value) {
            setNativeInputValue();
            return;
          }
          emit2(UPDATE_MODEL_EVENT, value);
          emit2("input", value);
          yield nextTick();
          setNativeInputValue();
          setCursor();
        });
        const handleChange = (event) => {
          emit2("change", event.target.value);
        };
        const handleCompositionStart = (event) => {
          emit2("compositionstart", event);
          isComposing.value = true;
        };
        const handleCompositionUpdate = (event) => {
          var _a2;
          emit2("compositionupdate", event);
          const text = (_a2 = event.target) == null ? void 0 : _a2.value;
          const lastCharacter = text[text.length - 1] || "";
          isComposing.value = !isKorean(lastCharacter);
        };
        const handleCompositionEnd = (event) => {
          emit2("compositionend", event);
          if (isComposing.value) {
            isComposing.value = false;
            handleInput(event);
          }
        };
        const handlePasswordVisible = () => {
          passwordVisible.value = !passwordVisible.value;
          focus();
        };
        const focus = () => __async(this, null, function* () {
          var _a2;
          yield nextTick();
          (_a2 = _ref.value) == null ? void 0 : _a2.focus();
        });
        const blur = () => {
          var _a2;
          return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
        };
        const handleMouseLeave = (evt) => {
          hovering.value = false;
          emit2("mouseleave", evt);
        };
        const handleMouseEnter = (evt) => {
          hovering.value = true;
          emit2("mouseenter", evt);
        };
        const handleKeydown = (evt) => {
          emit2("keydown", evt);
        };
        const select2 = () => {
          var _a2;
          (_a2 = _ref.value) == null ? void 0 : _a2.select();
        };
        const clear2 = () => {
          emit2(UPDATE_MODEL_EVENT, "");
          emit2("change", "");
          emit2("clear");
          emit2("input", "");
        };
        watch(() => props.modelValue, () => {
          var _a2;
          nextTick(() => resizeTextarea());
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
          }
        });
        watch(nativeInputValue, () => setNativeInputValue());
        watch(() => props.type, () => __async(this, null, function* () {
          yield nextTick();
          setNativeInputValue();
          resizeTextarea();
        }));
        onMounted(() => {
          if (!props.formatter && props.parser)
            ;
          setNativeInputValue();
          nextTick(resizeTextarea);
        });
        expose({
          input,
          textarea,
          ref: _ref,
          textareaStyle,
          autosize: toRef(props, "autosize"),
          focus,
          blur,
          select: select2,
          clear: clear2,
          resizeTextarea
        });
        return (_ctx, _cache) => {
          return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
            class: unref(containerKls),
            style: unref(containerStyle),
            role: _ctx.containerRole,
            onMouseenter: handleMouseEnter,
            onMouseleave: handleMouseLeave
          }), [
            createCommentVNode(" input "),
            _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createCommentVNode(" prepend slot "),
              _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(nsInput).be("group", "prepend"))
              }, [
                renderSlot(_ctx.$slots, "prepend")
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                ref_key: "wrapperRef",
                ref: wrapperRef,
                class: normalizeClass(unref(wrapperKls))
              }, [
                createCommentVNode(" prefix slot "),
                _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  class: normalizeClass(unref(nsInput).e("prefix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("prefix-inner"))
                  }, [
                    renderSlot(_ctx.$slots, "prefix"),
                    _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 0,
                      class: normalizeClass(unref(nsInput).e("icon"))
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true),
                createBaseVNode("input", mergeProps({
                  id: unref(inputId),
                  ref_key: "input",
                  ref: input,
                  class: unref(nsInput).e("inner")
                }, unref(attrs), {
                  type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
                  disabled: unref(inputDisabled),
                  formatter: _ctx.formatter,
                  parser: _ctx.parser,
                  readonly: _ctx.readonly,
                  autocomplete: _ctx.autocomplete,
                  tabindex: _ctx.tabindex,
                  "aria-label": _ctx.label,
                  placeholder: _ctx.placeholder,
                  style: _ctx.inputStyle,
                  form: props.form,
                  onCompositionstart: handleCompositionStart,
                  onCompositionupdate: handleCompositionUpdate,
                  onCompositionend: handleCompositionEnd,
                  onInput: handleInput,
                  onFocus: _cache[0] || (_cache[0] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                  onBlur: _cache[1] || (_cache[1] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                  onChange: handleChange,
                  onKeydown: handleKeydown
                }), null, 16, _hoisted_2$b),
                createCommentVNode(" suffix slot "),
                unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass(unref(nsInput).e("suffix"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("suffix-inner"))
                  }, [
                    !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      renderSlot(_ctx.$slots, "suffix"),
                      _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass(unref(nsInput).e("icon"))
                      }, {
                        default: withCtx(() => [
                          (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 64)) : createCommentVNode("v-if", true),
                    unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 1,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                      onMousedown: withModifiers(unref(NOOP), ["prevent"]),
                      onClick: clear2
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(circle_close_default))
                      ]),
                      _: 1
                    }, 8, ["class", "onMousedown"])) : createCommentVNode("v-if", true),
                    unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 2,
                      class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                      onClick: handlePasswordVisible
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true),
                    unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                      key: 3,
                      class: normalizeClass(unref(nsInput).e("count"))
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(nsInput).e("count-inner"))
                      }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 3)
                    ], 2)) : createCommentVNode("v-if", true),
                    unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 4,
                      class: normalizeClass([
                        unref(nsInput).e("icon"),
                        unref(nsInput).e("validateIcon"),
                        unref(nsInput).is("loading", unref(validateState) === "validating")
                      ])
                    }, {
                      default: withCtx(() => [
                        (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                      ]),
                      _: 1
                    }, 8, ["class"])) : createCommentVNode("v-if", true)
                  ], 2)
                ], 2)) : createCommentVNode("v-if", true)
              ], 2),
              createCommentVNode(" append slot "),
              _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(nsInput).be("group", "append"))
              }, [
                renderSlot(_ctx.$slots, "append")
              ], 2)) : createCommentVNode("v-if", true)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createCommentVNode(" textarea "),
              createBaseVNode("textarea", mergeProps({
                id: unref(inputId),
                ref_key: "textarea",
                ref: textarea,
                class: unref(nsTextarea).e("inner")
              }, unref(attrs), {
                tabindex: _ctx.tabindex,
                disabled: unref(inputDisabled),
                readonly: _ctx.readonly,
                autocomplete: _ctx.autocomplete,
                style: unref(textareaStyle),
                "aria-label": _ctx.label,
                placeholder: _ctx.placeholder,
                form: props.form,
                onCompositionstart: handleCompositionStart,
                onCompositionupdate: handleCompositionUpdate,
                onCompositionend: handleCompositionEnd,
                onInput: handleInput,
                onFocus: _cache[2] || (_cache[2] = (...args) => unref(handleFocus) && unref(handleFocus)(...args)),
                onBlur: _cache[3] || (_cache[3] = (...args) => unref(handleBlur) && unref(handleBlur)(...args)),
                onChange: handleChange,
                onKeydown: handleKeydown
              }), null, 16, _hoisted_3$8),
              unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                key: 0,
                style: normalizeStyle(countStyle.value),
                class: normalizeClass(unref(nsInput).e("count"))
              }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 7)) : createCommentVNode("v-if", true)
            ], 64))
          ], 16, _hoisted_1$f)), [
            [vShow, _ctx.type !== "hidden"]
          ]);
        };
      }
    }));
    var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
    const ElInput = withInstall(Input);
    const GAP = 4;
    const BAR_MAP = {
      vertical: {
        offset: "offsetHeight",
        scroll: "scrollTop",
        scrollSize: "scrollHeight",
        size: "height",
        key: "vertical",
        axis: "Y",
        client: "clientY",
        direction: "top"
      },
      horizontal: {
        offset: "offsetWidth",
        scroll: "scrollLeft",
        scrollSize: "scrollWidth",
        size: "width",
        key: "horizontal",
        axis: "X",
        client: "clientX",
        direction: "left"
      }
    };
    const renderThumbStyle = ({
      move,
      size: size2,
      bar
    }) => ({
      [bar.size]: size2,
      transform: `translate${bar.axis}(${move}%)`
    });
    const scrollbarContextKey = Symbol("scrollbarContextKey");
    const thumbProps = buildProps({
      vertical: Boolean,
      size: String,
      move: Number,
      ratio: {
        type: Number,
        required: true
      },
      always: Boolean
    });
    const COMPONENT_NAME$5 = "Thumb";
    const _sfc_main$D = /* @__PURE__ */ defineComponent({
      __name: "thumb",
      props: thumbProps,
      setup(__props) {
        const props = __props;
        const scrollbar = inject(scrollbarContextKey);
        const ns = useNamespace("scrollbar");
        if (!scrollbar)
          throwError(COMPONENT_NAME$5, "can not inject scrollbar context");
        const instance = ref();
        const thumb = ref();
        const thumbState = ref({});
        const visible = ref(false);
        let cursorDown = false;
        let cursorLeave = false;
        let originalOnSelectStart = isClient ? document.onselectstart : null;
        const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
        const thumbStyle = computed(() => renderThumbStyle({
          size: props.size,
          move: props.move,
          bar: bar.value
        }));
        const offsetRatio = computed(() => __pow(instance.value[bar.value.offset], 2) / scrollbar.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
        const clickThumbHandler = (e3) => {
          var _a2;
          e3.stopPropagation();
          if (e3.ctrlKey || [1, 2].includes(e3.button))
            return;
          (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
          startDrag(e3);
          const el = e3.currentTarget;
          if (!el)
            return;
          thumbState.value[bar.value.axis] = el[bar.value.offset] - (e3[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
        };
        const clickTrackHandler = (e3) => {
          if (!thumb.value || !instance.value || !scrollbar.wrapElement)
            return;
          const offset = Math.abs(e3.target.getBoundingClientRect()[bar.value.direction] - e3[bar.value.client]);
          const thumbHalf = thumb.value[bar.value.offset] / 2;
          const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const startDrag = (e3) => {
          e3.stopImmediatePropagation();
          cursorDown = true;
          document.addEventListener("mousemove", mouseMoveDocumentHandler);
          document.addEventListener("mouseup", mouseUpDocumentHandler);
          originalOnSelectStart = document.onselectstart;
          document.onselectstart = () => false;
        };
        const mouseMoveDocumentHandler = (e3) => {
          if (!instance.value || !thumb.value)
            return;
          if (cursorDown === false)
            return;
          const prevPage = thumbState.value[bar.value.axis];
          if (!prevPage)
            return;
          const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e3[bar.value.client]) * -1;
          const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
          const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
          scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
        };
        const mouseUpDocumentHandler = () => {
          cursorDown = false;
          thumbState.value[bar.value.axis] = 0;
          document.removeEventListener("mousemove", mouseMoveDocumentHandler);
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
          restoreOnselectstart();
          if (cursorLeave)
            visible.value = false;
        };
        const mouseMoveScrollbarHandler = () => {
          cursorLeave = false;
          visible.value = !!props.size;
        };
        const mouseLeaveScrollbarHandler = () => {
          cursorLeave = true;
          visible.value = cursorDown;
        };
        onBeforeUnmount(() => {
          restoreOnselectstart();
          document.removeEventListener("mouseup", mouseUpDocumentHandler);
        });
        const restoreOnselectstart = () => {
          if (document.onselectstart !== originalOnSelectStart)
            document.onselectstart = originalOnSelectStart;
        };
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
        useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition$1, {
            name: unref(ns).b("fade"),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                ref_key: "instance",
                ref: instance,
                class: normalizeClass([unref(ns).e("bar"), unref(ns).is(unref(bar).key)]),
                onMousedown: clickTrackHandler
              }, [
                createBaseVNode("div", {
                  ref_key: "thumb",
                  ref: thumb,
                  class: normalizeClass(unref(ns).e("thumb")),
                  style: normalizeStyle(unref(thumbStyle)),
                  onMousedown: clickThumbHandler
                }, null, 38)
              ], 34), [
                [vShow, _ctx.always || visible.value]
              ])
            ]),
            _: 1
          }, 8, ["name"]);
        };
      }
    });
    var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
    const barProps = buildProps({
      always: {
        type: Boolean,
        default: true
      },
      width: String,
      height: String,
      ratioX: {
        type: Number,
        default: 1
      },
      ratioY: {
        type: Number,
        default: 1
      }
    });
    const _sfc_main$C = /* @__PURE__ */ defineComponent({
      __name: "bar",
      props: barProps,
      setup(__props, { expose }) {
        const props = __props;
        const moveX = ref(0);
        const moveY = ref(0);
        const handleScroll = (wrap) => {
          if (wrap) {
            const offsetHeight = wrap.offsetHeight - GAP;
            const offsetWidth = wrap.offsetWidth - GAP;
            moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
            moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
          }
        };
        expose({
          handleScroll
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(Thumb, {
              move: moveX.value,
              ratio: _ctx.ratioX,
              size: _ctx.width,
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"]),
            createVNode(Thumb, {
              move: moveY.value,
              ratio: _ctx.ratioY,
              size: _ctx.height,
              vertical: "",
              always: _ctx.always
            }, null, 8, ["move", "ratio", "size", "always"])
          ], 64);
        };
      }
    });
    var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
    const scrollbarProps = buildProps({
      height: {
        type: [String, Number],
        default: ""
      },
      maxHeight: {
        type: [String, Number],
        default: ""
      },
      native: {
        type: Boolean,
        default: false
      },
      wrapStyle: {
        type: definePropType([String, Object, Array]),
        default: ""
      },
      wrapClass: {
        type: [String, Array],
        default: ""
      },
      viewClass: {
        type: [String, Array],
        default: ""
      },
      viewStyle: {
        type: [String, Array, Object],
        default: ""
      },
      noresize: Boolean,
      tag: {
        type: String,
        default: "div"
      },
      always: Boolean,
      minSize: {
        type: Number,
        default: 20
      }
    });
    const scrollbarEmits = {
      scroll: ({
        scrollTop,
        scrollLeft
      }) => [scrollTop, scrollLeft].every(isNumber$1)
    };
    const COMPONENT_NAME$4 = "ElScrollbar";
    const __default__$t = defineComponent({
      name: COMPONENT_NAME$4
    });
    const _sfc_main$B = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$t), {
      props: scrollbarProps,
      emits: scrollbarEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("scrollbar");
        let stopResizeObserver = void 0;
        let stopResizeListener = void 0;
        const scrollbarRef = ref();
        const wrapRef = ref();
        const resizeRef = ref();
        const sizeWidth = ref("0");
        const sizeHeight = ref("0");
        const barRef = ref();
        const ratioY = ref(1);
        const ratioX = ref(1);
        const style = computed(() => {
          const style2 = {};
          if (props.height)
            style2.height = addUnit(props.height);
          if (props.maxHeight)
            style2.maxHeight = addUnit(props.maxHeight);
          return [props.wrapStyle, style2];
        });
        const wrapKls = computed(() => {
          return [
            props.wrapClass,
            ns.e("wrap"),
            { [ns.em("wrap", "hidden-default")]: !props.native }
          ];
        });
        const resizeKls = computed(() => {
          return [ns.e("view"), props.viewClass];
        });
        const handleScroll = () => {
          var _a2;
          if (wrapRef.value) {
            (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
            emit2("scroll", {
              scrollTop: wrapRef.value.scrollTop,
              scrollLeft: wrapRef.value.scrollLeft
            });
          }
        };
        function scrollTo(arg1, arg2) {
          if (isObject$2(arg1)) {
            wrapRef.value.scrollTo(arg1);
          } else if (isNumber$1(arg1) && isNumber$1(arg2)) {
            wrapRef.value.scrollTo(arg1, arg2);
          }
        }
        const setScrollTop = (value) => {
          if (!isNumber$1(value)) {
            return;
          }
          wrapRef.value.scrollTop = value;
        };
        const setScrollLeft = (value) => {
          if (!isNumber$1(value)) {
            return;
          }
          wrapRef.value.scrollLeft = value;
        };
        const update = () => {
          if (!wrapRef.value)
            return;
          const offsetHeight = wrapRef.value.offsetHeight - GAP;
          const offsetWidth = wrapRef.value.offsetWidth - GAP;
          const originalHeight = __pow(offsetHeight, 2) / wrapRef.value.scrollHeight;
          const originalWidth = __pow(offsetWidth, 2) / wrapRef.value.scrollWidth;
          const height = Math.max(originalHeight, props.minSize);
          const width = Math.max(originalWidth, props.minSize);
          ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
          ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
          sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
          sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
        };
        watch(() => props.noresize, (noresize) => {
          if (noresize) {
            stopResizeObserver == null ? void 0 : stopResizeObserver();
            stopResizeListener == null ? void 0 : stopResizeListener();
          } else {
            ({ stop: stopResizeObserver } = useResizeObserver(resizeRef, update));
            stopResizeListener = useEventListener("resize", update);
          }
        }, { immediate: true });
        watch(() => [props.maxHeight, props.height], () => {
          if (!props.native)
            nextTick(() => {
              var _a2;
              update();
              if (wrapRef.value) {
                (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrapRef.value);
              }
            });
        });
        provide(scrollbarContextKey, reactive({
          scrollbarElement: scrollbarRef,
          wrapElement: wrapRef
        }));
        onMounted(() => {
          if (!props.native)
            nextTick(() => {
              update();
            });
        });
        onUpdated(() => update());
        expose({
          wrapRef,
          update,
          scrollTo,
          setScrollTop,
          setScrollLeft,
          handleScroll
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "scrollbarRef",
            ref: scrollbarRef,
            class: normalizeClass(unref(ns).b())
          }, [
            createBaseVNode("div", {
              ref_key: "wrapRef",
              ref: wrapRef,
              class: normalizeClass(unref(wrapKls)),
              style: normalizeStyle(unref(style)),
              onScroll: handleScroll
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
                ref_key: "resizeRef",
                ref: resizeRef,
                class: normalizeClass(unref(resizeKls)),
                style: normalizeStyle(_ctx.viewStyle)
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["class", "style"]))
            ], 38),
            !_ctx.native ? (openBlock(), createBlock(Bar, {
              key: 0,
              ref_key: "barRef",
              ref: barRef,
              height: sizeHeight.value,
              width: sizeWidth.value,
              always: _ctx.always,
              "ratio-x": ratioX.value,
              "ratio-y": ratioY.value
            }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
          ], 2);
        };
      }
    }));
    var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
    const ElScrollbar = withInstall(Scrollbar);
    const POPPER_INJECTION_KEY = Symbol("popper");
    const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
    const roleTypes = [
      "dialog",
      "grid",
      "group",
      "listbox",
      "menu",
      "navigation",
      "tooltip",
      "tree"
    ];
    const popperProps = buildProps({
      role: {
        type: String,
        values: roleTypes,
        default: "tooltip"
      }
    });
    const __default__$s = defineComponent({
      name: "ElPopper",
      inheritAttrs: false
    });
    const _sfc_main$A = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$s), {
      props: popperProps,
      setup(__props, { expose }) {
        const props = __props;
        const triggerRef2 = ref();
        const popperInstanceRef = ref();
        const contentRef = ref();
        const referenceRef = ref();
        const role = computed(() => props.role);
        const popperProvides = {
          triggerRef: triggerRef2,
          popperInstanceRef,
          contentRef,
          referenceRef,
          role
        };
        expose(popperProvides);
        provide(POPPER_INJECTION_KEY, popperProvides);
        return (_ctx, _cache) => {
          return renderSlot(_ctx.$slots, "default");
        };
      }
    }));
    var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
    const popperArrowProps = buildProps({
      arrowOffset: {
        type: Number,
        default: 5
      }
    });
    const __default__$r = defineComponent({
      name: "ElPopperArrow",
      inheritAttrs: false
    });
    const _sfc_main$z = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$r), {
      props: popperArrowProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("popper");
        const { arrowOffset, arrowRef, arrowStyle } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
        watch(() => props.arrowOffset, (val) => {
          arrowOffset.value = val;
        });
        onBeforeUnmount(() => {
          arrowRef.value = void 0;
        });
        expose({
          arrowRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("span", {
            ref_key: "arrowRef",
            ref: arrowRef,
            class: normalizeClass(unref(ns).e("arrow")),
            style: normalizeStyle(unref(arrowStyle)),
            "data-popper-arrow": ""
          }, null, 6);
        };
      }
    }));
    var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
    const NAME = "ElOnlyChild";
    const OnlyChild = defineComponent({
      name: NAME,
      setup(_, {
        slots,
        attrs
      }) {
        var _a2;
        const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
        const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
        return () => {
          var _a22;
          const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
          if (!defaultSlot)
            return null;
          if (defaultSlot.length > 1) {
            return null;
          }
          const firstLegitNode = findFirstLegitChild(defaultSlot);
          if (!firstLegitNode) {
            return null;
          }
          return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
        };
      }
    });
    function findFirstLegitChild(node) {
      if (!node)
        return null;
      const children2 = node;
      for (const child of children2) {
        if (isObject$2(child)) {
          switch (child.type) {
            case Comment:
              continue;
            case Text:
            case "svg":
              return wrapTextContent(child);
            case Fragment:
              return findFirstLegitChild(child.children);
            default:
              return child;
          }
        }
        return wrapTextContent(child);
      }
      return null;
    }
    function wrapTextContent(s) {
      const ns = useNamespace("only-child");
      return createVNode("span", {
        "class": ns.e("content")
      }, [s]);
    }
    const popperTriggerProps = buildProps({
      virtualRef: {
        type: definePropType(Object)
      },
      virtualTriggering: Boolean,
      onMouseenter: {
        type: definePropType(Function)
      },
      onMouseleave: {
        type: definePropType(Function)
      },
      onClick: {
        type: definePropType(Function)
      },
      onKeydown: {
        type: definePropType(Function)
      },
      onFocus: {
        type: definePropType(Function)
      },
      onBlur: {
        type: definePropType(Function)
      },
      onContextmenu: {
        type: definePropType(Function)
      },
      id: String,
      open: Boolean
    });
    const __default__$q = defineComponent({
      name: "ElPopperTrigger",
      inheritAttrs: false
    });
    const _sfc_main$y = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$q), {
      props: popperTriggerProps,
      setup(__props, { expose }) {
        const props = __props;
        const { role, triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
        useForwardRef(triggerRef2);
        const ariaControls = computed(() => {
          return ariaHaspopup.value ? props.id : void 0;
        });
        const ariaDescribedby = computed(() => {
          if (role && role.value === "tooltip") {
            return props.open && props.id ? props.id : void 0;
          }
          return void 0;
        });
        const ariaHaspopup = computed(() => {
          if (role && role.value !== "tooltip") {
            return role.value;
          }
          return void 0;
        });
        const ariaExpanded = computed(() => {
          return ariaHaspopup.value ? `${props.open}` : void 0;
        });
        let virtualTriggerAriaStopWatch = void 0;
        onMounted(() => {
          watch(() => props.virtualRef, (virtualEl) => {
            if (virtualEl) {
              triggerRef2.value = unrefElement(virtualEl);
            }
          }, {
            immediate: true
          });
          watch(triggerRef2, (el, prevEl) => {
            virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
            virtualTriggerAriaStopWatch = void 0;
            if (isElement(el)) {
              [
                "onMouseenter",
                "onMouseleave",
                "onClick",
                "onKeydown",
                "onFocus",
                "onBlur",
                "onContextmenu"
              ].forEach((eventName) => {
                var _a2;
                const handler = props[eventName];
                if (handler) {
                  el.addEventListener(eventName.slice(2).toLowerCase(), handler);
                  (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
                }
              });
              virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
                [
                  "aria-controls",
                  "aria-describedby",
                  "aria-haspopup",
                  "aria-expanded"
                ].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (isElement(prevEl)) {
              [
                "aria-controls",
                "aria-describedby",
                "aria-haspopup",
                "aria-expanded"
              ].forEach((key) => prevEl.removeAttribute(key));
            }
          }, {
            immediate: true
          });
        });
        onBeforeUnmount(() => {
          virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
          virtualTriggerAriaStopWatch = void 0;
        });
        expose({
          triggerRef: triggerRef2
        });
        return (_ctx, _cache) => {
          return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
            "aria-controls": unref(ariaControls),
            "aria-describedby": unref(ariaDescribedby),
            "aria-expanded": unref(ariaExpanded),
            "aria-haspopup": unref(ariaHaspopup)
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
        };
      }
    }));
    var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
    const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
    const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
    const FOCUSOUT_PREVENTED = "focus-trap.focusout-prevented";
    const FOCUS_AFTER_TRAPPED_OPTS = {
      cancelable: true,
      bubbles: false
    };
    const FOCUSOUT_PREVENTED_OPTS = {
      cancelable: true,
      bubbles: false
    };
    const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
    const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
    const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
    const focusReason = ref();
    const lastUserFocusTimestamp = ref(0);
    const lastAutomatedFocusTimestamp = ref(0);
    let focusReasonUserCount = 0;
    const obtainAllFocusableElements = (element2) => {
      const nodes = [];
      const walker = document.createTreeWalker(element2, NodeFilter.SHOW_ELEMENT, {
        acceptNode: (node) => {
          const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
          if (node.disabled || node.hidden || isHiddenInput)
            return NodeFilter.FILTER_SKIP;
          return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        }
      });
      while (walker.nextNode())
        nodes.push(walker.currentNode);
      return nodes;
    };
    const getVisibleElement = (elements, container) => {
      for (const element2 of elements) {
        if (!isHidden(element2, container))
          return element2;
      }
    };
    const isHidden = (element2, container) => {
      if (getComputedStyle(element2).visibility === "hidden")
        return true;
      while (element2) {
        if (container && element2 === container)
          return false;
        if (getComputedStyle(element2).display === "none")
          return true;
        element2 = element2.parentElement;
      }
      return false;
    };
    const getEdges = (container) => {
      const focusable = obtainAllFocusableElements(container);
      const first = getVisibleElement(focusable, container);
      const last = getVisibleElement(focusable.reverse(), container);
      return [first, last];
    };
    const isSelectable = (element2) => {
      return element2 instanceof HTMLInputElement && "select" in element2;
    };
    const tryFocus = (element2, shouldSelect) => {
      if (element2 && element2.focus) {
        const prevFocusedElement = document.activeElement;
        element2.focus({ preventScroll: true });
        lastAutomatedFocusTimestamp.value = window.performance.now();
        if (element2 !== prevFocusedElement && isSelectable(element2) && shouldSelect) {
          element2.select();
        }
      }
    };
    function removeFromStack(list, item) {
      const copy2 = [...list];
      const idx = list.indexOf(item);
      if (idx !== -1) {
        copy2.splice(idx, 1);
      }
      return copy2;
    }
    const createFocusableStack = () => {
      let stack = [];
      const push = (layer) => {
        const currentLayer = stack[0];
        if (currentLayer && layer !== currentLayer) {
          currentLayer.pause();
        }
        stack = removeFromStack(stack, layer);
        stack.unshift(layer);
      };
      const remove2 = (layer) => {
        var _a2, _b;
        stack = removeFromStack(stack, layer);
        (_b = (_a2 = stack[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
      };
      return {
        push,
        remove: remove2
      };
    };
    const focusFirstDescendant = (elements, shouldSelect = false) => {
      const prevFocusedElement = document.activeElement;
      for (const element2 of elements) {
        tryFocus(element2, shouldSelect);
        if (document.activeElement !== prevFocusedElement)
          return;
      }
    };
    const focusableStack = createFocusableStack();
    const isFocusCausedByUserEvent = () => {
      return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;
    };
    const notifyFocusReasonPointer = () => {
      focusReason.value = "pointer";
      lastUserFocusTimestamp.value = window.performance.now();
    };
    const notifyFocusReasonKeydown = () => {
      focusReason.value = "keyboard";
      lastUserFocusTimestamp.value = window.performance.now();
    };
    const useFocusReason = () => {
      onMounted(() => {
        if (focusReasonUserCount === 0) {
          document.addEventListener("mousedown", notifyFocusReasonPointer);
          document.addEventListener("touchstart", notifyFocusReasonPointer);
          document.addEventListener("keydown", notifyFocusReasonKeydown);
        }
        focusReasonUserCount++;
      });
      onBeforeUnmount(() => {
        focusReasonUserCount--;
        if (focusReasonUserCount <= 0) {
          document.removeEventListener("mousedown", notifyFocusReasonPointer);
          document.removeEventListener("touchstart", notifyFocusReasonPointer);
          document.removeEventListener("keydown", notifyFocusReasonKeydown);
        }
      });
      return {
        focusReason,
        lastUserFocusTimestamp,
        lastAutomatedFocusTimestamp
      };
    };
    const createFocusOutPreventedEvent = (detail) => {
      return new CustomEvent(FOCUSOUT_PREVENTED, __spreadProps(__spreadValues({}, FOCUSOUT_PREVENTED_OPTS), {
        detail
      }));
    };
    const _sfc_main$x = defineComponent({
      name: "ElFocusTrap",
      inheritAttrs: false,
      props: {
        loop: Boolean,
        trapped: Boolean,
        focusTrapEl: Object,
        focusStartEl: {
          type: [Object, String],
          default: "first"
        }
      },
      emits: [
        ON_TRAP_FOCUS_EVT,
        ON_RELEASE_FOCUS_EVT,
        "focusin",
        "focusout",
        "focusout-prevented",
        "release-requested"
      ],
      setup(props, { emit: emit2 }) {
        const forwardRef = ref();
        let lastFocusBeforeTrapped;
        let lastFocusAfterTrapped;
        const { focusReason: focusReason2 } = useFocusReason();
        useEscapeKeydown((event) => {
          if (props.trapped && !focusLayer.paused) {
            emit2("release-requested", event);
          }
        });
        const focusLayer = {
          paused: false,
          pause() {
            this.paused = true;
          },
          resume() {
            this.paused = false;
          }
        };
        const onKeydown = (e3) => {
          if (!props.loop && !props.trapped)
            return;
          if (focusLayer.paused)
            return;
          const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e3;
          const { loop } = props;
          const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
          const currentFocusingEl = document.activeElement;
          if (isTabbing && currentFocusingEl) {
            const container = currentTarget;
            const [first, last] = getEdges(container);
            const isTabbable = first && last;
            if (!isTabbable) {
              if (currentFocusingEl === container) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e3.preventDefault();
                }
              }
            } else {
              if (!shiftKey && currentFocusingEl === last) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e3.preventDefault();
                  if (loop)
                    tryFocus(first, true);
                }
              } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
                const focusoutPreventedEvent = createFocusOutPreventedEvent({
                  focusReason: focusReason2.value
                });
                emit2("focusout-prevented", focusoutPreventedEvent);
                if (!focusoutPreventedEvent.defaultPrevented) {
                  e3.preventDefault();
                  if (loop)
                    tryFocus(last, true);
                }
              }
            }
          }
        };
        provide(FOCUS_TRAP_INJECTION_KEY, {
          focusTrapRef: forwardRef,
          onKeydown
        });
        watch(() => props.focusTrapEl, (focusTrapEl) => {
          if (focusTrapEl) {
            forwardRef.value = focusTrapEl;
          }
        }, { immediate: true });
        watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
          if (forwardRef2) {
            forwardRef2.addEventListener("keydown", onKeydown);
            forwardRef2.addEventListener("focusin", onFocusIn);
            forwardRef2.addEventListener("focusout", onFocusOut);
          }
          if (oldForwardRef) {
            oldForwardRef.removeEventListener("keydown", onKeydown);
            oldForwardRef.removeEventListener("focusin", onFocusIn);
            oldForwardRef.removeEventListener("focusout", onFocusOut);
          }
        });
        const trapOnFocus = (e3) => {
          emit2(ON_TRAP_FOCUS_EVT, e3);
        };
        const releaseOnFocus = (e3) => emit2(ON_RELEASE_FOCUS_EVT, e3);
        const onFocusIn = (e3) => {
          const trapContainer = unref(forwardRef);
          if (!trapContainer)
            return;
          const target = e3.target;
          const relatedTarget = e3.relatedTarget;
          const isFocusedInTrap = target && trapContainer.contains(target);
          if (!props.trapped) {
            const isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);
            if (!isPrevFocusedInTrap) {
              lastFocusBeforeTrapped = relatedTarget;
            }
          }
          if (isFocusedInTrap)
            emit2("focusin", e3);
          if (focusLayer.paused)
            return;
          if (props.trapped) {
            if (isFocusedInTrap) {
              lastFocusAfterTrapped = target;
            } else {
              tryFocus(lastFocusAfterTrapped, true);
            }
          }
        };
        const onFocusOut = (e3) => {
          const trapContainer = unref(forwardRef);
          if (focusLayer.paused || !trapContainer)
            return;
          if (props.trapped) {
            const relatedTarget = e3.relatedTarget;
            if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
              setTimeout(() => {
                if (!focusLayer.paused && props.trapped) {
                  const focusoutPreventedEvent = createFocusOutPreventedEvent({
                    focusReason: focusReason2.value
                  });
                  emit2("focusout-prevented", focusoutPreventedEvent);
                  if (!focusoutPreventedEvent.defaultPrevented) {
                    tryFocus(lastFocusAfterTrapped, true);
                  }
                }
              }, 0);
            }
          } else {
            const target = e3.target;
            const isFocusedInTrap = target && trapContainer.contains(target);
            if (!isFocusedInTrap)
              emit2("focusout", e3);
          }
        };
        function startTrap() {
          return __async(this, null, function* () {
            yield nextTick();
            const trapContainer = unref(forwardRef);
            if (trapContainer) {
              focusableStack.push(focusLayer);
              const prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;
              lastFocusBeforeTrapped = prevFocusedElement;
              const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
              if (!isPrevFocusContained) {
                const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
                trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
                trapContainer.dispatchEvent(focusEvent);
                if (!focusEvent.defaultPrevented) {
                  nextTick(() => {
                    let focusStartEl = props.focusStartEl;
                    if (!isString$2(focusStartEl)) {
                      tryFocus(focusStartEl);
                      if (document.activeElement !== focusStartEl) {
                        focusStartEl = "first";
                      }
                    }
                    if (focusStartEl === "first") {
                      focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
                    }
                    if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                      tryFocus(trapContainer);
                    }
                  });
                }
              }
            }
          });
        }
        function stopTrap() {
          const trapContainer = unref(forwardRef);
          if (trapContainer) {
            trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
            const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, __spreadProps(__spreadValues({}, FOCUS_AFTER_TRAPPED_OPTS), {
              detail: {
                focusReason: focusReason2.value
              }
            }));
            trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
            trapContainer.dispatchEvent(releasedEvent);
            if (!releasedEvent.defaultPrevented && (focusReason2.value == "keyboard" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {
              tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);
            }
            trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
            focusableStack.remove(focusLayer);
          }
        }
        onMounted(() => {
          if (props.trapped) {
            startTrap();
          }
          watch(() => props.trapped, (trapped) => {
            if (trapped) {
              startTrap();
            } else {
              stopTrap();
            }
          });
        });
        onBeforeUnmount(() => {
          if (props.trapped) {
            stopTrap();
          }
        });
        return {
          onKeydown
        };
      }
    });
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
    }
    var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
    const POSITIONING_STRATEGIES = ["fixed", "absolute"];
    const popperCoreConfigProps = buildProps({
      boundariesPadding: {
        type: Number,
        default: 0
      },
      fallbackPlacements: {
        type: definePropType(Array),
        default: void 0
      },
      gpuAcceleration: {
        type: Boolean,
        default: true
      },
      offset: {
        type: Number,
        default: 12
      },
      placement: {
        type: String,
        values: Ee,
        default: "bottom"
      },
      popperOptions: {
        type: definePropType(Object),
        default: () => ({})
      },
      strategy: {
        type: String,
        values: POSITIONING_STRATEGIES,
        default: "absolute"
      }
    });
    const popperContentProps = buildProps(__spreadProps(__spreadValues({}, popperCoreConfigProps), {
      id: String,
      style: {
        type: definePropType([String, Array, Object])
      },
      className: {
        type: definePropType([String, Array, Object])
      },
      effect: {
        type: String,
        default: "dark"
      },
      visible: Boolean,
      enterable: {
        type: Boolean,
        default: true
      },
      pure: Boolean,
      focusOnShow: {
        type: Boolean,
        default: false
      },
      trapping: {
        type: Boolean,
        default: false
      },
      popperClass: {
        type: definePropType([String, Array, Object])
      },
      popperStyle: {
        type: definePropType([String, Array, Object])
      },
      referenceEl: {
        type: definePropType(Object)
      },
      triggerTargetEl: {
        type: definePropType(Object)
      },
      stopPopperMouseEvent: {
        type: Boolean,
        default: true
      },
      ariaLabel: {
        type: String,
        default: void 0
      },
      virtualTriggering: Boolean,
      zIndex: Number
    }));
    const popperContentEmits = {
      mouseenter: (evt) => evt instanceof MouseEvent,
      mouseleave: (evt) => evt instanceof MouseEvent,
      focus: () => true,
      blur: () => true,
      close: () => true
    };
    const buildPopperOptions = (props, modifiers = []) => {
      const { placement, strategy, popperOptions } = props;
      const options = __spreadProps(__spreadValues({
        placement,
        strategy
      }, popperOptions), {
        modifiers: [...genModifiers(props), ...modifiers]
      });
      deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
      return options;
    };
    const unwrapMeasurableEl = ($el) => {
      if (!isClient)
        return;
      return unrefElement($el);
    };
    function genModifiers(options) {
      const { offset, gpuAcceleration, fallbackPlacements } = options;
      return [
        {
          name: "offset",
          options: {
            offset: [0, offset != null ? offset : 12]
          }
        },
        {
          name: "preventOverflow",
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        },
        {
          name: "flip",
          options: {
            padding: 5,
            fallbackPlacements
          }
        },
        {
          name: "computeStyles",
          options: {
            gpuAcceleration
          }
        }
      ];
    }
    function deriveExtraModifiers(options, modifiers) {
      if (modifiers) {
        options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
      }
    }
    const DEFAULT_ARROW_OFFSET = 0;
    const usePopperContent = (props) => {
      const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = inject(POPPER_INJECTION_KEY, void 0);
      const arrowRef = ref();
      const arrowOffset = ref();
      const eventListenerModifier = computed(() => {
        return {
          name: "eventListeners",
          enabled: !!props.visible
        };
      });
      const arrowModifier = computed(() => {
        var _a2;
        const arrowEl = unref(arrowRef);
        const offset = (_a2 = unref(arrowOffset)) != null ? _a2 : DEFAULT_ARROW_OFFSET;
        return {
          name: "arrow",
          enabled: !isUndefined$2(arrowEl),
          options: {
            element: arrowEl,
            padding: offset
          }
        };
      });
      const options = computed(() => {
        return __spreadValues({
          onFirstUpdate: () => {
            update();
          }
        }, buildPopperOptions(props, [
          unref(arrowModifier),
          unref(eventListenerModifier)
        ]));
      });
      const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef2));
      const { attributes, state, styles, update, forceUpdate, instanceRef } = usePopper(computedReference, contentRef, options);
      watch(instanceRef, (instance) => popperInstanceRef.value = instance);
      onMounted(() => {
        watch(() => {
          var _a2;
          return (_a2 = unref(computedReference)) == null ? void 0 : _a2.getBoundingClientRect();
        }, () => {
          update();
        });
      });
      return {
        attributes,
        arrowRef,
        contentRef,
        instanceRef,
        state,
        styles,
        role,
        forceUpdate,
        update
      };
    };
    const usePopperContentDOM = (props, {
      attributes,
      styles,
      role
    }) => {
      const { nextZIndex } = useZIndex();
      const ns = useNamespace("popper");
      const contentAttrs = computed(() => unref(attributes).popper);
      const contentZIndex = ref(props.zIndex || nextZIndex());
      const contentClass = computed(() => [
        ns.b(),
        ns.is("pure", props.pure),
        ns.is(props.effect),
        props.popperClass
      ]);
      const contentStyle = computed(() => {
        return [
          { zIndex: unref(contentZIndex) },
          unref(styles).popper,
          props.popperStyle || {}
        ];
      });
      const ariaModal = computed(() => role.value === "dialog" ? "false" : void 0);
      const arrowStyle = computed(() => unref(styles).arrow || {});
      const updateZIndex = () => {
        contentZIndex.value = props.zIndex || nextZIndex();
      };
      return {
        ariaModal,
        arrowStyle,
        contentAttrs,
        contentClass,
        contentStyle,
        contentZIndex,
        updateZIndex
      };
    };
    const usePopperContentFocusTrap = (props, emit2) => {
      const trapped = ref(false);
      const focusStartRef = ref();
      const onFocusAfterTrapped = () => {
        emit2("focus");
      };
      const onFocusAfterReleased = (event) => {
        var _a2;
        if (((_a2 = event.detail) == null ? void 0 : _a2.focusReason) !== "pointer") {
          focusStartRef.value = "first";
          emit2("blur");
        }
      };
      const onFocusInTrap = (event) => {
        if (props.visible && !trapped.value) {
          if (event.target) {
            focusStartRef.value = event.target;
          }
          trapped.value = true;
        }
      };
      const onFocusoutPrevented = (event) => {
        if (!props.trapping) {
          if (event.detail.focusReason === "pointer") {
            event.preventDefault();
          }
          trapped.value = false;
        }
      };
      const onReleaseRequested = () => {
        trapped.value = false;
        emit2("close");
      };
      return {
        focusStartRef,
        trapped,
        onFocusAfterReleased,
        onFocusAfterTrapped,
        onFocusInTrap,
        onFocusoutPrevented,
        onReleaseRequested
      };
    };
    const __default__$p = defineComponent({
      name: "ElPopperContent"
    });
    const _sfc_main$w = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$p), {
      props: popperContentProps,
      emits: popperContentEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const {
          focusStartRef,
          trapped,
          onFocusAfterReleased,
          onFocusAfterTrapped,
          onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        } = usePopperContentFocusTrap(props, emit2);
        const { attributes, arrowRef, contentRef, styles, instanceRef, role, update } = usePopperContent(props);
        const {
          ariaModal,
          arrowStyle,
          contentAttrs,
          contentClass,
          contentStyle,
          updateZIndex
        } = usePopperContentDOM(props, {
          styles,
          attributes,
          role
        });
        const formItemContext = inject(formItemContextKey, void 0);
        const arrowOffset = ref();
        provide(POPPER_CONTENT_INJECTION_KEY, {
          arrowStyle,
          arrowRef,
          arrowOffset
        });
        if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
          provide(formItemContextKey, __spreadProps(__spreadValues({}, formItemContext), {
            addInputId: NOOP,
            removeInputId: NOOP
          }));
        }
        let triggerTargetAriaStopWatch = void 0;
        const updatePopper = (shouldUpdateZIndex = true) => {
          update();
          shouldUpdateZIndex && updateZIndex();
        };
        const togglePopperAlive = () => {
          updatePopper(false);
          if (props.visible && props.focusOnShow) {
            trapped.value = true;
          } else if (props.visible === false) {
            trapped.value = false;
          }
        };
        onMounted(() => {
          watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
            triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
            triggerTargetAriaStopWatch = void 0;
            const el = unref(triggerTargetEl || contentRef.value);
            const prevEl = unref(prevTriggerTargetEl || contentRef.value);
            if (isElement(el)) {
              triggerTargetAriaStopWatch = watch([role, () => props.ariaLabel, ariaModal, () => props.id], (watches) => {
                ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
                  isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
                });
              }, { immediate: true });
            }
            if (prevEl !== el && isElement(prevEl)) {
              ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
                prevEl.removeAttribute(key);
              });
            }
          }, { immediate: true });
          watch(() => props.visible, togglePopperAlive, { immediate: true });
        });
        onBeforeUnmount(() => {
          triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
          triggerTargetAriaStopWatch = void 0;
        });
        expose({
          popperContentRef: contentRef,
          popperInstanceRef: instanceRef,
          updatePopper,
          contentStyle
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", mergeProps({
            ref_key: "contentRef",
            ref: contentRef
          }, unref(contentAttrs), {
            style: unref(contentStyle),
            class: unref(contentClass),
            tabindex: "-1",
            onMouseenter: _cache[0] || (_cache[0] = (e3) => _ctx.$emit("mouseenter", e3)),
            onMouseleave: _cache[1] || (_cache[1] = (e3) => _ctx.$emit("mouseleave", e3))
          }), [
            createVNode(unref(ElFocusTrap), {
              trapped: unref(trapped),
              "trap-on-focus-in": true,
              "focus-trap-el": unref(contentRef),
              "focus-start-el": unref(focusStartRef),
              onFocusAfterTrapped: unref(onFocusAfterTrapped),
              onFocusAfterReleased: unref(onFocusAfterReleased),
              onFocusin: unref(onFocusInTrap),
              onFocusoutPrevented: unref(onFocusoutPrevented),
              onReleaseRequested: unref(onReleaseRequested)
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
          ], 16);
        };
      }
    }));
    var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
    const ElPopper = withInstall(Popper);
    const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
    const useTooltipContentProps = buildProps(__spreadProps(__spreadValues(__spreadValues({}, useDelayedToggleProps), popperContentProps), {
      appendTo: {
        type: definePropType([String, Object])
      },
      content: {
        type: String,
        default: ""
      },
      rawContent: {
        type: Boolean,
        default: false
      },
      persistent: Boolean,
      ariaLabel: String,
      visible: {
        type: definePropType(Boolean),
        default: null
      },
      transition: String,
      teleported: {
        type: Boolean,
        default: true
      },
      disabled: Boolean
    }));
    const useTooltipTriggerProps = buildProps(__spreadProps(__spreadValues({}, popperTriggerProps), {
      disabled: Boolean,
      trigger: {
        type: definePropType([String, Array]),
        default: "hover"
      },
      triggerKeys: {
        type: definePropType(Array),
        default: () => [EVENT_CODE.enter, EVENT_CODE.space]
      }
    }));
    const {
      useModelToggleProps: useTooltipModelToggleProps,
      useModelToggleEmits: useTooltipModelToggleEmits,
      useModelToggle: useTooltipModelToggle
    } = createModelToggleComposable("visible");
    const useTooltipProps = buildProps(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, popperProps), useTooltipModelToggleProps), useTooltipContentProps), useTooltipTriggerProps), popperArrowProps), {
      showArrow: {
        type: Boolean,
        default: true
      }
    }));
    const tooltipEmits = [
      ...useTooltipModelToggleEmits,
      "before-show",
      "before-hide",
      "show",
      "hide",
      "open",
      "close"
    ];
    const isTriggerType = (trigger2, type) => {
      if (isArray$3(trigger2)) {
        return trigger2.includes(type);
      }
      return trigger2 === type;
    };
    const whenTrigger = (trigger2, type, handler) => {
      return (e3) => {
        isTriggerType(unref(trigger2), type) && handler(e3);
      };
    };
    const __default__$o = defineComponent({
      name: "ElTooltipTrigger"
    });
    const _sfc_main$v = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$o), {
      props: useTooltipTriggerProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("tooltip");
        const { controlled, id: id2, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const triggerRef2 = ref(null);
        const stopWhenControlledOrDisabled = () => {
          if (unref(controlled) || props.disabled) {
            return true;
          }
        };
        const trigger2 = toRef(props, "trigger");
        const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
        const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
        const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e3) => {
          if (e3.button === 0) {
            onToggle(e3);
          }
        }));
        const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
        const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
        const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e3) => {
          e3.preventDefault();
          onToggle(e3);
        }));
        const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e3) => {
          const { code } = e3;
          if (props.triggerKeys.includes(code)) {
            e3.preventDefault();
            onToggle(e3);
          }
        });
        expose({
          triggerRef: triggerRef2
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElPopperTrigger), {
            id: unref(id2),
            "virtual-ref": _ctx.virtualRef,
            open: unref(open),
            "virtual-triggering": _ctx.virtualTriggering,
            class: normalizeClass(unref(ns).e("trigger")),
            onBlur: unref(onBlur),
            onClick: unref(onClick),
            onContextmenu: unref(onContextMenu),
            onFocus: unref(onFocus),
            onMouseenter: unref(onMouseenter),
            onMouseleave: unref(onMouseleave),
            onKeydown: unref(onKeydown)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
        };
      }
    }));
    var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
    const __default__$n = defineComponent({
      name: "ElTooltipContent",
      inheritAttrs: false
    });
    const _sfc_main$u = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$n), {
      props: useTooltipContentProps,
      setup(__props, { expose }) {
        const props = __props;
        const { selector: selector2 } = usePopperContainerId();
        const ns = useNamespace("tooltip");
        const contentRef = ref(null);
        const destroyed = ref(false);
        const {
          controlled,
          id: id2,
          open,
          trigger: trigger2,
          onClose,
          onOpen,
          onShow,
          onHide,
          onBeforeShow,
          onBeforeHide
        } = inject(TOOLTIP_INJECTION_KEY, void 0);
        const transitionClass = computed(() => {
          return props.transition || `${ns.namespace.value}-fade-in-linear`;
        });
        const persistentRef = computed(() => {
          return props.persistent;
        });
        onBeforeUnmount(() => {
          destroyed.value = true;
        });
        const shouldRender = computed(() => {
          return unref(persistentRef) ? true : unref(open);
        });
        const shouldShow = computed(() => {
          return props.disabled ? false : unref(open);
        });
        const appendTo = computed(() => {
          return props.appendTo || selector2.value;
        });
        const contentStyle = computed(() => {
          var _a2;
          return (_a2 = props.style) != null ? _a2 : {};
        });
        const ariaHidden = computed(() => !unref(open));
        const onTransitionLeave = () => {
          onHide();
        };
        const stopWhenControlled = () => {
          if (unref(controlled))
            return true;
        };
        const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
          if (props.enterable && unref(trigger2) === "hover") {
            onOpen();
          }
        });
        const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
          if (unref(trigger2) === "hover") {
            onClose();
          }
        });
        const onBeforeEnter = () => {
          var _a2, _b;
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          onBeforeShow == null ? void 0 : onBeforeShow();
        };
        const onBeforeLeave = () => {
          onBeforeHide == null ? void 0 : onBeforeHide();
        };
        const onAfterShow = () => {
          onShow();
          stopHandle = onClickOutside(computed(() => {
            var _a2;
            return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
          }), () => {
            if (unref(controlled))
              return;
            const $trigger = unref(trigger2);
            if ($trigger !== "hover") {
              onClose();
            }
          });
        };
        const onBlur = () => {
          if (!props.virtualTriggering) {
            onClose();
          }
        };
        let stopHandle;
        watch(() => unref(open), (val) => {
          if (!val) {
            stopHandle == null ? void 0 : stopHandle();
          }
        }, {
          flush: "post"
        });
        watch(() => props.content, () => {
          var _a2, _b;
          (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        });
        expose({
          contentRef
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Teleport, {
            disabled: !_ctx.teleported,
            to: unref(appendTo)
          }, [
            createVNode(Transition$1, {
              name: unref(transitionClass),
              onAfterLeave: onTransitionLeave,
              onBeforeEnter,
              onAfterEnter: onAfterShow,
              onBeforeLeave
            }, {
              default: withCtx(() => [
                unref(shouldRender) ? withDirectives((openBlock(), createBlock(unref(ElPopperContent), mergeProps({
                  key: 0,
                  id: unref(id2),
                  ref_key: "contentRef",
                  ref: contentRef
                }, _ctx.$attrs, {
                  "aria-label": _ctx.ariaLabel,
                  "aria-hidden": unref(ariaHidden),
                  "boundaries-padding": _ctx.boundariesPadding,
                  "fallback-placements": _ctx.fallbackPlacements,
                  "gpu-acceleration": _ctx.gpuAcceleration,
                  offset: _ctx.offset,
                  placement: _ctx.placement,
                  "popper-options": _ctx.popperOptions,
                  strategy: _ctx.strategy,
                  effect: _ctx.effect,
                  enterable: _ctx.enterable,
                  pure: _ctx.pure,
                  "popper-class": _ctx.popperClass,
                  "popper-style": [_ctx.popperStyle, unref(contentStyle)],
                  "reference-el": _ctx.referenceEl,
                  "trigger-target-el": _ctx.triggerTargetEl,
                  visible: unref(shouldShow),
                  "z-index": _ctx.zIndex,
                  onMouseenter: unref(onContentEnter),
                  onMouseleave: unref(onContentLeave),
                  onBlur,
                  onClose: unref(onClose)
                }), {
                  default: withCtx(() => [
                    !destroyed.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [
                  [vShow, unref(shouldShow)]
                ]) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 8, ["name"])
          ], 8, ["disabled", "to"]);
        };
      }
    }));
    var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
    const _hoisted_1$e = ["innerHTML"];
    const _hoisted_2$a = { key: 1 };
    const __default__$m = defineComponent({
      name: "ElTooltip"
    });
    const _sfc_main$t = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$m), {
      props: useTooltipProps,
      emits: tooltipEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        usePopperContainer();
        const id2 = useId();
        const popperRef = ref();
        const contentRef = ref();
        const updatePopper = () => {
          var _a2;
          const popperComponent = unref(popperRef);
          if (popperComponent) {
            (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
          }
        };
        const open = ref(false);
        const toggleReason = ref();
        const { show, hide, hasUpdateHandler } = useTooltipModelToggle({
          indicator: open,
          toggleReason
        });
        const { onOpen, onClose } = useDelayedToggle({
          showAfter: toRef(props, "showAfter"),
          hideAfter: toRef(props, "hideAfter"),
          autoClose: toRef(props, "autoClose"),
          open: show,
          close: hide
        });
        const controlled = computed(() => isBoolean$1(props.visible) && !hasUpdateHandler.value);
        provide(TOOLTIP_INJECTION_KEY, {
          controlled,
          id: id2,
          open: readonly(open),
          trigger: toRef(props, "trigger"),
          onOpen: (event) => {
            onOpen(event);
          },
          onClose: (event) => {
            onClose(event);
          },
          onToggle: (event) => {
            if (unref(open)) {
              onClose(event);
            } else {
              onOpen(event);
            }
          },
          onShow: () => {
            emit2("show", toggleReason.value);
          },
          onHide: () => {
            emit2("hide", toggleReason.value);
          },
          onBeforeShow: () => {
            emit2("before-show", toggleReason.value);
          },
          onBeforeHide: () => {
            emit2("before-hide", toggleReason.value);
          },
          updatePopper
        });
        watch(() => props.disabled, (disabled) => {
          if (disabled && open.value) {
            open.value = false;
          }
        });
        const isFocusInsideContent = (event) => {
          var _a2, _b;
          const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
          const activeElement = (event == null ? void 0 : event.relatedTarget) || document.activeElement;
          return popperContent && popperContent.contains(activeElement);
        };
        onDeactivated(() => open.value && hide());
        expose({
          popperRef,
          contentRef,
          isFocusInsideContent,
          updatePopper,
          onOpen,
          onClose,
          hide
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElPopper), {
            ref_key: "popperRef",
            ref: popperRef,
            role: _ctx.role
          }, {
            default: withCtx(() => [
              createVNode(ElTooltipTrigger, {
                disabled: _ctx.disabled,
                trigger: _ctx.trigger,
                "trigger-keys": _ctx.triggerKeys,
                "virtual-ref": _ctx.virtualRef,
                "virtual-triggering": _ctx.virtualTriggering
              }, {
                default: withCtx(() => [
                  _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
              createVNode(ElTooltipContent, {
                ref_key: "contentRef",
                ref: contentRef,
                "aria-label": _ctx.ariaLabel,
                "boundaries-padding": _ctx.boundariesPadding,
                content: _ctx.content,
                disabled: _ctx.disabled,
                effect: _ctx.effect,
                enterable: _ctx.enterable,
                "fallback-placements": _ctx.fallbackPlacements,
                "hide-after": _ctx.hideAfter,
                "gpu-acceleration": _ctx.gpuAcceleration,
                offset: _ctx.offset,
                persistent: _ctx.persistent,
                "popper-class": _ctx.popperClass,
                "popper-style": _ctx.popperStyle,
                placement: _ctx.placement,
                "popper-options": _ctx.popperOptions,
                pure: _ctx.pure,
                "raw-content": _ctx.rawContent,
                "reference-el": _ctx.referenceEl,
                "trigger-target-el": _ctx.triggerTargetEl,
                "show-after": _ctx.showAfter,
                strategy: _ctx.strategy,
                teleported: _ctx.teleported,
                transition: _ctx.transition,
                "virtual-triggering": _ctx.virtualTriggering,
                "z-index": _ctx.zIndex,
                "append-to": _ctx.appendTo
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "content", {}, () => [
                    _ctx.rawContent ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      innerHTML: _ctx.content
                    }, null, 8, _hoisted_1$e)) : (openBlock(), createElementBlock("span", _hoisted_2$a, toDisplayString(_ctx.content), 1))
                  ]),
                  _ctx.showArrow ? (openBlock(), createBlock(unref(ElPopperArrow), {
                    key: 0,
                    "arrow-offset": _ctx.arrowOffset
                  }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
                ]),
                _: 3
              }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
            ]),
            _: 3
          }, 8, ["role"]);
        };
      }
    }));
    var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
    const ElTooltip = withInstall(Tooltip);
    const autocompleteProps = buildProps({
      valueKey: {
        type: String,
        default: "value"
      },
      modelValue: {
        type: [String, Number],
        default: ""
      },
      debounce: {
        type: Number,
        default: 300
      },
      placement: {
        type: definePropType(String),
        values: [
          "top",
          "top-start",
          "top-end",
          "bottom",
          "bottom-start",
          "bottom-end"
        ],
        default: "bottom-start"
      },
      fetchSuggestions: {
        type: definePropType([Function, Array]),
        default: NOOP
      },
      popperClass: {
        type: String,
        default: ""
      },
      triggerOnFocus: {
        type: Boolean,
        default: true
      },
      selectWhenUnmatched: {
        type: Boolean,
        default: false
      },
      hideLoading: {
        type: Boolean,
        default: false
      },
      label: {
        type: String
      },
      teleported: useTooltipContentProps.teleported,
      highlightFirstItem: {
        type: Boolean,
        default: false
      },
      fitInputWidth: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      name: String
    });
    const autocompleteEmits = {
      [UPDATE_MODEL_EVENT]: (value) => isString$2(value),
      [INPUT_EVENT]: (value) => isString$2(value),
      [CHANGE_EVENT]: (value) => isString$2(value),
      focus: (evt) => evt instanceof FocusEvent,
      blur: (evt) => evt instanceof FocusEvent,
      clear: () => true,
      select: (item) => isObject$2(item)
    };
    const _hoisted_1$d = ["aria-expanded", "aria-owns"];
    const _hoisted_2$9 = { key: 0 };
    const _hoisted_3$7 = ["id", "aria-selected", "onClick"];
    const COMPONENT_NAME$3 = "ElAutocomplete";
    const __default__$l = defineComponent({
      name: COMPONENT_NAME$3,
      inheritAttrs: false
    });
    const _sfc_main$s = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$l), {
      props: autocompleteProps,
      emits: autocompleteEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const attrs = useAttrs();
        const rawAttrs = useAttrs$1();
        const disabled = useFormDisabled();
        const ns = useNamespace("autocomplete");
        const inputRef = ref();
        const regionRef = ref();
        const popperRef = ref();
        const listboxRef = ref();
        let readonly2 = false;
        let ignoreFocusEvent = false;
        const suggestions = ref([]);
        const highlightedIndex = ref(-1);
        const dropdownWidth = ref("");
        const activated = ref(false);
        const suggestionDisabled = ref(false);
        const loading = ref(false);
        const listboxId = computed(() => ns.b(String(generateId())));
        const styles = computed(() => rawAttrs.style);
        const suggestionVisible = computed(() => {
          const isValidData = suggestions.value.length > 0;
          return (isValidData || loading.value) && activated.value;
        });
        const suggestionLoading = computed(() => !props.hideLoading && loading.value);
        const refInput = computed(() => {
          if (inputRef.value) {
            return Array.from(inputRef.value.$el.querySelectorAll("input"));
          }
          return [];
        });
        const onSuggestionShow = () => __async(this, null, function* () {
          yield nextTick();
          if (suggestionVisible.value) {
            dropdownWidth.value = `${inputRef.value.$el.offsetWidth}px`;
          }
        });
        const onHide = () => {
          highlightedIndex.value = -1;
        };
        const getData = (queryString) => __async(this, null, function* () {
          if (suggestionDisabled.value)
            return;
          const cb = (suggestionList) => {
            loading.value = false;
            if (suggestionDisabled.value)
              return;
            if (isArray$3(suggestionList)) {
              suggestions.value = suggestionList;
              highlightedIndex.value = props.highlightFirstItem ? 0 : -1;
            } else {
              throwError(COMPONENT_NAME$3, "autocomplete suggestions must be an array");
            }
          };
          loading.value = true;
          if (isArray$3(props.fetchSuggestions)) {
            cb(props.fetchSuggestions);
          } else {
            const result = yield props.fetchSuggestions(queryString, cb);
            if (isArray$3(result))
              cb(result);
          }
        });
        const debouncedGetData = debounce(getData, props.debounce);
        const handleInput = (value) => {
          const valuePresented = !!value;
          emit2(INPUT_EVENT, value);
          emit2(UPDATE_MODEL_EVENT, value);
          suggestionDisabled.value = false;
          activated.value || (activated.value = valuePresented);
          if (!props.triggerOnFocus && !value) {
            suggestionDisabled.value = true;
            suggestions.value = [];
            return;
          }
          debouncedGetData(value);
        };
        const handleMouseDown = (event) => {
          var _a2;
          if (disabled.value)
            return;
          if (((_a2 = event.target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
            activated.value = true;
          }
        };
        const handleChange = (value) => {
          emit2(CHANGE_EVENT, value);
        };
        const handleFocus = (evt) => {
          if (!ignoreFocusEvent) {
            activated.value = true;
            emit2("focus", evt);
            if (props.triggerOnFocus && !readonly2) {
              debouncedGetData(String(props.modelValue));
            }
          } else {
            ignoreFocusEvent = false;
          }
        };
        const handleBlur = (evt) => {
          setTimeout(() => {
            var _a2;
            if ((_a2 = popperRef.value) == null ? void 0 : _a2.isFocusInsideContent()) {
              ignoreFocusEvent = true;
              return;
            }
            activated.value && close();
            emit2("blur", evt);
          });
        };
        const handleClear = () => {
          activated.value = false;
          emit2(UPDATE_MODEL_EVENT, "");
          emit2("clear");
        };
        const handleKeyEnter = () => __async(this, null, function* () {
          if (suggestionVisible.value && highlightedIndex.value >= 0 && highlightedIndex.value < suggestions.value.length) {
            handleSelect(suggestions.value[highlightedIndex.value]);
          } else if (props.selectWhenUnmatched) {
            emit2("select", { value: props.modelValue });
            suggestions.value = [];
            highlightedIndex.value = -1;
          }
        });
        const handleKeyEscape = (evt) => {
          if (suggestionVisible.value) {
            evt.preventDefault();
            evt.stopPropagation();
            close();
          }
        };
        const close = () => {
          activated.value = false;
        };
        const focus = () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.focus();
        };
        const blur = () => {
          var _a2;
          (_a2 = inputRef.value) == null ? void 0 : _a2.blur();
        };
        const handleSelect = (item) => __async(this, null, function* () {
          emit2(INPUT_EVENT, item[props.valueKey]);
          emit2(UPDATE_MODEL_EVENT, item[props.valueKey]);
          emit2("select", item);
          suggestions.value = [];
          highlightedIndex.value = -1;
        });
        const highlight = (index2) => {
          if (!suggestionVisible.value || loading.value)
            return;
          if (index2 < 0) {
            highlightedIndex.value = -1;
            return;
          }
          if (index2 >= suggestions.value.length) {
            index2 = suggestions.value.length - 1;
          }
          const suggestion = regionRef.value.querySelector(`.${ns.be("suggestion", "wrap")}`);
          const suggestionList = suggestion.querySelectorAll(`.${ns.be("suggestion", "list")} li`);
          const highlightItem = suggestionList[index2];
          const scrollTop = suggestion.scrollTop;
          const { offsetTop, scrollHeight } = highlightItem;
          if (offsetTop + scrollHeight > scrollTop + suggestion.clientHeight) {
            suggestion.scrollTop += scrollHeight;
          }
          if (offsetTop < scrollTop) {
            suggestion.scrollTop -= scrollHeight;
          }
          highlightedIndex.value = index2;
          inputRef.value.ref.setAttribute("aria-activedescendant", `${listboxId.value}-item-${highlightedIndex.value}`);
        };
        onClickOutside(listboxRef, () => {
          suggestionVisible.value && close();
        });
        onMounted(() => {
          inputRef.value.ref.setAttribute("role", "textbox");
          inputRef.value.ref.setAttribute("aria-autocomplete", "list");
          inputRef.value.ref.setAttribute("aria-controls", "id");
          inputRef.value.ref.setAttribute("aria-activedescendant", `${listboxId.value}-item-${highlightedIndex.value}`);
          readonly2 = inputRef.value.ref.hasAttribute("readonly");
        });
        expose({
          highlightedIndex,
          activated,
          loading,
          inputRef,
          popperRef,
          suggestions,
          handleSelect,
          handleKeyEnter,
          focus,
          blur,
          close,
          highlight
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(unref(ElTooltip), {
            ref_key: "popperRef",
            ref: popperRef,
            visible: unref(suggestionVisible),
            placement: _ctx.placement,
            "fallback-placements": ["bottom-start", "top-start"],
            "popper-class": [unref(ns).e("popper"), _ctx.popperClass],
            teleported: _ctx.teleported,
            "gpu-acceleration": false,
            pure: "",
            "manual-mode": "",
            effect: "light",
            trigger: "click",
            transition: `${unref(ns).namespace.value}-zoom-in-top`,
            persistent: "",
            role: "listbox",
            onBeforeShow: onSuggestionShow,
            onHide
          }, {
            content: withCtx(() => [
              createBaseVNode("div", {
                ref_key: "regionRef",
                ref: regionRef,
                class: normalizeClass([unref(ns).b("suggestion"), unref(ns).is("loading", unref(suggestionLoading))]),
                style: normalizeStyle({
                  [_ctx.fitInputWidth ? "width" : "minWidth"]: dropdownWidth.value,
                  outline: "none"
                }),
                role: "region"
              }, [
                createVNode(unref(ElScrollbar), {
                  id: unref(listboxId),
                  tag: "ul",
                  "wrap-class": unref(ns).be("suggestion", "wrap"),
                  "view-class": unref(ns).be("suggestion", "list"),
                  role: "listbox"
                }, {
                  default: withCtx(() => [
                    unref(suggestionLoading) ? (openBlock(), createElementBlock("li", _hoisted_2$9, [
                      createVNode(unref(ElIcon), {
                        class: normalizeClass(unref(ns).is("loading"))
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(loading_default))
                        ]),
                        _: 1
                      }, 8, ["class"])
                    ])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(suggestions.value, (item, index2) => {
                      return openBlock(), createElementBlock("li", {
                        id: `${unref(listboxId)}-item-${index2}`,
                        key: index2,
                        class: normalizeClass({ highlighted: highlightedIndex.value === index2 }),
                        role: "option",
                        "aria-selected": highlightedIndex.value === index2,
                        onClick: ($event) => handleSelect(item)
                      }, [
                        renderSlot(_ctx.$slots, "default", { item }, () => [
                          createTextVNode(toDisplayString(item[_ctx.valueKey]), 1)
                        ])
                      ], 10, _hoisted_3$7);
                    }), 128))
                  ]),
                  _: 3
                }, 8, ["id", "wrap-class", "view-class"])
              ], 6)
            ]),
            default: withCtx(() => [
              createBaseVNode("div", {
                ref_key: "listboxRef",
                ref: listboxRef,
                class: normalizeClass([unref(ns).b(), _ctx.$attrs.class]),
                style: normalizeStyle(unref(styles)),
                role: "combobox",
                "aria-haspopup": "listbox",
                "aria-expanded": unref(suggestionVisible),
                "aria-owns": unref(listboxId)
              }, [
                createVNode(unref(ElInput), mergeProps({
                  ref_key: "inputRef",
                  ref: inputRef
                }, unref(attrs), {
                  clearable: _ctx.clearable,
                  disabled: unref(disabled),
                  name: _ctx.name,
                  "model-value": _ctx.modelValue,
                  onInput: handleInput,
                  onChange: handleChange,
                  onFocus: handleFocus,
                  onBlur: handleBlur,
                  onClear: handleClear,
                  onKeydown: [
                    _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => highlight(highlightedIndex.value - 1), ["prevent"]), ["up"])),
                    _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => highlight(highlightedIndex.value + 1), ["prevent"]), ["down"])),
                    withKeys(handleKeyEnter, ["enter"]),
                    withKeys(close, ["tab"]),
                    withKeys(handleKeyEscape, ["esc"])
                  ],
                  onMousedown: handleMouseDown
                }), createSlots({ _: 2 }, [
                  _ctx.$slots.prepend ? {
                    name: "prepend",
                    fn: withCtx(() => [
                      renderSlot(_ctx.$slots, "prepend")
                    ])
                  } : void 0,
                  _ctx.$slots.append ? {
                    name: "append",
                    fn: withCtx(() => [
                      renderSlot(_ctx.$slots, "append")
                    ])
                  } : void 0,
                  _ctx.$slots.prefix ? {
                    name: "prefix",
                    fn: withCtx(() => [
                      renderSlot(_ctx.$slots, "prefix")
                    ])
                  } : void 0,
                  _ctx.$slots.suffix ? {
                    name: "suffix",
                    fn: withCtx(() => [
                      renderSlot(_ctx.$slots, "suffix")
                    ])
                  } : void 0
                ]), 1040, ["clearable", "disabled", "name", "model-value", "onKeydown"])
              ], 14, _hoisted_1$d)
            ]),
            _: 3
          }, 8, ["visible", "placement", "popper-class", "teleported", "transition"]);
        };
      }
    }));
    var Autocomplete = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/autocomplete/src/autocomplete.vue"]]);
    const ElAutocomplete = withInstall(Autocomplete);
    const badgeProps = buildProps({
      value: {
        type: [String, Number],
        default: ""
      },
      max: {
        type: Number,
        default: 99
      },
      isDot: Boolean,
      hidden: Boolean,
      type: {
        type: String,
        values: ["primary", "success", "warning", "info", "danger"],
        default: "danger"
      }
    });
    const _hoisted_1$c = ["textContent"];
    const __default__$k = defineComponent({
      name: "ElBadge"
    });
    const _sfc_main$r = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$k), {
      props: badgeProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("badge");
        const content2 = computed(() => {
          if (props.isDot)
            return "";
          if (isNumber$1(props.value) && isNumber$1(props.max)) {
            return props.max < props.value ? `${props.max}+` : `${props.value}`;
          }
          return `${props.value}`;
        });
        expose({
          content: content2
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(ns).b())
          }, [
            renderSlot(_ctx.$slots, "default"),
            createVNode(Transition$1, {
              name: `${unref(ns).namespace.value}-zoom-in-center`,
              persisted: ""
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("sup", {
                  class: normalizeClass([
                    unref(ns).e("content"),
                    unref(ns).em("content", _ctx.type),
                    unref(ns).is("fixed", !!_ctx.$slots.default),
                    unref(ns).is("dot", _ctx.isDot)
                  ]),
                  textContent: toDisplayString(unref(content2))
                }, null, 10, _hoisted_1$c), [
                  [vShow, !_ctx.hidden && (unref(content2) || _ctx.isDot)]
                ])
              ]),
              _: 1
            }, 8, ["name"])
          ], 2);
        };
      }
    }));
    var Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
    const ElBadge = withInstall(Badge);
    const buttonGroupContextKey = Symbol("buttonGroupContextKey");
    const useButton = (props, emit2) => {
      useDeprecated({
        from: "type.text",
        replacement: "link",
        version: "3.0.0",
        scope: "props",
        ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
      }, computed(() => props.type === "text"));
      const buttonGroupContext = inject(buttonGroupContextKey, void 0);
      const globalConfig2 = useGlobalConfig("button");
      const { form } = useFormItem();
      const _size = useFormSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
      const _disabled = useFormDisabled();
      const _ref = ref();
      const slots = useSlots();
      const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
      const autoInsertSpace = computed(() => {
        var _a2, _b, _c;
        return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
      });
      const _props = computed(() => {
        if (props.tag === "button") {
          return {
            ariaDisabled: _disabled.value || props.loading,
            disabled: _disabled.value || props.loading,
            autofocus: props.autofocus,
            type: props.nativeType
          };
        }
        return {};
      });
      const shouldAddSpace = computed(() => {
        var _a2;
        const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
        if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
          const slot = defaultSlot[0];
          if ((slot == null ? void 0 : slot.type) === Text) {
            const text = slot.children;
            return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(text.trim());
          }
        }
        return false;
      });
      const handleClick = (evt) => {
        if (props.nativeType === "reset") {
          form == null ? void 0 : form.resetFields();
        }
        emit2("click", evt);
      };
      return {
        _disabled,
        _size,
        _type,
        _ref,
        _props,
        shouldAddSpace,
        handleClick
      };
    };
    const buttonTypes = [
      "default",
      "primary",
      "success",
      "warning",
      "info",
      "danger",
      "text",
      ""
    ];
    const buttonNativeTypes = ["button", "submit", "reset"];
    const buttonProps = buildProps({
      size: useSizeProp,
      disabled: Boolean,
      type: {
        type: String,
        values: buttonTypes,
        default: ""
      },
      icon: {
        type: iconPropType
      },
      nativeType: {
        type: String,
        values: buttonNativeTypes,
        default: "button"
      },
      loading: Boolean,
      loadingIcon: {
        type: iconPropType,
        default: () => loading_default
      },
      plain: Boolean,
      text: Boolean,
      link: Boolean,
      bg: Boolean,
      autofocus: Boolean,
      round: Boolean,
      circle: Boolean,
      color: String,
      dark: Boolean,
      autoInsertSpace: {
        type: Boolean,
        default: void 0
      },
      tag: {
        type: definePropType([String, Object]),
        default: "button"
      }
    });
    const buttonEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    function bound01(n, max) {
      if (isOnePointZero(n)) {
        n = "100%";
      }
      var isPercent = isPercentage(n);
      n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
      if (isPercent) {
        n = parseInt(String(n * max), 10) / 100;
      }
      if (Math.abs(n - max) < 1e-6) {
        return 1;
      }
      if (max === 360) {
        n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
      } else {
        n = n % max / parseFloat(String(max));
      }
      return n;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero(n) {
      return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
    }
    function isPercentage(n) {
      return typeof n === "string" && n.indexOf("%") !== -1;
    }
    function boundAlpha(a2) {
      a2 = parseFloat(a2);
      if (isNaN(a2) || a2 < 0 || a2 > 1) {
        a2 = 1;
      }
      return a2;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        return "".concat(Number(n) * 100, "%");
      }
      return n;
    }
    function pad2(c2) {
      return c2.length === 1 ? "0" + c2 : String(c2);
    }
    function rgbToRgb(r, g, b) {
      return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
      };
    }
    function rgbToHsl(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h2 = 0;
      var s = 0;
      var l = (max + min) / 2;
      if (max === min) {
        s = 0;
        h2 = 0;
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h2 = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h2 = (b - r) / d + 2;
            break;
          case b:
            h2 = (r - g) / d + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, l };
    }
    function hue2rgb$1(p2, q2, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p2 + (q2 - p2) * (6 * t);
      }
      if (t < 1 / 2) {
        return q2;
      }
      if (t < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s, l) {
      var r;
      var g;
      var b;
      h2 = bound01(h2, 360);
      s = bound01(s, 100);
      l = bound01(l, 100);
      if (s === 0) {
        g = l;
        b = l;
        r = l;
      } else {
        var q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p2 = 2 * l - q2;
        r = hue2rgb$1(p2, q2, h2 + 1 / 3);
        g = hue2rgb$1(p2, q2, h2);
        b = hue2rgb$1(p2, q2, h2 - 1 / 3);
      }
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHsv(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var h2 = 0;
      var v = max;
      var d = max - min;
      var s = max === 0 ? 0 : d / max;
      if (max === min) {
        h2 = 0;
      } else {
        switch (max) {
          case r:
            h2 = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h2 = (b - r) / d + 2;
            break;
          case b:
            h2 = (r - g) / d + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, v };
    }
    function hsvToRgb(h2, s, v) {
      h2 = bound01(h2, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);
      var i2 = Math.floor(h2);
      var f2 = h2 - i2;
      var p2 = v * (1 - s);
      var q2 = v * (1 - f2 * s);
      var t = v * (1 - (1 - f2) * s);
      var mod = i2 % 6;
      var r = [v, q2, p2, p2, t, v][mod];
      var g = [t, v, v, q2, p2, p2][mod];
      var b = [p2, p2, t, v, v, q2][mod];
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHex(r, g, b, allow3Char) {
      var hex2 = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16))
      ];
      if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
        return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
      }
      return hex2.join("");
    }
    function rgbaToHex(r, g, b, a2, allow4Char) {
      var hex2 = [
        pad2(Math.round(r).toString(16)),
        pad2(Math.round(g).toString(16)),
        pad2(Math.round(b).toString(16)),
        pad2(convertDecimalToHex(a2))
      ];
      if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
        return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
      }
      return hex2.join("");
    }
    function convertDecimalToHex(d) {
      return Math.round(parseFloat(d) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color2) {
      return {
        r: color2 >> 16,
        g: (color2 & 65280) >> 8,
        b: color2 & 255
      };
    }
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB(color2) {
      var rgb2 = { r: 0, g: 0, b: 0 };
      var a2 = 1;
      var s = null;
      var v = null;
      var l = null;
      var ok = false;
      var format2 = false;
      if (typeof color2 === "string") {
        color2 = stringInputToObject(color2);
      }
      if (typeof color2 === "object") {
        if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
          rgb2 = rgbToRgb(color2.r, color2.g, color2.b);
          ok = true;
          format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
          s = convertToPercentage(color2.s);
          v = convertToPercentage(color2.v);
          rgb2 = hsvToRgb(color2.h, s, v);
          ok = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
          s = convertToPercentage(color2.s);
          l = convertToPercentage(color2.l);
          rgb2 = hslToRgb(color2.h, s, l);
          ok = true;
          format2 = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color2, "a")) {
          a2 = color2.a;
        }
      }
      a2 = boundAlpha(a2);
      return {
        ok,
        format: color2.format || format2,
        r: Math.min(255, Math.max(rgb2.r, 0)),
        g: Math.min(255, Math.max(rgb2.g, 0)),
        b: Math.min(255, Math.max(rgb2.b, 0)),
        a: a2
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color2) {
      color2 = color2.trim().toLowerCase();
      if (color2.length === 0) {
        return false;
      }
      var named2 = false;
      if (names[color2]) {
        color2 = names[color2];
        named2 = true;
      } else if (color2 === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match = matchers.rgb.exec(color2);
      if (match) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      match = matchers.rgba.exec(color2);
      if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      match = matchers.hsl.exec(color2);
      if (match) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      match = matchers.hsla.exec(color2);
      if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      match = matchers.hsv.exec(color2);
      if (match) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      match = matchers.hsva.exec(color2);
      if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      match = matchers.hex8.exec(color2);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named2 ? "name" : "hex8"
        };
      }
      match = matchers.hex6.exec(color2);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named2 ? "name" : "hex"
        };
      }
      match = matchers.hex4.exec(color2);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          a: convertHexToDecimal(match[4] + match[4]),
          format: named2 ? "name" : "hex8"
        };
      }
      match = matchers.hex3.exec(color2);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          format: named2 ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color2) {
      return Boolean(matchers.CSS_UNIT.exec(String(color2)));
    }
    var TinyColor = (
      /** @class */
      function() {
        function TinyColor2(color2, opts) {
          if (color2 === void 0) {
            color2 = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a2;
          if (color2 instanceof TinyColor2) {
            return color2;
          }
          if (typeof color2 === "number") {
            color2 = numberInputToObject(color2);
          }
          this.originalInput = color2;
          var rgb2 = inputToRGB(color2);
          this.originalInput = color2;
          this.r = rgb2.r;
          this.g = rgb2.g;
          this.b = rgb2.b;
          this.a = rgb2.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb2.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb2.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb2 = this.toRgb();
          return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb2 = this.toRgb();
          var R2;
          var G2;
          var B3;
          var RsRGB = rgb2.r / 255;
          var GsRGB = rgb2.g / 255;
          var BsRGB = rgb2.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B3 = BsRGB / 12.92;
          } else {
            B3 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B3;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s = this.toHsl().s;
          return s === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          var h2 = Math.round(hsv.h * 360);
          var s = Math.round(hsv.s * 100);
          var v = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl2 = rgbToHsl(this.r, this.g, this.b);
          return { h: hsl2.h * 360, s: hsl2.s, l: hsl2.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl2 = rgbToHsl(this.r, this.g, this.b);
          var h2 = Math.round(hsl2.h * 360);
          var s = Math.round(hsl2.s * 100);
          var l = Math.round(hsl2.l * 100);
          return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toHexShortString = function(allowShortChar) {
          if (allowShortChar === void 0) {
            allowShortChar = false;
          }
          return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r = Math.round(this.r);
          var g = Math.round(this.g);
          var b = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x2) {
            return "".concat(Math.round(bound01(x2, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x2) {
            return Math.round(bound01(x2, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
          for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
            var _b = _a2[_i], key = _b[0], value = _b[1];
            if (hex2 === value) {
              return key;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format2) {
          var formatSet = Boolean(format2);
          format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl2 = this.toHsl();
          hsl2.l += amount / 100;
          hsl2.l = clamp01(hsl2.l);
          return new TinyColor2(hsl2);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb2 = this.toRgb();
          rgb2.r = Math.max(0, Math.min(255, rgb2.r - Math.round(255 * -(amount / 100))));
          rgb2.g = Math.max(0, Math.min(255, rgb2.g - Math.round(255 * -(amount / 100))));
          rgb2.b = Math.max(0, Math.min(255, rgb2.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb2);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl2 = this.toHsl();
          hsl2.l -= amount / 100;
          hsl2.l = clamp01(hsl2.l);
          return new TinyColor2(hsl2);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl2 = this.toHsl();
          hsl2.s -= amount / 100;
          hsl2.s = clamp01(hsl2.s);
          return new TinyColor2(hsl2);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl2 = this.toHsl();
          hsl2.s += amount / 100;
          hsl2.s = clamp01(hsl2.s);
          return new TinyColor2(hsl2);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl2 = this.toHsl();
          var hue2 = (hsl2.h + amount) % 360;
          hsl2.h = hue2 < 0 ? 360 + hue2 : hue2;
          return new TinyColor2(hsl2);
        };
        TinyColor2.prototype.mix = function(color2, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color2).toRgb();
          var p2 = amount / 100;
          var rgba2 = {
            r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
            g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
            b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
            a: (rgb2.a - rgb1.a) * p2 + rgb1.a
          };
          return new TinyColor2(rgba2);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl2 = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl2.h = (hsl2.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl2.h = (hsl2.h + part) % 360;
            ret.push(new TinyColor2(hsl2));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl2 = this.toHsl();
          hsl2.h = (hsl2.h + 180) % 360;
          return new TinyColor2(hsl2);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h2 = hsv.h;
          var s = hsv.s;
          var v = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h: h2, s, v }));
            v = (v + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl2 = this.toHsl();
          var h2 = hsl2.h;
          return [
            this,
            new TinyColor2({ h: (h2 + 72) % 360, s: hsl2.s, l: hsl2.l }),
            new TinyColor2({ h: (h2 + 216) % 360, s: hsl2.s, l: hsl2.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg = this.toRgb();
          var bg = new TinyColor2(background).toRgb();
          var alpha = fg.a + bg.a * (1 - fg.a);
          return new TinyColor2({
            r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
            g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
            b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
            a: alpha
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n) {
          var hsl2 = this.toHsl();
          var h2 = hsl2.h;
          var result = [this];
          var increment = 360 / n;
          for (var i2 = 1; i2 < n; i2++) {
            result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl2.s, l: hsl2.l }));
          }
          return result;
        };
        TinyColor2.prototype.equals = function(color2) {
          return this.toRgbString() === new TinyColor2(color2).toRgbString();
        };
        return TinyColor2;
      }()
    );
    function darken(color2, amount = 20) {
      return color2.mix("#141414", amount).toString();
    }
    function useButtonCustomStyle(props) {
      const _disabled = useFormDisabled();
      const ns = useNamespace("button");
      return computed(() => {
        let styles = {};
        const buttonColor = props.color;
        if (buttonColor) {
          const color2 = new TinyColor(buttonColor);
          const activeBgColor = props.dark ? color2.tint(20).toString() : darken(color2, 20);
          if (props.plain) {
            styles = ns.cssVarBlock({
              "bg-color": props.dark ? darken(color2, 90) : color2.tint(90).toString(),
              "text-color": buttonColor,
              "border-color": props.dark ? darken(color2, 50) : color2.tint(50).toString(),
              "hover-text-color": `var(${ns.cssVarName("color-white")})`,
              "hover-bg-color": buttonColor,
              "hover-border-color": buttonColor,
              "active-bg-color": activeBgColor,
              "active-text-color": `var(${ns.cssVarName("color-white")})`,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              styles[ns.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color2, 90) : color2.tint(90).toString();
              styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color2, 50) : color2.tint(50).toString();
              styles[ns.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color2, 80) : color2.tint(80).toString();
            }
          } else {
            const hoverBgColor = props.dark ? darken(color2, 30) : color2.tint(30).toString();
            const textColor = color2.isDark() ? `var(${ns.cssVarName("color-white")})` : `var(${ns.cssVarName("color-black")})`;
            styles = ns.cssVarBlock({
              "bg-color": buttonColor,
              "text-color": textColor,
              "border-color": buttonColor,
              "hover-bg-color": hoverBgColor,
              "hover-text-color": textColor,
              "hover-border-color": hoverBgColor,
              "active-bg-color": activeBgColor,
              "active-border-color": activeBgColor
            });
            if (_disabled.value) {
              const disabledButtonColor = props.dark ? darken(color2, 50) : color2.tint(50).toString();
              styles[ns.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
              styles[ns.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns.cssVarName("color-white")})`;
              styles[ns.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
            }
          }
        }
        return styles;
      });
    }
    const __default__$j = defineComponent({
      name: "ElButton"
    });
    const _sfc_main$q = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$j), {
      props: buttonProps,
      emits: buttonEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const buttonStyle = useButtonCustomStyle(props);
        const ns = useNamespace("button");
        const { _ref, _size, _type, _disabled, _props, shouldAddSpace, handleClick } = useButton(props, emit2);
        expose({
          ref: _ref,
          size: _size,
          type: _type,
          disabled: _disabled,
          shouldAddSpace
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps({
            ref_key: "_ref",
            ref: _ref
          }, unref(_props), {
            class: [
              unref(ns).b(),
              unref(ns).m(unref(_type)),
              unref(ns).m(unref(_size)),
              unref(ns).is("disabled", unref(_disabled)),
              unref(ns).is("loading", _ctx.loading),
              unref(ns).is("plain", _ctx.plain),
              unref(ns).is("round", _ctx.round),
              unref(ns).is("circle", _ctx.circle),
              unref(ns).is("text", _ctx.text),
              unref(ns).is("link", _ctx.link),
              unref(ns).is("has-bg", _ctx.bg)
            ],
            style: unref(buttonStyle),
            onClick: unref(handleClick)
          }), {
            default: withCtx(() => [
              _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass(unref(ns).is("loading"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                default: withCtx(() => [
                  _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
                ]),
                _: 3
              })) : createCommentVNode("v-if", true),
              _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                key: 2,
                class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
              }, [
                renderSlot(_ctx.$slots, "default")
              ], 2)) : createCommentVNode("v-if", true)
            ]),
            _: 3
          }, 16, ["class", "style", "onClick"]);
        };
      }
    }));
    var Button = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
    const buttonGroupProps = {
      size: buttonProps.size,
      type: buttonProps.type
    };
    const __default__$i = defineComponent({
      name: "ElButtonGroup"
    });
    const _sfc_main$p = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$i), {
      props: buttonGroupProps,
      setup(__props) {
        const props = __props;
        provide(buttonGroupContextKey, reactive({
          size: toRef(props, "size"),
          type: toRef(props, "type")
        }));
        const ns = useNamespace("button");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(`${unref(ns).b("group")}`)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    }));
    var ButtonGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
    const ElButton = withInstall(Button, {
      ButtonGroup
    });
    withNoopInstall(ButtonGroup);
    const nodeList = /* @__PURE__ */ new Map();
    let startClick;
    if (isClient) {
      document.addEventListener("mousedown", (e3) => startClick = e3);
      document.addEventListener("mouseup", (e3) => {
        for (const handlers of nodeList.values()) {
          for (const { documentHandler } of handlers) {
            documentHandler(e3, startClick);
          }
        }
      });
    }
    function createDocumentHandler(el, binding) {
      let excludes = [];
      if (Array.isArray(binding.arg)) {
        excludes = binding.arg;
      } else if (isElement(binding.arg)) {
        excludes.push(binding.arg);
      }
      return function(mouseup, mousedown) {
        const popperRef = binding.instance.popperRef;
        const mouseUpTarget = mouseup.target;
        const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
        const isBound = !binding || !binding.instance;
        const isTargetExists = !mouseUpTarget || !mouseDownTarget;
        const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
        const isSelf = el === mouseUpTarget;
        const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
        const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
        if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
          return;
        }
        binding.value(mouseup, mousedown);
      };
    }
    const ClickOutside = {
      beforeMount(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        nodeList.get(el).push({
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        });
      },
      updated(el, binding) {
        if (!nodeList.has(el)) {
          nodeList.set(el, []);
        }
        const handlers = nodeList.get(el);
        const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
        const newHandler = {
          documentHandler: createDocumentHandler(el, binding),
          bindingFn: binding.value
        };
        if (oldHandlerIndex >= 0) {
          handlers.splice(oldHandlerIndex, 1, newHandler);
        } else {
          handlers.push(newHandler);
        }
      },
      unmounted(el) {
        nodeList.delete(el);
      }
    };
    const tagProps = buildProps({
      type: {
        type: String,
        values: ["success", "info", "warning", "danger", ""],
        default: ""
      },
      closable: Boolean,
      disableTransitions: Boolean,
      hit: Boolean,
      color: {
        type: String,
        default: ""
      },
      size: {
        type: String,
        values: componentSizes,
        default: ""
      },
      effect: {
        type: String,
        values: ["dark", "light", "plain"],
        default: "light"
      },
      round: Boolean
    });
    const tagEmits = {
      close: (evt) => evt instanceof MouseEvent,
      click: (evt) => evt instanceof MouseEvent
    };
    const __default__$h = defineComponent({
      name: "ElTag"
    });
    const _sfc_main$o = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$h), {
      props: tagProps,
      emits: tagEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const tagSize = useFormSize();
        const ns = useNamespace("tag");
        const containerKls = computed(() => {
          const { type, hit, effect, closable, round } = props;
          return [
            ns.b(),
            ns.is("closable", closable),
            ns.m(type),
            ns.m(tagSize.value),
            ns.m(effect),
            ns.is("hit", hit),
            ns.is("round", round)
          ];
        });
        const handleClose = (event) => {
          emit2("close", event);
        };
        const handleClick = (event) => {
          emit2("click", event);
        };
        return (_ctx, _cache) => {
          return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(unref(containerKls)),
            style: normalizeStyle({ backgroundColor: _ctx.color }),
            onClick: handleClick
          }, [
            createBaseVNode("span", {
              class: normalizeClass(unref(ns).e("content"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2),
            _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass(unref(ns).e("close")),
              onClick: withModifiers(handleClose, ["stop"])
            }, {
              default: withCtx(() => [
                createVNode(unref(close_default))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
          ], 6)) : (openBlock(), createBlock(Transition$1, {
            key: 1,
            name: `${unref(ns).namespace.value}-zoom-in-center`,
            appear: ""
          }, {
            default: withCtx(() => [
              createBaseVNode("span", {
                class: normalizeClass(unref(containerKls)),
                style: normalizeStyle({ backgroundColor: _ctx.color }),
                onClick: handleClick
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(ns).e("content"))
                }, [
                  renderSlot(_ctx.$slots, "default")
                ], 2),
                _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns).e("close")),
                  onClick: withModifiers(handleClose, ["stop"])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(close_default))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
              ], 6)
            ]),
            _: 3
          }, 8, ["name"]));
        };
      }
    }));
    var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
    const ElTag = withInstall(Tag);
    const rowContextKey = Symbol("rowContextKey");
    const RowJustify = [
      "start",
      "center",
      "end",
      "space-around",
      "space-between",
      "space-evenly"
    ];
    const RowAlign = ["top", "middle", "bottom"];
    const rowProps = buildProps({
      tag: {
        type: String,
        default: "div"
      },
      gutter: {
        type: Number,
        default: 0
      },
      justify: {
        type: String,
        values: RowJustify,
        default: "start"
      },
      align: {
        type: String,
        values: RowAlign
      }
    });
    const __default__$g = defineComponent({
      name: "ElRow"
    });
    const _sfc_main$n = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$g), {
      props: rowProps,
      setup(__props) {
        const props = __props;
        const ns = useNamespace("row");
        const gutter = computed(() => props.gutter);
        provide(rowContextKey, {
          gutter
        });
        const style = computed(() => {
          const styles = {};
          if (!props.gutter) {
            return styles;
          }
          styles.marginRight = styles.marginLeft = `-${props.gutter / 2}px`;
          return styles;
        });
        const rowKls = computed(() => [
          ns.b(),
          ns.is(`justify-${props.justify}`, props.justify !== "start"),
          ns.is(`align-${props.align}`, !!props.align)
        ]);
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            class: normalizeClass(unref(rowKls)),
            style: normalizeStyle(unref(style))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]);
        };
      }
    }));
    var Row = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/row/src/row.vue"]]);
    const ElRow = withInstall(Row);
    const colProps = buildProps({
      tag: {
        type: String,
        default: "div"
      },
      span: {
        type: Number,
        default: 24
      },
      offset: {
        type: Number,
        default: 0
      },
      pull: {
        type: Number,
        default: 0
      },
      push: {
        type: Number,
        default: 0
      },
      xs: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      sm: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      md: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      lg: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      },
      xl: {
        type: definePropType([Number, Object]),
        default: () => mutable({})
      }
    });
    const __default__$f = defineComponent({
      name: "ElCol"
    });
    const _sfc_main$m = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$f), {
      props: colProps,
      setup(__props) {
        const props = __props;
        const { gutter } = inject(rowContextKey, { gutter: computed(() => 0) });
        const ns = useNamespace("col");
        const style = computed(() => {
          const styles = {};
          if (gutter.value) {
            styles.paddingLeft = styles.paddingRight = `${gutter.value / 2}px`;
          }
          return styles;
        });
        const colKls = computed(() => {
          const classes = [];
          const pos = ["span", "offset", "pull", "push"];
          pos.forEach((prop) => {
            const size2 = props[prop];
            if (isNumber$1(size2)) {
              if (prop === "span")
                classes.push(ns.b(`${props[prop]}`));
              else if (size2 > 0)
                classes.push(ns.b(`${prop}-${props[prop]}`));
            }
          });
          const sizes = ["xs", "sm", "md", "lg", "xl"];
          sizes.forEach((size2) => {
            if (isNumber$1(props[size2])) {
              classes.push(ns.b(`${size2}-${props[size2]}`));
            } else if (isObject$2(props[size2])) {
              Object.entries(props[size2]).forEach(([prop, sizeProp]) => {
                classes.push(prop !== "span" ? ns.b(`${size2}-${prop}-${sizeProp}`) : ns.b(`${size2}-${sizeProp}`));
              });
            }
          });
          if (gutter.value) {
            classes.push(ns.is("guttered"));
          }
          return [ns.b(), classes];
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            class: normalizeClass(unref(colKls)),
            style: normalizeStyle(unref(style))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]);
        };
      }
    }));
    var Col = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/col/src/col.vue"]]);
    const ElCol = withInstall(Col);
    const __default__$e = defineComponent({
      name: "ElContainer"
    });
    const _sfc_main$l = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$e), {
      props: {
        direction: {
          type: String
        }
      },
      setup(__props) {
        const props = __props;
        const slots = useSlots();
        const ns = useNamespace("container");
        const isVertical = computed(() => {
          if (props.direction === "vertical") {
            return true;
          } else if (props.direction === "horizontal") {
            return false;
          }
          if (slots && slots.default) {
            const vNodes = slots.default();
            return vNodes.some((vNode) => {
              const tag = vNode.type.name;
              return tag === "ElHeader" || tag === "ElFooter";
            });
          } else {
            return false;
          }
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("section", {
            class: normalizeClass([unref(ns).b(), unref(ns).is("vertical", unref(isVertical))])
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    }));
    var Container = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
    const __default__$d = defineComponent({
      name: "ElAside"
    });
    const _sfc_main$k = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$d), {
      props: {
        width: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns = useNamespace("aside");
        const style = computed(() => props.width ? ns.cssVarBlock({ width: props.width }) : {});
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("aside", {
            class: normalizeClass(unref(ns).b()),
            style: normalizeStyle(unref(style))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    }));
    var Aside = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
    const __default__$c = defineComponent({
      name: "ElFooter"
    });
    const _sfc_main$j = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$c), {
      props: {
        height: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns = useNamespace("footer");
        const style = computed(() => props.height ? ns.cssVarBlock({ height: props.height }) : {});
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("footer", {
            class: normalizeClass(unref(ns).b()),
            style: normalizeStyle(unref(style))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    }));
    var Footer = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
    const __default__$b = defineComponent({
      name: "ElHeader"
    });
    const _sfc_main$i = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$b), {
      props: {
        height: {
          type: String,
          default: null
        }
      },
      setup(__props) {
        const props = __props;
        const ns = useNamespace("header");
        const style = computed(() => {
          return props.height ? ns.cssVarBlock({
            height: props.height
          }) : {};
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("header", {
            class: normalizeClass(unref(ns).b()),
            style: normalizeStyle(unref(style))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6);
        };
      }
    }));
    var Header = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
    const __default__$a = defineComponent({
      name: "ElMain"
    });
    const _sfc_main$h = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$a), {
      setup(__props) {
        const ns = useNamespace("main");
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("main", {
            class: normalizeClass(unref(ns).b())
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2);
        };
      }
    }));
    var Main = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
    const ElContainer = withInstall(Container, {
      Aside,
      Footer,
      Header,
      Main
    });
    const ElAside = withNoopInstall(Aside);
    withNoopInstall(Footer);
    const ElHeader = withNoopInstall(Header);
    const ElMain = withNoopInstall(Main);
    const descriptionsKey = Symbol("elDescriptions");
    var ElDescriptionsCell = defineComponent({
      name: "ElDescriptionsCell",
      props: {
        cell: {
          type: Object
        },
        tag: {
          type: String
        },
        type: {
          type: String
        }
      },
      setup() {
        const descriptions = inject(descriptionsKey, {});
        return {
          descriptions
        };
      },
      render() {
        var _a2, _b, _c, _d, _e, _f;
        const item = getNormalizedProps(this.cell);
        const { border, direction: direction2 } = this.descriptions;
        const isVertical = direction2 === "vertical";
        const label = ((_c = (_b = (_a2 = this.cell) == null ? void 0 : _a2.children) == null ? void 0 : _b.label) == null ? void 0 : _c.call(_b)) || item.label;
        const content2 = (_f = (_e = (_d = this.cell) == null ? void 0 : _d.children) == null ? void 0 : _e.default) == null ? void 0 : _f.call(_e);
        const span = item.span;
        const align = item.align ? `is-${item.align}` : "";
        const labelAlign = item.labelAlign ? `is-${item.labelAlign}` : align;
        const className = item.className;
        const labelClassName = item.labelClassName;
        const style = {
          width: addUnit(item.width),
          minWidth: addUnit(item.minWidth)
        };
        const ns = useNamespace("descriptions");
        switch (this.type) {
          case "label":
            return h(this.tag, {
              style,
              class: [
                ns.e("cell"),
                ns.e("label"),
                ns.is("bordered-label", border),
                ns.is("vertical-label", isVertical),
                labelAlign,
                labelClassName
              ],
              colSpan: isVertical ? span : 1
            }, label);
          case "content":
            return h(this.tag, {
              style,
              class: [
                ns.e("cell"),
                ns.e("content"),
                ns.is("bordered-content", border),
                ns.is("vertical-content", isVertical),
                align,
                className
              ],
              colSpan: isVertical ? span : span * 2 - 1
            }, content2);
          default:
            return h("td", {
              style,
              class: [ns.e("cell"), align],
              colSpan: span
            }, [
              !isNil(label) ? h("span", {
                class: [ns.e("label"), labelClassName]
              }, label) : void 0,
              h("span", {
                class: [ns.e("content"), className]
              }, content2)
            ]);
        }
      }
    });
    const descriptionsRowProps = buildProps({
      row: {
        type: Array,
        default: () => []
      }
    });
    const _hoisted_1$b = { key: 1 };
    const __default__$9 = defineComponent({
      name: "ElDescriptionsRow"
    });
    const _sfc_main$g = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$9), {
      props: descriptionsRowProps,
      setup(__props) {
        const descriptions = inject(descriptionsKey, {});
        return (_ctx, _cache) => {
          return unref(descriptions).direction === "vertical" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, index2) => {
                return openBlock(), createBlock(unref(ElDescriptionsCell), {
                  key: `tr1-${index2}`,
                  cell,
                  tag: "th",
                  type: "label"
                }, null, 8, ["cell"]);
              }), 128))
            ]),
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, index2) => {
                return openBlock(), createBlock(unref(ElDescriptionsCell), {
                  key: `tr2-${index2}`,
                  cell,
                  tag: "td",
                  type: "content"
                }, null, 8, ["cell"]);
              }), 128))
            ])
          ], 64)) : (openBlock(), createElementBlock("tr", _hoisted_1$b, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.row, (cell, index2) => {
              return openBlock(), createElementBlock(Fragment, {
                key: `tr3-${index2}`
              }, [
                unref(descriptions).border ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createVNode(unref(ElDescriptionsCell), {
                    cell,
                    tag: "td",
                    type: "label"
                  }, null, 8, ["cell"]),
                  createVNode(unref(ElDescriptionsCell), {
                    cell,
                    tag: "td",
                    type: "content"
                  }, null, 8, ["cell"])
                ], 64)) : (openBlock(), createBlock(unref(ElDescriptionsCell), {
                  key: 1,
                  cell,
                  tag: "td",
                  type: "both"
                }, null, 8, ["cell"]))
              ], 64);
            }), 128))
          ]));
        };
      }
    }));
    var ElDescriptionsRow = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/descriptions-row.vue"]]);
    const descriptionProps = buildProps({
      border: {
        type: Boolean,
        default: false
      },
      column: {
        type: Number,
        default: 3
      },
      direction: {
        type: String,
        values: ["horizontal", "vertical"],
        default: "horizontal"
      },
      size: useSizeProp,
      title: {
        type: String,
        default: ""
      },
      extra: {
        type: String,
        default: ""
      }
    });
    const __default__$8 = defineComponent({
      name: "ElDescriptions"
    });
    const _sfc_main$f = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$8), {
      props: descriptionProps,
      setup(__props) {
        const props = __props;
        const ns = useNamespace("descriptions");
        const descriptionsSize = useFormSize();
        const slots = useSlots();
        provide(descriptionsKey, props);
        const descriptionKls = computed(() => [ns.b(), ns.m(descriptionsSize.value)]);
        const filledNode = (node, span, count, isLast = false) => {
          if (!node.props) {
            node.props = {};
          }
          if (span > count) {
            node.props.span = count;
          }
          if (isLast) {
            node.props.span = span;
          }
          return node;
        };
        const getRows = () => {
          var _a2;
          const children2 = flattedChildren((_a2 = slots.default) == null ? void 0 : _a2.call(slots)).filter((node) => {
            var _a22;
            return ((_a22 = node == null ? void 0 : node.type) == null ? void 0 : _a22.name) === "ElDescriptionsItem";
          });
          const rows = [];
          let temp = [];
          let count = props.column;
          let totalSpan = 0;
          children2.forEach((node, index2) => {
            var _a22;
            const span = ((_a22 = node.props) == null ? void 0 : _a22.span) || 1;
            if (index2 < children2.length - 1) {
              totalSpan += span > count ? count : span;
            }
            if (index2 === children2.length - 1) {
              const lastSpan = props.column - totalSpan % props.column;
              temp.push(filledNode(node, lastSpan, count, true));
              rows.push(temp);
              return;
            }
            if (span < count) {
              count -= span;
              temp.push(node);
            } else {
              temp.push(filledNode(node, span, count));
              rows.push(temp);
              count = props.column;
              temp = [];
            }
          });
          return rows;
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(descriptionKls))
          }, [
            _ctx.title || _ctx.extra || _ctx.$slots.title || _ctx.$slots.extra ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns).e("header"))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("title"))
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(_ctx.title), 1)
                ])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("extra"))
              }, [
                renderSlot(_ctx.$slots, "extra", {}, () => [
                  createTextVNode(toDisplayString(_ctx.extra), 1)
                ])
              ], 2)
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns).e("body"))
            }, [
              createBaseVNode("table", {
                class: normalizeClass([unref(ns).e("table"), unref(ns).is("bordered", _ctx.border)])
              }, [
                createBaseVNode("tbody", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(getRows(), (row, index2) => {
                    return openBlock(), createBlock(ElDescriptionsRow, {
                      key: index2,
                      row
                    }, null, 8, ["row"]);
                  }), 128))
                ])
              ], 2)
            ], 2)
          ], 2);
        };
      }
    }));
    var Descriptions = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/description.vue"]]);
    var DescriptionsItem = defineComponent({
      name: "ElDescriptionsItem",
      props: {
        label: {
          type: String,
          default: ""
        },
        span: {
          type: Number,
          default: 1
        },
        width: {
          type: [String, Number],
          default: ""
        },
        minWidth: {
          type: [String, Number],
          default: ""
        },
        align: {
          type: String,
          default: "left"
        },
        labelAlign: {
          type: String,
          default: ""
        },
        className: {
          type: String,
          default: ""
        },
        labelClassName: {
          type: String,
          default: ""
        }
      }
    });
    const ElDescriptions = withInstall(Descriptions, {
      DescriptionsItem
    });
    const ElDescriptionsItem = withNoopInstall(DescriptionsItem);
    const linkProps = buildProps({
      type: {
        type: String,
        values: ["primary", "success", "warning", "info", "danger", "default"],
        default: "default"
      },
      underline: {
        type: Boolean,
        default: true
      },
      disabled: { type: Boolean, default: false },
      href: { type: String, default: "" },
      icon: {
        type: iconPropType
      }
    });
    const linkEmits = {
      click: (evt) => evt instanceof MouseEvent
    };
    const _hoisted_1$a = ["href"];
    const __default__$7 = defineComponent({
      name: "ElLink"
    });
    const _sfc_main$e = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$7), {
      props: linkProps,
      emits: linkEmits,
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const ns = useNamespace("link");
        const linkKls = computed(() => [
          ns.b(),
          ns.m(props.type),
          ns.is("disabled", props.disabled),
          ns.is("underline", props.underline && !props.disabled)
        ]);
        function handleClick(event) {
          if (!props.disabled)
            emit2("click", event);
        }
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("a", {
            class: normalizeClass(unref(linkKls)),
            href: _ctx.disabled || !_ctx.href ? void 0 : _ctx.href,
            onClick: handleClick
          }, [
            _ctx.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon)))
              ]),
              _: 1
            })) : createCommentVNode("v-if", true),
            _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(unref(ns).e("inner"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2)) : createCommentVNode("v-if", true),
            _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 2 }) : createCommentVNode("v-if", true)
          ], 10, _hoisted_1$a);
        };
      }
    }));
    var Link = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]);
    const ElLink = withInstall(Link);
    const selectGroupKey = Symbol("ElSelectGroup");
    const selectKey = Symbol("ElSelect");
    function useOption(props, states) {
      const select2 = inject(selectKey);
      const selectGroup = inject(selectGroupKey, { disabled: false });
      const isObject2 = computed(() => {
        return Object.prototype.toString.call(props.value).toLowerCase() === "[object object]";
      });
      const itemSelected = computed(() => {
        if (!select2.props.multiple) {
          return isEqual2(props.value, select2.props.modelValue);
        } else {
          return contains2(select2.props.modelValue, props.value);
        }
      });
      const limitReached = computed(() => {
        if (select2.props.multiple) {
          const modelValue = select2.props.modelValue || [];
          return !itemSelected.value && modelValue.length >= select2.props.multipleLimit && select2.props.multipleLimit > 0;
        } else {
          return false;
        }
      });
      const currentLabel = computed(() => {
        return props.label || (isObject2.value ? "" : props.value);
      });
      const currentValue = computed(() => {
        return props.value || props.label || "";
      });
      const isDisabled = computed(() => {
        return props.disabled || states.groupDisabled || limitReached.value;
      });
      const instance = getCurrentInstance();
      const contains2 = (arr = [], target) => {
        if (!isObject2.value) {
          return arr && arr.includes(target);
        } else {
          const valueKey = select2.props.valueKey;
          return arr && arr.some((item) => {
            return toRaw(get$2(item, valueKey)) === get$2(target, valueKey);
          });
        }
      };
      const isEqual2 = (a2, b) => {
        if (!isObject2.value) {
          return a2 === b;
        } else {
          const { valueKey } = select2.props;
          return get$2(a2, valueKey) === get$2(b, valueKey);
        }
      };
      const hoverItem = () => {
        if (!props.disabled && !selectGroup.disabled) {
          select2.hoverIndex = select2.optionsArray.indexOf(instance.proxy);
        }
      };
      watch(() => currentLabel.value, () => {
        if (!props.created && !select2.props.remote)
          select2.setSelected();
      });
      watch(() => props.value, (val, oldVal) => {
        const { remote, valueKey } = select2.props;
        if (!Object.is(val, oldVal)) {
          select2.onOptionDestroy(oldVal, instance.proxy);
          select2.onOptionCreate(instance.proxy);
        }
        if (!props.created && !remote) {
          if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
            return;
          }
          select2.setSelected();
        }
      });
      watch(() => selectGroup.disabled, () => {
        states.groupDisabled = selectGroup.disabled;
      }, { immediate: true });
      const { queryChange } = toRaw(select2);
      watch(queryChange, (changes) => {
        const { query } = unref(changes);
        const regexp = new RegExp(escapeStringRegexp(query), "i");
        states.visible = regexp.test(currentLabel.value) || props.created;
        if (!states.visible) {
          select2.filteredOptionsCount--;
        }
      }, { immediate: true });
      return {
        select: select2,
        currentLabel,
        currentValue,
        itemSelected,
        isDisabled,
        hoverItem
      };
    }
    const _sfc_main$d = defineComponent({
      name: "ElOption",
      componentName: "ElOption",
      props: {
        value: {
          required: true,
          type: [String, Number, Boolean, Object]
        },
        label: [String, Number],
        created: Boolean,
        disabled: {
          type: Boolean,
          default: false
        }
      },
      setup(props) {
        const ns = useNamespace("select");
        const containerKls = computed(() => [
          ns.be("dropdown", "item"),
          ns.is("disabled", unref(isDisabled)),
          {
            selected: unref(itemSelected),
            hover: unref(hover)
          }
        ]);
        const states = reactive({
          index: -1,
          groupDisabled: false,
          visible: true,
          hitState: false,
          hover: false
        });
        const { currentLabel, itemSelected, isDisabled, select: select2, hoverItem } = useOption(props, states);
        const { visible, hover } = toRefs(states);
        const vm = getCurrentInstance().proxy;
        select2.onOptionCreate(vm);
        onBeforeUnmount(() => {
          const key = vm.value;
          const { selected } = select2;
          const selectedOptions = select2.props.multiple ? selected : [selected];
          const doesSelected = selectedOptions.some((item) => {
            return item.value === vm.value;
          });
          nextTick(() => {
            if (select2.cachedOptions.get(key) === vm && !doesSelected) {
              select2.cachedOptions.delete(key);
            }
          });
          select2.onOptionDestroy(key, vm);
        });
        function selectOptionClick() {
          if (props.disabled !== true && states.groupDisabled !== true) {
            select2.handleOptionSelect(vm);
          }
        }
        return {
          ns,
          containerKls,
          currentLabel,
          itemSelected,
          isDisabled,
          select: select2,
          hoverItem,
          visible,
          hover,
          selectOptionClick,
          states
        };
      }
    });
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("li", {
        class: normalizeClass(_ctx.containerKls),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
        onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
        ])
      ], 34)), [
        [vShow, _ctx.visible]
      ]);
    }
    var Option = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["render", _sfc_render$3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
    const _sfc_main$c = defineComponent({
      name: "ElSelectDropdown",
      componentName: "ElSelectDropdown",
      setup() {
        const select2 = inject(selectKey);
        const ns = useNamespace("select");
        const popperClass = computed(() => select2.props.popperClass);
        const isMultiple = computed(() => select2.props.multiple);
        const isFitInputWidth = computed(() => select2.props.fitInputWidth);
        const minWidth = ref("");
        function updateMinWidth() {
          var _a2;
          minWidth.value = `${(_a2 = select2.selectWrapper) == null ? void 0 : _a2.offsetWidth}px`;
        }
        onMounted(() => {
          updateMinWidth();
          useResizeObserver(select2.selectWrapper, updateMinWidth);
        });
        return {
          ns,
          minWidth,
          popperClass,
          isMultiple,
          isFitInputWidth
        };
      }
    });
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
        style: normalizeStyle({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    }
    var ElSelectMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["render", _sfc_render$2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
    function useSelectStates(props) {
      const { t } = useLocale();
      return reactive({
        options: /* @__PURE__ */ new Map(),
        cachedOptions: /* @__PURE__ */ new Map(),
        createdLabel: null,
        createdSelected: false,
        selected: props.multiple ? [] : {},
        inputLength: 20,
        inputWidth: 0,
        optionsCount: 0,
        filteredOptionsCount: 0,
        visible: false,
        selectedLabel: "",
        hoverIndex: -1,
        query: "",
        previousQuery: null,
        inputHovering: false,
        cachedPlaceHolder: "",
        currentPlaceholder: t("el.select.placeholder"),
        menuVisibleOnFocus: false,
        isOnComposition: false,
        prefixWidth: 11,
        mouseEnter: false,
        focused: false
      });
    }
    const useSelect = (props, states, ctx) => {
      const { t } = useLocale();
      const ns = useNamespace("select");
      useDeprecated({
        from: "suffixTransition",
        replacement: "override style scheme",
        version: "2.3.0",
        scope: "props",
        ref: "https://element-plus.org/en-US/component/select.html#select-attributes"
      }, computed(() => props.suffixTransition === false));
      const reference = ref(null);
      const input = ref(null);
      const iOSInput = ref(null);
      const tooltipRef = ref(null);
      const tagTooltipRef = ref(null);
      const tags = ref(null);
      const selectWrapper = ref(null);
      const scrollbar = ref(null);
      const hoverOption = ref(-1);
      const queryChange = shallowRef({ query: "" });
      const groupQueryChange = shallowRef("");
      const optionList = ref([]);
      let originClientHeight = 0;
      const { form, formItem } = useFormItem();
      const readonly2 = computed(() => !props.filterable || props.multiple || !states.visible);
      const selectDisabled = computed(() => props.disabled || (form == null ? void 0 : form.disabled));
      const showClose = computed(() => {
        const hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== "";
        const criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasValue;
        return criteria;
      });
      const iconComponent = computed(() => props.remote && props.filterable && !props.remoteShowSuffix ? "" : props.suffixIcon);
      const iconReverse = computed(() => ns.is("reverse", iconComponent.value && states.visible && props.suffixTransition));
      const showStatusIconAndState = computed(() => (form == null ? void 0 : form.statusIcon) && (formItem == null ? void 0 : formItem.validateState) && ValidateComponentsMap[formItem == null ? void 0 : formItem.validateState]);
      const debounce$1 = computed(() => props.remote ? 300 : 0);
      const emptyText = computed(() => {
        if (props.loading) {
          return props.loadingText || t("el.select.loading");
        } else {
          if (props.remote && states.query === "" && states.options.size === 0)
            return false;
          if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
            return props.noMatchText || t("el.select.noMatch");
          }
          if (states.options.size === 0) {
            return props.noDataText || t("el.select.noData");
          }
        }
        return null;
      });
      const optionsArray = computed(() => {
        const list = Array.from(states.options.values());
        const newList = [];
        optionList.value.forEach((item) => {
          const index2 = list.findIndex((i2) => i2.currentLabel === item);
          if (index2 > -1) {
            newList.push(list[index2]);
          }
        });
        return newList.length ? newList : list;
      });
      const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
      const showNewOption = computed(() => {
        const hasExistingOption = optionsArray.value.filter((option) => {
          return !option.created;
        }).some((option) => {
          return option.currentLabel === states.query;
        });
        return props.filterable && props.allowCreate && states.query !== "" && !hasExistingOption;
      });
      const selectSize = useFormSize();
      const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
      const dropMenuVisible = computed({
        get() {
          return states.visible && emptyText.value !== false;
        },
        set(val) {
          states.visible = val;
        }
      });
      watch([() => selectDisabled.value, () => selectSize.value, () => form == null ? void 0 : form.size], () => {
        nextTick(() => {
          resetInputHeight();
        });
      });
      watch(() => props.placeholder, (val) => {
        states.cachedPlaceHolder = states.currentPlaceholder = val;
        const hasValue = props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0;
        if (hasValue) {
          states.currentPlaceholder = "";
        }
      });
      watch(() => props.modelValue, (val, oldVal) => {
        if (props.multiple) {
          resetInputHeight();
          if (val && val.length > 0 || input.value && states.query !== "") {
            states.currentPlaceholder = "";
          } else {
            states.currentPlaceholder = states.cachedPlaceHolder;
          }
          if (props.filterable && !props.reserveKeyword) {
            states.query = "";
            handleQueryChange(states.query);
          }
        }
        setSelected();
        if (props.filterable && !props.multiple) {
          states.inputLength = 20;
        }
        if (!isEqual(val, oldVal) && props.validateEvent) {
          formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn());
        }
      }, {
        flush: "post",
        deep: true
      });
      watch(() => states.visible, (val) => {
        var _a2, _b, _c, _d, _e;
        if (!val) {
          if (props.filterable) {
            if (isFunction$3(props.filterMethod)) {
              props.filterMethod("");
            }
            if (isFunction$3(props.remoteMethod)) {
              props.remoteMethod("");
            }
          }
          states.query = "";
          states.previousQuery = null;
          states.selectedLabel = "";
          states.inputLength = 20;
          states.menuVisibleOnFocus = false;
          resetHoverIndex();
          nextTick(() => {
            if (input.value && input.value.value === "" && states.selected.length === 0) {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
          });
          if (!props.multiple) {
            if (states.selected) {
              if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) {
                states.selectedLabel = states.createdLabel;
              } else {
                states.selectedLabel = states.selected.currentLabel;
              }
              if (props.filterable)
                states.query = states.selectedLabel;
            }
            if (props.filterable) {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
          }
        } else {
          (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          if (props.filterable) {
            states.filteredOptionsCount = states.optionsCount;
            states.query = props.remote ? "" : states.selectedLabel;
            (_d = (_c = iOSInput.value) == null ? void 0 : _c.focus) == null ? void 0 : _d.call(_c);
            if (props.multiple) {
              (_e = input.value) == null ? void 0 : _e.focus();
            } else {
              if (states.selectedLabel) {
                states.currentPlaceholder = `${states.selectedLabel}`;
                states.selectedLabel = "";
              }
            }
            handleQueryChange(states.query);
            if (!props.multiple && !props.remote) {
              queryChange.value.query = "";
              triggerRef(queryChange);
              triggerRef(groupQueryChange);
            }
          }
        }
        ctx.emit("visible-change", val);
      });
      watch(() => states.options.entries(), () => {
        var _a2, _b, _c;
        if (!isClient)
          return;
        (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        if (props.multiple) {
          resetInputHeight();
        }
        const inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll("input")) || [];
        if (!Array.from(inputs).includes(document.activeElement)) {
          setSelected();
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
          checkDefaultFirstOption();
        }
      }, {
        flush: "post"
      });
      watch(() => states.hoverIndex, (val) => {
        if (isNumber$1(val) && val > -1) {
          hoverOption.value = optionsArray.value[val] || {};
        } else {
          hoverOption.value = {};
        }
        optionsArray.value.forEach((option) => {
          option.hover = hoverOption.value === option;
        });
      });
      const resetInputHeight = () => {
        nextTick(() => {
          var _a2, _b;
          if (!reference.value)
            return;
          const input2 = reference.value.$el.querySelector("input");
          originClientHeight = originClientHeight || (input2.clientHeight > 0 ? input2.clientHeight + 2 : 0);
          const _tags = tags.value;
          const gotSize = getComponentSize(selectSize.value || (form == null ? void 0 : form.size));
          const sizeInMap = selectSize.value || gotSize === originClientHeight || originClientHeight <= 0 ? gotSize : originClientHeight;
          const isElHidden = input2.offsetParent === null;
          !isElHidden && (input2.style.height = `${(states.selected.length === 0 ? sizeInMap : Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)) - 2}px`);
          if (states.visible && emptyText.value !== false) {
            (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
          }
        });
      };
      const handleQueryChange = (val) => __async(exports, null, function* () {
        if (states.previousQuery === val || states.isOnComposition)
          return;
        if (states.previousQuery === null && (isFunction$3(props.filterMethod) || isFunction$3(props.remoteMethod))) {
          states.previousQuery = val;
          return;
        }
        states.previousQuery = val;
        nextTick(() => {
          var _a2, _b;
          if (states.visible)
            (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        });
        states.hoverIndex = -1;
        if (props.multiple && props.filterable) {
          nextTick(() => {
            const length = input.value.value.length * 15 + 20;
            states.inputLength = props.collapseTags ? Math.min(50, length) : length;
            managePlaceholder();
            resetInputHeight();
          });
        }
        if (props.remote && isFunction$3(props.remoteMethod)) {
          states.hoverIndex = -1;
          props.remoteMethod(val);
        } else if (isFunction$3(props.filterMethod)) {
          props.filterMethod(val);
          triggerRef(groupQueryChange);
        } else {
          states.filteredOptionsCount = states.optionsCount;
          queryChange.value.query = val;
          triggerRef(queryChange);
          triggerRef(groupQueryChange);
        }
        if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {
          yield nextTick();
          checkDefaultFirstOption();
        }
      });
      const managePlaceholder = () => {
        if (states.currentPlaceholder !== "") {
          states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
        }
      };
      const checkDefaultFirstOption = () => {
        const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
        const userCreatedOption = optionsInDropdown.find((n) => n.created);
        const firstOriginOption = optionsInDropdown[0];
        states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
      };
      const setSelected = () => {
        var _a2;
        if (!props.multiple) {
          const option = getOption(props.modelValue);
          if ((_a2 = option.props) == null ? void 0 : _a2.created) {
            states.createdLabel = option.props.value;
            states.createdSelected = true;
          } else {
            states.createdSelected = false;
          }
          states.selectedLabel = option.currentLabel;
          states.selected = option;
          if (props.filterable)
            states.query = states.selectedLabel;
          return;
        } else {
          states.selectedLabel = "";
        }
        const result = [];
        if (Array.isArray(props.modelValue)) {
          props.modelValue.forEach((value) => {
            result.push(getOption(value));
          });
        }
        states.selected = result;
        nextTick(() => {
          resetInputHeight();
        });
      };
      const getOption = (value) => {
        let option;
        const isObjectValue = toRawType(value).toLowerCase() === "object";
        const isNull = toRawType(value).toLowerCase() === "null";
        const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
        for (let i2 = states.cachedOptions.size - 1; i2 >= 0; i2--) {
          const cachedOption = cachedOptionsArray.value[i2];
          const isEqualValue = isObjectValue ? get$2(cachedOption.value, props.valueKey) === get$2(value, props.valueKey) : cachedOption.value === value;
          if (isEqualValue) {
            option = {
              value,
              currentLabel: cachedOption.currentLabel,
              isDisabled: cachedOption.isDisabled
            };
            break;
          }
        }
        if (option)
          return option;
        const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
        const newOption = {
          value,
          currentLabel: label
        };
        if (props.multiple) {
          newOption.hitState = false;
        }
        return newOption;
      };
      const resetHoverIndex = () => {
        setTimeout(() => {
          const valueKey = props.valueKey;
          if (!props.multiple) {
            states.hoverIndex = optionsArray.value.findIndex((item) => {
              return getValueKey(item) === getValueKey(states.selected);
            });
          } else {
            if (states.selected.length > 0) {
              states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
                return optionsArray.value.findIndex((item) => {
                  return get$2(item, valueKey) === get$2(selected, valueKey);
                });
              }));
            } else {
              states.hoverIndex = -1;
            }
          }
        }, 300);
      };
      const handleResize = () => {
        var _a2, _b;
        resetInputWidth();
        (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
        props.multiple && resetInputHeight();
      };
      const resetInputWidth = () => {
        var _a2;
        states.inputWidth = (_a2 = reference.value) == null ? void 0 : _a2.$el.offsetWidth;
      };
      const onInputChange = () => {
        if (props.filterable && states.query !== states.selectedLabel) {
          states.query = states.selectedLabel;
          handleQueryChange(states.query);
        }
      };
      const debouncedOnInputChange = debounce(() => {
        onInputChange();
      }, debounce$1.value);
      const debouncedQueryChange = debounce((e3) => {
        handleQueryChange(e3.target.value);
      }, debounce$1.value);
      const emitChange = (val) => {
        if (!isEqual(props.modelValue, val)) {
          ctx.emit(CHANGE_EVENT, val);
        }
      };
      const deletePrevTag = (e3) => {
        if (e3.code === EVENT_CODE.delete)
          return;
        if (e3.target.value.length <= 0 && !toggleLastOptionHitState()) {
          const value = props.modelValue.slice();
          value.pop();
          ctx.emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
        }
        if (e3.target.value.length === 1 && props.modelValue.length === 0) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      };
      const deleteTag = (event, tag) => {
        const index2 = states.selected.indexOf(tag);
        if (index2 > -1 && !selectDisabled.value) {
          const value = props.modelValue.slice();
          value.splice(index2, 1);
          ctx.emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          ctx.emit("remove-tag", tag.value);
        }
        event.stopPropagation();
        focus();
      };
      const deleteSelected = (event) => {
        event.stopPropagation();
        const value = props.multiple ? [] : "";
        if (!isString$2(value)) {
          for (const item of states.selected) {
            if (item.isDisabled)
              value.push(item.value);
          }
        }
        ctx.emit(UPDATE_MODEL_EVENT, value);
        emitChange(value);
        states.hoverIndex = -1;
        states.visible = false;
        ctx.emit("clear");
        focus();
      };
      const handleOptionSelect = (option) => {
        var _a2;
        if (props.multiple) {
          const value = (props.modelValue || []).slice();
          const optionIndex = getValueIndex(value, option.value);
          if (optionIndex > -1) {
            value.splice(optionIndex, 1);
          } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {
            value.push(option.value);
          }
          ctx.emit(UPDATE_MODEL_EVENT, value);
          emitChange(value);
          if (option.created) {
            states.query = "";
            handleQueryChange("");
            states.inputLength = 20;
          }
          if (props.filterable)
            (_a2 = input.value) == null ? void 0 : _a2.focus();
        } else {
          ctx.emit(UPDATE_MODEL_EVENT, option.value);
          emitChange(option.value);
          states.visible = false;
        }
        setSoftFocus();
        if (states.visible)
          return;
        nextTick(() => {
          scrollToOption(option);
        });
      };
      const getValueIndex = (arr = [], value) => {
        if (!isObject$2(value))
          return arr.indexOf(value);
        const valueKey = props.valueKey;
        let index2 = -1;
        arr.some((item, i2) => {
          if (toRaw(get$2(item, valueKey)) === get$2(value, valueKey)) {
            index2 = i2;
            return true;
          }
          return false;
        });
        return index2;
      };
      const setSoftFocus = () => {
        const _input = input.value || reference.value;
        if (_input) {
          _input == null ? void 0 : _input.focus();
        }
      };
      const scrollToOption = (option) => {
        var _a2, _b, _c, _d, _e;
        const targetOption = Array.isArray(option) ? option[0] : option;
        let target = null;
        if (targetOption == null ? void 0 : targetOption.value) {
          const options = optionsArray.value.filter((item) => item.value === targetOption.value);
          if (options.length > 0) {
            target = options[0].$el;
          }
        }
        if (tooltipRef.value && target) {
          const menu = (_d = (_c = (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef) == null ? void 0 : _c.querySelector) == null ? void 0 : _d.call(_c, `.${ns.be("dropdown", "wrap")}`);
          if (menu) {
            scrollIntoView(menu, target);
          }
        }
        (_e = scrollbar.value) == null ? void 0 : _e.handleScroll();
      };
      const onOptionCreate = (vm) => {
        states.optionsCount++;
        states.filteredOptionsCount++;
        states.options.set(vm.value, vm);
        states.cachedOptions.set(vm.value, vm);
      };
      const onOptionDestroy = (key, vm) => {
        if (states.options.get(key) === vm) {
          states.optionsCount--;
          states.filteredOptionsCount--;
          states.options.delete(key);
        }
      };
      const resetInputState = (e3) => {
        if (e3.code !== EVENT_CODE.backspace)
          toggleLastOptionHitState(false);
        states.inputLength = input.value.value.length * 15 + 20;
        resetInputHeight();
      };
      const toggleLastOptionHitState = (hit) => {
        if (!Array.isArray(states.selected))
          return;
        const option = states.selected[states.selected.length - 1];
        if (!option)
          return;
        if (hit === true || hit === false) {
          option.hitState = hit;
          return hit;
        }
        option.hitState = !option.hitState;
        return option.hitState;
      };
      const handleComposition = (event) => {
        const text = event.target.value;
        if (event.type === "compositionend") {
          states.isOnComposition = false;
          nextTick(() => handleQueryChange(text));
        } else {
          const lastCharacter = text[text.length - 1] || "";
          states.isOnComposition = !isKorean(lastCharacter);
        }
      };
      const handleMenuEnter = () => {
        nextTick(() => scrollToOption(states.selected));
      };
      const handleFocus = (event) => {
        if (!states.focused) {
          if (props.automaticDropdown || props.filterable) {
            if (props.filterable && !states.visible) {
              states.menuVisibleOnFocus = true;
            }
            states.visible = true;
          }
          states.focused = true;
          ctx.emit("focus", event);
        }
      };
      const focus = () => {
        var _a2, _b;
        if (states.visible) {
          (_a2 = input.value || reference.value) == null ? void 0 : _a2.focus();
        } else {
          (_b = reference.value) == null ? void 0 : _b.focus();
        }
      };
      const blur = () => {
        var _a2, _b, _c;
        states.visible = false;
        (_a2 = reference.value) == null ? void 0 : _a2.blur();
        (_c = (_b = iOSInput.value) == null ? void 0 : _b.blur) == null ? void 0 : _c.call(_b);
      };
      const handleBlur = (event) => {
        var _a2, _b, _c;
        if (((_a2 = tooltipRef.value) == null ? void 0 : _a2.isFocusInsideContent(event)) || ((_b = tagTooltipRef.value) == null ? void 0 : _b.isFocusInsideContent(event)) || ((_c = selectWrapper.value) == null ? void 0 : _c.contains(event.relatedTarget))) {
          return;
        }
        states.visible && handleClose();
        states.focused = false;
        ctx.emit("blur", event);
      };
      const handleClearClick = (event) => {
        deleteSelected(event);
      };
      const handleClose = () => {
        states.visible = false;
      };
      const handleKeydownEscape = (event) => {
        if (states.visible) {
          event.preventDefault();
          event.stopPropagation();
          states.visible = false;
        }
      };
      const toggleMenu = (e3) => {
        if (e3 && !states.mouseEnter) {
          return;
        }
        if (!selectDisabled.value) {
          if (states.menuVisibleOnFocus) {
            states.menuVisibleOnFocus = false;
          } else {
            if (!tooltipRef.value || !tooltipRef.value.isFocusInsideContent()) {
              states.visible = !states.visible;
            }
          }
          focus();
        }
      };
      const selectOption = () => {
        if (!states.visible) {
          toggleMenu();
        } else {
          if (optionsArray.value[states.hoverIndex]) {
            handleOptionSelect(optionsArray.value[states.hoverIndex]);
          }
        }
      };
      const getValueKey = (item) => {
        return isObject$2(item.value) ? get$2(item.value, props.valueKey) : item.value;
      };
      const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
      const showTagList = computed(() => states.selected.slice(0, props.maxCollapseTags));
      const collapseTagList = computed(() => states.selected.slice(props.maxCollapseTags));
      const navigateOptions = (direction2) => {
        if (!states.visible) {
          states.visible = true;
          return;
        }
        if (states.options.size === 0 || states.filteredOptionsCount === 0)
          return;
        if (states.isOnComposition)
          return;
        if (!optionsAllDisabled.value) {
          if (direction2 === "next") {
            states.hoverIndex++;
            if (states.hoverIndex === states.options.size) {
              states.hoverIndex = 0;
            }
          } else if (direction2 === "prev") {
            states.hoverIndex--;
            if (states.hoverIndex < 0) {
              states.hoverIndex = states.options.size - 1;
            }
          }
          const option = optionsArray.value[states.hoverIndex];
          if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
            navigateOptions(direction2);
          }
          nextTick(() => scrollToOption(hoverOption.value));
        }
      };
      const handleMouseEnter = () => {
        states.mouseEnter = true;
      };
      const handleMouseLeave = () => {
        states.mouseEnter = false;
      };
      const handleDeleteTooltipTag = (event, tag) => {
        var _a2, _b;
        deleteTag(event, tag);
        (_b = (_a2 = tagTooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      };
      const selectTagsStyle = computed(() => ({
        maxWidth: `${unref(states.inputWidth) - 32 - (showStatusIconAndState.value ? 22 : 0)}px`,
        width: "100%"
      }));
      return {
        optionList,
        optionsArray,
        selectSize,
        handleResize,
        debouncedOnInputChange,
        debouncedQueryChange,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        readonly: readonly2,
        resetInputHeight,
        showClose,
        iconComponent,
        iconReverse,
        showNewOption,
        collapseTagSize,
        setSelected,
        managePlaceholder,
        selectDisabled,
        emptyText,
        toggleLastOptionHitState,
        resetInputState,
        handleComposition,
        onOptionCreate,
        onOptionDestroy,
        handleMenuEnter,
        handleFocus,
        focus,
        blur,
        handleBlur,
        handleClearClick,
        handleClose,
        handleKeydownEscape,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        handleDeleteTooltipTag,
        dropMenuVisible,
        queryChange,
        groupQueryChange,
        showTagList,
        collapseTagList,
        selectTagsStyle,
        reference,
        input,
        iOSInput,
        tooltipRef,
        tagTooltipRef,
        tags,
        selectWrapper,
        scrollbar,
        handleMouseEnter,
        handleMouseLeave
      };
    };
    var ElOptions = defineComponent({
      name: "ElOptions",
      emits: ["update-options"],
      setup(_, { slots, emit: emit2 }) {
        let cachedOptions = [];
        function isSameOptions(a2, b) {
          if (a2.length !== b.length)
            return false;
          for (const [index2] of a2.entries()) {
            if (a2[index2] != b[index2]) {
              return false;
            }
          }
          return true;
        }
        return () => {
          var _a2, _b;
          const children2 = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
          const filteredOptions = [];
          function filterOptions(children22) {
            if (!Array.isArray(children22))
              return;
            children22.forEach((item) => {
              var _a22, _b2, _c, _d;
              const name = (_a22 = (item == null ? void 0 : item.type) || {}) == null ? void 0 : _a22.name;
              if (name === "ElOptionGroup") {
                filterOptions(!isString$2(item.children) && !Array.isArray(item.children) && isFunction$3((_b2 = item.children) == null ? void 0 : _b2.default) ? (_c = item.children) == null ? void 0 : _c.default() : item.children);
              } else if (name === "ElOption") {
                filteredOptions.push((_d = item.props) == null ? void 0 : _d.label);
              } else if (Array.isArray(item.children)) {
                filterOptions(item.children);
              }
            });
          }
          if (children2.length) {
            filterOptions((_b = children2[0]) == null ? void 0 : _b.children);
          }
          if (!isSameOptions(filteredOptions, cachedOptions)) {
            cachedOptions = filteredOptions;
            emit2("update-options", filteredOptions);
          }
          return children2;
        };
      }
    });
    const COMPONENT_NAME$2 = "ElSelect";
    const _sfc_main$b = defineComponent({
      name: COMPONENT_NAME$2,
      componentName: COMPONENT_NAME$2,
      components: {
        ElInput,
        ElSelectMenu,
        ElOption: Option,
        ElOptions,
        ElTag,
        ElScrollbar,
        ElTooltip,
        ElIcon
      },
      directives: { ClickOutside },
      props: {
        name: String,
        id: String,
        modelValue: {
          type: [Array, String, Number, Boolean, Object],
          default: void 0
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        automaticDropdown: Boolean,
        size: {
          type: String,
          validator: isValidComponentSize
        },
        effect: {
          type: String,
          default: "light"
        },
        disabled: Boolean,
        clearable: Boolean,
        filterable: Boolean,
        allowCreate: Boolean,
        loading: Boolean,
        popperClass: {
          type: String,
          default: ""
        },
        popperOptions: {
          type: Object,
          default: () => ({})
        },
        remote: Boolean,
        loadingText: String,
        noMatchText: String,
        noDataText: String,
        remoteMethod: Function,
        filterMethod: Function,
        multiple: Boolean,
        multipleLimit: {
          type: Number,
          default: 0
        },
        placeholder: {
          type: String
        },
        defaultFirstOption: Boolean,
        reserveKeyword: {
          type: Boolean,
          default: true
        },
        valueKey: {
          type: String,
          default: "value"
        },
        collapseTags: Boolean,
        collapseTagsTooltip: {
          type: Boolean,
          default: false
        },
        maxCollapseTags: {
          type: Number,
          default: 1
        },
        teleported: useTooltipContentProps.teleported,
        persistent: {
          type: Boolean,
          default: true
        },
        clearIcon: {
          type: iconPropType,
          default: circle_close_default
        },
        fitInputWidth: {
          type: Boolean,
          default: false
        },
        suffixIcon: {
          type: iconPropType,
          default: arrow_down_default
        },
        tagType: __spreadProps(__spreadValues({}, tagProps.type), { default: "info" }),
        validateEvent: {
          type: Boolean,
          default: true
        },
        remoteShowSuffix: {
          type: Boolean,
          default: false
        },
        suffixTransition: {
          type: Boolean,
          default: true
        },
        placement: {
          type: String,
          values: Ee,
          default: "bottom-start"
        }
      },
      emits: [
        UPDATE_MODEL_EVENT,
        CHANGE_EVENT,
        "remove-tag",
        "clear",
        "visible-change",
        "focus",
        "blur"
      ],
      setup(props, ctx) {
        const nsSelect = useNamespace("select");
        const nsInput = useNamespace("input");
        const { t } = useLocale();
        const states = useSelectStates(props);
        const {
          optionList,
          optionsArray,
          selectSize,
          readonly: readonly2,
          handleResize,
          collapseTagSize,
          debouncedOnInputChange,
          debouncedQueryChange,
          deletePrevTag,
          deleteTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          setSelected,
          resetInputHeight,
          managePlaceholder,
          showClose,
          selectDisabled,
          iconComponent,
          iconReverse,
          showNewOption,
          emptyText,
          toggleLastOptionHitState,
          resetInputState,
          handleComposition,
          onOptionCreate,
          onOptionDestroy,
          handleMenuEnter,
          handleFocus,
          focus,
          blur,
          handleBlur,
          handleClearClick,
          handleClose,
          handleKeydownEscape,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          handleDeleteTooltipTag,
          dropMenuVisible,
          reference,
          input,
          iOSInput,
          tooltipRef,
          tagTooltipRef,
          tags,
          selectWrapper,
          scrollbar,
          queryChange,
          groupQueryChange,
          handleMouseEnter,
          handleMouseLeave,
          showTagList,
          collapseTagList,
          selectTagsStyle
        } = useSelect(props, states, ctx);
        const {
          inputWidth,
          selected,
          inputLength,
          filteredOptionsCount,
          visible,
          selectedLabel,
          hoverIndex,
          query,
          inputHovering,
          currentPlaceholder,
          menuVisibleOnFocus,
          isOnComposition,
          options,
          cachedOptions,
          optionsCount,
          prefixWidth
        } = toRefs(states);
        const wrapperKls = computed(() => {
          const classList2 = [nsSelect.b()];
          const _selectSize = unref(selectSize);
          if (_selectSize) {
            classList2.push(nsSelect.m(_selectSize));
          }
          if (props.disabled) {
            classList2.push(nsSelect.m("disabled"));
          }
          return classList2;
        });
        const tagsKls = computed(() => [
          nsSelect.e("tags"),
          nsSelect.is("disabled", unref(selectDisabled))
        ]);
        const tagWrapperKls = computed(() => [
          nsSelect.b("tags-wrapper"),
          { "has-prefix": unref(prefixWidth) && unref(selected).length }
        ]);
        const inputKls = computed(() => [
          nsSelect.e("input"),
          nsSelect.is(unref(selectSize)),
          nsSelect.is("disabled", unref(selectDisabled))
        ]);
        const iOSInputKls = computed(() => [
          nsSelect.e("input"),
          nsSelect.is(unref(selectSize)),
          nsSelect.em("input", "iOS")
        ]);
        const scrollbarKls = computed(() => [
          nsSelect.is("empty", !props.allowCreate && Boolean(unref(query)) && unref(filteredOptionsCount) === 0)
        ]);
        const tagTextStyle = computed(() => {
          const maxWidth = unref(inputWidth) > 123 ? unref(inputWidth) - 123 : unref(inputWidth) - 75;
          return { maxWidth: `${maxWidth}px` };
        });
        const inputStyle = computed(() => ({
          marginLeft: `${unref(prefixWidth)}px`,
          flexGrow: 1,
          width: `${unref(inputLength) / (unref(inputWidth) - 32)}%`,
          maxWidth: `${unref(inputWidth) - 42}px`
        }));
        provide(selectKey, reactive({
          props,
          options,
          optionsArray,
          cachedOptions,
          optionsCount,
          filteredOptionsCount,
          hoverIndex,
          handleOptionSelect,
          onOptionCreate,
          onOptionDestroy,
          selectWrapper,
          selected,
          setSelected,
          queryChange,
          groupQueryChange
        }));
        onMounted(() => {
          states.cachedPlaceHolder = currentPlaceholder.value = props.placeholder || (() => t("el.select.placeholder"));
          if (props.multiple && Array.isArray(props.modelValue) && props.modelValue.length > 0) {
            currentPlaceholder.value = "";
          }
          useResizeObserver(selectWrapper, handleResize);
          if (props.remote && props.multiple) {
            resetInputHeight();
          }
          nextTick(() => {
            const refEl = reference.value && reference.value.$el;
            if (!refEl)
              return;
            inputWidth.value = refEl.getBoundingClientRect().width;
            if (ctx.slots.prefix) {
              const prefix2 = refEl.querySelector(`.${nsInput.e("prefix")}`);
              prefixWidth.value = Math.max(prefix2.getBoundingClientRect().width + 11, 30);
            }
          });
          setSelected();
        });
        if (props.multiple && !Array.isArray(props.modelValue)) {
          ctx.emit(UPDATE_MODEL_EVENT, []);
        }
        if (!props.multiple && Array.isArray(props.modelValue)) {
          ctx.emit(UPDATE_MODEL_EVENT, "");
        }
        const popperPaneRef = computed(() => {
          var _a2, _b;
          return (_b = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
        });
        const onOptionsRendered = (v) => {
          optionList.value = v;
        };
        return {
          isIOS,
          onOptionsRendered,
          prefixWidth,
          selectSize,
          readonly: readonly2,
          handleResize,
          collapseTagSize,
          debouncedOnInputChange,
          debouncedQueryChange,
          deletePrevTag,
          deleteTag,
          handleDeleteTooltipTag,
          deleteSelected,
          handleOptionSelect,
          scrollToOption,
          inputWidth,
          selected,
          inputLength,
          filteredOptionsCount,
          visible,
          selectedLabel,
          hoverIndex,
          query,
          inputHovering,
          currentPlaceholder,
          menuVisibleOnFocus,
          isOnComposition,
          options,
          resetInputHeight,
          managePlaceholder,
          showClose,
          selectDisabled,
          iconComponent,
          iconReverse,
          showNewOption,
          emptyText,
          toggleLastOptionHitState,
          resetInputState,
          handleComposition,
          handleMenuEnter,
          handleFocus,
          focus,
          blur,
          handleBlur,
          handleClearClick,
          handleClose,
          handleKeydownEscape,
          toggleMenu,
          selectOption,
          getValueKey,
          navigateOptions,
          dropMenuVisible,
          reference,
          input,
          iOSInput,
          tooltipRef,
          popperPaneRef,
          tags,
          selectWrapper,
          scrollbar,
          wrapperKls,
          tagsKls,
          tagWrapperKls,
          inputKls,
          iOSInputKls,
          scrollbarKls,
          selectTagsStyle,
          nsSelect,
          tagTextStyle,
          inputStyle,
          handleMouseEnter,
          handleMouseLeave,
          showTagList,
          collapseTagList,
          tagTooltipRef
        };
      }
    });
    const _hoisted_1$9 = ["disabled", "autocomplete"];
    const _hoisted_2$8 = ["disabled"];
    const _hoisted_3$6 = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_el_tag = resolveComponent("el-tag");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_icon = resolveComponent("el-icon");
      const _component_el_input = resolveComponent("el-input");
      const _component_el_option = resolveComponent("el-option");
      const _component_el_options = resolveComponent("el-options");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_select_menu = resolveComponent("el-select-menu");
      const _directive_click_outside = resolveDirective("click-outside");
      return withDirectives((openBlock(), createElementBlock("div", {
        ref: "selectWrapper",
        class: normalizeClass(_ctx.wrapperKls),
        onMouseenter: _cache[22] || (_cache[22] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
        onMouseleave: _cache[23] || (_cache[23] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
        onClick: _cache[24] || (_cache[24] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
      }, [
        createVNode(_component_el_tooltip, {
          ref: "tooltipRef",
          visible: _ctx.dropMenuVisible,
          placement: _ctx.placement,
          teleported: _ctx.teleported,
          "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
          "popper-options": _ctx.popperOptions,
          "fallback-placements": ["bottom-start", "top-start", "right", "left"],
          effect: _ctx.effect,
          pure: "",
          trigger: "click",
          transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
          "stop-popper-mouse-event": false,
          "gpu-acceleration": false,
          persistent: _ctx.persistent,
          onShow: _ctx.handleMenuEnter
        }, {
          default: withCtx(() => [
            createBaseVNode("div", {
              class: "select-trigger",
              onMouseenter: _cache[20] || (_cache[20] = ($event) => _ctx.inputHovering = true),
              onMouseleave: _cache[21] || (_cache[21] = ($event) => _ctx.inputHovering = false)
            }, [
              _ctx.multiple ? (openBlock(), createElementBlock("div", {
                key: 0,
                ref: "tags",
                tabindex: "-1",
                class: normalizeClass(_ctx.tagsKls),
                style: normalizeStyle(_ctx.selectTagsStyle),
                onClick: _cache[15] || (_cache[15] = (...args) => _ctx.focus && _ctx.focus(...args))
              }, [
                _ctx.collapseTags && _ctx.selected.length ? (openBlock(), createBlock(Transition$1, {
                  key: 0,
                  onAfterLeave: _ctx.resetInputHeight
                }, {
                  default: withCtx(() => [
                    createBaseVNode("span", {
                      class: normalizeClass(_ctx.tagWrapperKls)
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showTagList, (item) => {
                        return openBlock(), createBlock(_component_el_tag, {
                          key: _ctx.getValueKey(item),
                          closable: !_ctx.selectDisabled && !item.isDisabled,
                          size: _ctx.collapseTagSize,
                          hit: item.hitState,
                          type: _ctx.tagType,
                          "disable-transitions": "",
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                              style: normalizeStyle(_ctx.tagTextStyle)
                            }, toDisplayString(item.currentLabel), 7)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                      }), 128)),
                      _ctx.selected.length > _ctx.maxCollapseTags ? (openBlock(), createBlock(_component_el_tag, {
                        key: 0,
                        closable: false,
                        size: _ctx.collapseTagSize,
                        type: _ctx.tagType,
                        "disable-transitions": ""
                      }, {
                        default: withCtx(() => [
                          _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                            key: 0,
                            ref: "tagTooltipRef",
                            disabled: _ctx.dropMenuVisible,
                            "fallback-placements": ["bottom", "top", "right", "left"],
                            effect: _ctx.effect,
                            placement: "bottom",
                            teleported: _ctx.teleported
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", {
                                class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                              }, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3)
                            ]),
                            content: withCtx(() => [
                              createBaseVNode("div", {
                                class: normalizeClass(_ctx.nsSelect.e("collapse-tags"))
                              }, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapseTagList, (item) => {
                                  return openBlock(), createElementBlock("div", {
                                    key: _ctx.getValueKey(item),
                                    class: normalizeClass(_ctx.nsSelect.e("collapse-tag"))
                                  }, [
                                    createVNode(_component_el_tag, {
                                      class: "in-tooltip",
                                      closable: !_ctx.selectDisabled && !item.isDisabled,
                                      size: _ctx.collapseTagSize,
                                      hit: item.hitState,
                                      type: _ctx.tagType,
                                      "disable-transitions": "",
                                      style: { margin: "2px" },
                                      onClose: ($event) => _ctx.handleDeleteTooltipTag($event, item)
                                    }, {
                                      default: withCtx(() => [
                                        createBaseVNode("span", {
                                          class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                          style: normalizeStyle({
                                            maxWidth: _ctx.inputWidth - 75 + "px"
                                          })
                                        }, toDisplayString(item.currentLabel), 7)
                                      ]),
                                      _: 2
                                    }, 1032, ["closable", "size", "hit", "type", "onClose"])
                                  ], 2);
                                }), 128))
                              ], 2)
                            ]),
                            _: 1
                          }, 8, ["disabled", "effect", "teleported"])) : (openBlock(), createElementBlock("span", {
                            key: 1,
                            class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                          }, "+ " + toDisplayString(_ctx.selected.length - _ctx.maxCollapseTags), 3))
                        ]),
                        _: 1
                      }, 8, ["size", "type"])) : createCommentVNode("v-if", true)
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
                !_ctx.collapseTags ? (openBlock(), createBlock(Transition$1, {
                  key: 1,
                  onAfterLeave: _ctx.resetInputHeight
                }, {
                  default: withCtx(() => [
                    createBaseVNode("span", {
                      class: normalizeClass(_ctx.tagWrapperKls),
                      style: normalizeStyle(_ctx.prefixWidth && _ctx.selected.length ? { marginLeft: `${_ctx.prefixWidth}px` } : "")
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item) => {
                        return openBlock(), createBlock(_component_el_tag, {
                          key: _ctx.getValueKey(item),
                          closable: !_ctx.selectDisabled && !item.isDisabled,
                          size: _ctx.collapseTagSize,
                          hit: item.hitState,
                          type: _ctx.tagType,
                          "disable-transitions": "",
                          onClose: ($event) => _ctx.deleteTag($event, item)
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", {
                              class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                              style: normalizeStyle({ maxWidth: _ctx.inputWidth - 75 + "px" })
                            }, toDisplayString(item.currentLabel), 7)
                          ]),
                          _: 2
                        }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                      }), 128))
                    ], 6)
                  ]),
                  _: 1
                }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
                _ctx.filterable && !_ctx.selectDisabled ? withDirectives((openBlock(), createElementBlock("input", {
                  key: 2,
                  ref: "input",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.query = $event),
                  type: "text",
                  class: normalizeClass(_ctx.inputKls),
                  disabled: _ctx.selectDisabled,
                  autocomplete: _ctx.autocomplete,
                  style: normalizeStyle(_ctx.inputStyle),
                  onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
                  onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
                  onKeyup: _cache[3] || (_cache[3] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
                  onKeydown: [
                    _cache[4] || (_cache[4] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                    _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                    _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                    _cache[7] || (_cache[7] = withKeys((...args) => _ctx.handleKeydownEscape && _ctx.handleKeydownEscape(...args), ["esc"])),
                    _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                    _cache[9] || (_cache[9] = withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                    _cache[10] || (_cache[10] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                  ],
                  onCompositionstart: _cache[11] || (_cache[11] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                  onCompositionupdate: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                  onCompositionend: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
                  onInput: _cache[14] || (_cache[14] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
                }, null, 46, _hoisted_1$9)), [
                  [vModelText, _ctx.query]
                ]) : createCommentVNode("v-if", true)
              ], 6)) : createCommentVNode("v-if", true),
              createCommentVNode(" fix: https://github.com/element-plus/element-plus/issues/11415 "),
              _ctx.isIOS && !_ctx.multiple && _ctx.filterable && _ctx.readonly ? (openBlock(), createElementBlock("input", {
                key: 1,
                ref: "iOSInput",
                class: normalizeClass(_ctx.iOSInputKls),
                disabled: _ctx.selectDisabled,
                type: "text"
              }, null, 10, _hoisted_2$8)) : createCommentVNode("v-if", true),
              createVNode(_component_el_input, {
                id: _ctx.id,
                ref: "reference",
                modelValue: _ctx.selectedLabel,
                "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => _ctx.selectedLabel = $event),
                type: "text",
                placeholder: typeof _ctx.currentPlaceholder === "function" ? _ctx.currentPlaceholder() : _ctx.currentPlaceholder,
                name: _ctx.name,
                autocomplete: _ctx.autocomplete,
                size: _ctx.selectSize,
                disabled: _ctx.selectDisabled,
                readonly: _ctx.readonly,
                "validate-event": false,
                class: normalizeClass([_ctx.nsSelect.is("focus", _ctx.visible)]),
                tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
                onFocus: _ctx.handleFocus,
                onBlur: _ctx.handleBlur,
                onInput: _ctx.debouncedOnInputChange,
                onPaste: _ctx.debouncedOnInputChange,
                onCompositionstart: _ctx.handleComposition,
                onCompositionupdate: _ctx.handleComposition,
                onCompositionend: _ctx.handleComposition,
                onKeydown: [
                  _cache[17] || (_cache[17] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
                  _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
                  withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
                  withKeys(_ctx.handleKeydownEscape, ["esc"]),
                  _cache[19] || (_cache[19] = withKeys(($event) => _ctx.visible = false, ["tab"]))
                ]
              }, createSlots({
                suffix: withCtx(() => [
                  _ctx.iconComponent && !_ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
                    key: 0,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true),
                  _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                    key: 1,
                    class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                    onClick: _ctx.handleClearClick
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                    ]),
                    _: 1
                  }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
                ]),
                _: 2
              }, [
                _ctx.$slots.prefix ? {
                  name: "prefix",
                  fn: withCtx(() => [
                    createBaseVNode("div", _hoisted_3$6, [
                      renderSlot(_ctx.$slots, "prefix")
                    ])
                  ])
                } : void 0
              ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
            ], 32)
          ]),
          content: withCtx(() => [
            createVNode(_component_el_select_menu, null, {
              default: withCtx(() => [
                withDirectives(createVNode(_component_el_scrollbar, {
                  ref: "scrollbar",
                  tag: "ul",
                  "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
                  "view-class": _ctx.nsSelect.be("dropdown", "list"),
                  class: normalizeClass(_ctx.scrollbarKls)
                }, {
                  default: withCtx(() => [
                    _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                      key: 0,
                      value: _ctx.query,
                      created: true
                    }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                    createVNode(_component_el_options, { onUpdateOptions: _ctx.onOptionsRendered }, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    }, 8, ["onUpdateOptions"])
                  ]),
                  _: 3
                }, 8, ["wrap-class", "view-class", "class"]), [
                  [vShow, _ctx.options.size > 0 && !_ctx.loading]
                ]),
                _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.$slots.empty ? renderSlot(_ctx.$slots, "empty", { key: 0 }) : (openBlock(), createElementBlock("p", {
                    key: 1,
                    class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
                  }, toDisplayString(_ctx.emptyText), 3))
                ], 64)) : createCommentVNode("v-if", true)
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["visible", "placement", "teleported", "popper-class", "popper-options", "effect", "transition", "persistent", "onShow"])
      ], 34)), [
        [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
      ]);
    }
    var Select = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["render", _sfc_render$1], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
    const _sfc_main$a = defineComponent({
      name: "ElOptionGroup",
      componentName: "ElOptionGroup",
      props: {
        label: String,
        disabled: {
          type: Boolean,
          default: false
        }
      },
      setup(props) {
        const ns = useNamespace("select");
        const visible = ref(true);
        const instance = getCurrentInstance();
        const children2 = ref([]);
        provide(selectGroupKey, reactive(__spreadValues({}, toRefs(props))));
        const select2 = inject(selectKey);
        onMounted(() => {
          children2.value = flattedChildren2(instance.subTree);
        });
        const flattedChildren2 = (node) => {
          const children22 = [];
          if (Array.isArray(node.children)) {
            node.children.forEach((child) => {
              var _a2;
              if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
                children22.push(child.component.proxy);
              } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
                children22.push(...flattedChildren2(child));
              }
            });
          }
          return children22;
        };
        const { groupQueryChange } = toRaw(select2);
        watch(groupQueryChange, () => {
          visible.value = children2.value.some((option) => option.visible === true);
        }, { flush: "post" });
        return {
          visible,
          ns
        };
      }
    });
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("ul", {
        class: normalizeClass(_ctx.ns.be("group", "wrap"))
      }, [
        createBaseVNode("li", {
          class: normalizeClass(_ctx.ns.be("group", "title"))
        }, toDisplayString(_ctx.label), 3),
        createBaseVNode("li", null, [
          createBaseVNode("ul", {
            class: normalizeClass(_ctx.ns.b("group"))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)
        ])
      ], 2)), [
        [vShow, _ctx.visible]
      ]);
    }
    var OptionGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
    const ElSelect = withInstall(Select, {
      Option,
      OptionGroup
    });
    const ElOption = withNoopInstall(Option);
    withNoopInstall(OptionGroup);
    const progressProps = buildProps({
      type: {
        type: String,
        default: "line",
        values: ["line", "circle", "dashboard"]
      },
      percentage: {
        type: Number,
        default: 0,
        validator: (val) => val >= 0 && val <= 100
      },
      status: {
        type: String,
        default: "",
        values: ["", "success", "exception", "warning"]
      },
      indeterminate: {
        type: Boolean,
        default: false
      },
      duration: {
        type: Number,
        default: 3
      },
      strokeWidth: {
        type: Number,
        default: 6
      },
      strokeLinecap: {
        type: definePropType(String),
        default: "round"
      },
      textInside: {
        type: Boolean,
        default: false
      },
      width: {
        type: Number,
        default: 126
      },
      showText: {
        type: Boolean,
        default: true
      },
      color: {
        type: definePropType([
          String,
          Array,
          Function
        ]),
        default: ""
      },
      striped: Boolean,
      stripedFlow: Boolean,
      format: {
        type: definePropType(Function),
        default: (percentage) => `${percentage}%`
      }
    });
    const _hoisted_1$8 = ["aria-valuenow"];
    const _hoisted_2$7 = { viewBox: "0 0 100 100" };
    const _hoisted_3$5 = ["d", "stroke", "stroke-linecap", "stroke-width"];
    const _hoisted_4$4 = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"];
    const _hoisted_5$4 = { key: 0 };
    const __default__$6 = defineComponent({
      name: "ElProgress"
    });
    const _sfc_main$9 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$6), {
      props: progressProps,
      setup(__props) {
        const props = __props;
        const STATUS_COLOR_MAP = {
          success: "#13ce66",
          exception: "#ff4949",
          warning: "#e6a23c",
          default: "#20a0ff"
        };
        const ns = useNamespace("progress");
        const barStyle = computed(() => ({
          width: `${props.percentage}%`,
          animationDuration: `${props.duration}s`,
          backgroundColor: getCurrentColor(props.percentage)
        }));
        const relativeStrokeWidth = computed(() => (props.strokeWidth / props.width * 100).toFixed(1));
        const radius = computed(() => {
          if (["circle", "dashboard"].includes(props.type)) {
            return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
          }
          return 0;
        });
        const trackPath = computed(() => {
          const r = radius.value;
          const isDashboard = props.type === "dashboard";
          return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
        });
        const perimeter = computed(() => 2 * Math.PI * radius.value);
        const rate = computed(() => props.type === "dashboard" ? 0.75 : 1);
        const strokeDashoffset = computed(() => {
          const offset = -1 * perimeter.value * (1 - rate.value) / 2;
          return `${offset}px`;
        });
        const trailPathStyle = computed(() => ({
          strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
          strokeDashoffset: strokeDashoffset.value
        }));
        const circlePathStyle = computed(() => ({
          strokeDasharray: `${perimeter.value * rate.value * (props.percentage / 100)}px, ${perimeter.value}px`,
          strokeDashoffset: strokeDashoffset.value,
          transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
        }));
        const stroke = computed(() => {
          let ret;
          if (props.color) {
            ret = getCurrentColor(props.percentage);
          } else {
            ret = STATUS_COLOR_MAP[props.status] || STATUS_COLOR_MAP.default;
          }
          return ret;
        });
        const statusIcon = computed(() => {
          if (props.status === "warning") {
            return warning_filled_default;
          }
          if (props.type === "line") {
            return props.status === "success" ? circle_check_default : circle_close_default;
          } else {
            return props.status === "success" ? check_default : close_default;
          }
        });
        const progressTextSize = computed(() => {
          return props.type === "line" ? 12 + props.strokeWidth * 0.4 : props.width * 0.111111 + 2;
        });
        const content2 = computed(() => props.format(props.percentage));
        function getColors(color2) {
          const span = 100 / color2.length;
          const seriesColors = color2.map((seriesColor, index2) => {
            if (isString$2(seriesColor)) {
              return {
                color: seriesColor,
                percentage: (index2 + 1) * span
              };
            }
            return seriesColor;
          });
          return seriesColors.sort((a2, b) => a2.percentage - b.percentage);
        }
        const getCurrentColor = (percentage) => {
          var _a2;
          const { color: color2 } = props;
          if (isFunction$3(color2)) {
            return color2(percentage);
          } else if (isString$2(color2)) {
            return color2;
          } else {
            const colors = getColors(color2);
            for (const color22 of colors) {
              if (color22.percentage > percentage)
                return color22.color;
            }
            return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
          }
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([
              unref(ns).b(),
              unref(ns).m(_ctx.type),
              unref(ns).is(_ctx.status),
              {
                [unref(ns).m("without-text")]: !_ctx.showText,
                [unref(ns).m("text-inside")]: _ctx.textInside
              }
            ]),
            role: "progressbar",
            "aria-valuenow": _ctx.percentage,
            "aria-valuemin": "0",
            "aria-valuemax": "100"
          }, [
            _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(ns).b("bar"))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).be("bar", "outer")),
                style: normalizeStyle({ height: `${_ctx.strokeWidth}px` })
              }, [
                createBaseVNode("div", {
                  class: normalizeClass([
                    unref(ns).be("bar", "inner"),
                    { [unref(ns).bem("bar", "inner", "indeterminate")]: _ctx.indeterminate },
                    { [unref(ns).bem("bar", "inner", "striped")]: _ctx.striped },
                    { [unref(ns).bem("bar", "inner", "striped-flow")]: _ctx.stripedFlow }
                  ]),
                  style: normalizeStyle(unref(barStyle))
                }, [
                  (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(unref(ns).be("bar", "innerText"))
                  }, [
                    renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                      createBaseVNode("span", null, toDisplayString(unref(content2)), 1)
                    ])
                  ], 2)) : createCommentVNode("v-if", true)
                ], 6)
              ], 6)
            ], 2)) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(ns).b("circle")),
              style: normalizeStyle({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
            }, [
              (openBlock(), createElementBlock("svg", _hoisted_2$7, [
                createBaseVNode("path", {
                  class: normalizeClass(unref(ns).be("circle", "track")),
                  d: unref(trackPath),
                  stroke: `var(${unref(ns).cssVarName("fill-color-light")}, #e5e9f2)`,
                  "stroke-linecap": _ctx.strokeLinecap,
                  "stroke-width": unref(relativeStrokeWidth),
                  fill: "none",
                  style: normalizeStyle(unref(trailPathStyle))
                }, null, 14, _hoisted_3$5),
                createBaseVNode("path", {
                  class: normalizeClass(unref(ns).be("circle", "path")),
                  d: unref(trackPath),
                  stroke: unref(stroke),
                  fill: "none",
                  opacity: _ctx.percentage ? 1 : 0,
                  "stroke-linecap": _ctx.strokeLinecap,
                  "stroke-width": unref(relativeStrokeWidth),
                  style: normalizeStyle(unref(circlePathStyle))
                }, null, 14, _hoisted_4$4)
              ]))
            ], 6)),
            (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(unref(ns).e("text")),
              style: normalizeStyle({ fontSize: `${unref(progressTextSize)}px` })
            }, [
              renderSlot(_ctx.$slots, "default", { percentage: _ctx.percentage }, () => [
                !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$4, toDisplayString(unref(content2)), 1)) : (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(statusIcon))))
                  ]),
                  _: 1
                }))
              ])
            ], 6)) : createCommentVNode("v-if", true)
          ], 10, _hoisted_1$8);
        };
      }
    }));
    var Progress = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
    const ElProgress = withInstall(Progress);
    const switchProps = buildProps({
      modelValue: {
        type: [Boolean, String, Number],
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      loading: {
        type: Boolean,
        default: false
      },
      size: {
        type: String,
        validator: isValidComponentSize
      },
      width: {
        type: [String, Number],
        default: ""
      },
      inlinePrompt: {
        type: Boolean,
        default: false
      },
      inactiveActionIcon: {
        type: iconPropType
      },
      activeActionIcon: {
        type: iconPropType
      },
      activeIcon: {
        type: iconPropType
      },
      inactiveIcon: {
        type: iconPropType
      },
      activeText: {
        type: String,
        default: ""
      },
      inactiveText: {
        type: String,
        default: ""
      },
      activeValue: {
        type: [Boolean, String, Number],
        default: true
      },
      inactiveValue: {
        type: [Boolean, String, Number],
        default: false
      },
      activeColor: {
        type: String,
        default: ""
      },
      inactiveColor: {
        type: String,
        default: ""
      },
      borderColor: {
        type: String,
        default: ""
      },
      name: {
        type: String,
        default: ""
      },
      validateEvent: {
        type: Boolean,
        default: true
      },
      beforeChange: {
        type: definePropType(Function)
      },
      id: String,
      tabindex: {
        type: [String, Number]
      },
      value: {
        type: [Boolean, String, Number],
        default: false
      }
    });
    const switchEmits = {
      [UPDATE_MODEL_EVENT]: (val) => isBoolean$1(val) || isString$2(val) || isNumber$1(val),
      [CHANGE_EVENT]: (val) => isBoolean$1(val) || isString$2(val) || isNumber$1(val),
      [INPUT_EVENT]: (val) => isBoolean$1(val) || isString$2(val) || isNumber$1(val)
    };
    const _hoisted_1$7 = ["onClick"];
    const _hoisted_2$6 = ["id", "aria-checked", "aria-disabled", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"];
    const _hoisted_3$4 = ["aria-hidden"];
    const _hoisted_4$3 = ["aria-hidden"];
    const _hoisted_5$3 = ["aria-hidden"];
    const COMPONENT_NAME$1 = "ElSwitch";
    const __default__$5 = defineComponent({
      name: COMPONENT_NAME$1
    });
    const _sfc_main$8 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$5), {
      props: switchProps,
      emits: switchEmits,
      setup(__props, { expose, emit: emit2 }) {
        const props = __props;
        const vm = getCurrentInstance();
        const { formItem } = useFormItem();
        const switchSize = useFormSize();
        const ns = useNamespace("switch");
        const useBatchDeprecated = (list) => {
          list.forEach((param) => {
            useDeprecated({
              from: param[0],
              replacement: param[1],
              scope: COMPONENT_NAME$1,
              version: "2.3.0",
              ref: "https://element-plus.org/en-US/component/switch.html#attributes",
              type: "Attribute"
            }, computed(() => {
              var _a2;
              return !!((_a2 = vm.vnode.props) == null ? void 0 : _a2[param[2]]);
            }));
          });
        };
        useBatchDeprecated([
          ['"value"', '"model-value" or "v-model"', "value"],
          ['"active-color"', "CSS var `--el-switch-on-color`", "activeColor"],
          ['"inactive-color"', "CSS var `--el-switch-off-color`", "inactiveColor"],
          ['"border-color"', "CSS var `--el-switch-border-color`", "borderColor"]
        ]);
        const { inputId } = useFormItemInputId(props, {
          formItemContext: formItem
        });
        const switchDisabled = useFormDisabled(computed(() => props.loading));
        const isControlled = ref(props.modelValue !== false);
        const input = ref();
        const core = ref();
        const switchKls = computed(() => [
          ns.b(),
          ns.m(switchSize.value),
          ns.is("disabled", switchDisabled.value),
          ns.is("checked", checked.value)
        ]);
        const labelLeftKls = computed(() => [
          ns.e("label"),
          ns.em("label", "left"),
          ns.is("active", !checked.value)
        ]);
        const labelRightKls = computed(() => [
          ns.e("label"),
          ns.em("label", "right"),
          ns.is("active", checked.value)
        ]);
        const coreStyle = computed(() => ({
          width: addUnit(props.width)
        }));
        watch(() => props.modelValue, () => {
          isControlled.value = true;
        });
        watch(() => props.value, () => {
          isControlled.value = false;
        });
        const actualValue = computed(() => {
          return isControlled.value ? props.modelValue : props.value;
        });
        const checked = computed(() => actualValue.value === props.activeValue);
        if (![props.activeValue, props.inactiveValue].includes(actualValue.value)) {
          emit2(UPDATE_MODEL_EVENT, props.inactiveValue);
          emit2(CHANGE_EVENT, props.inactiveValue);
          emit2(INPUT_EVENT, props.inactiveValue);
        }
        watch(checked, (val) => {
          var _a2;
          input.value.checked = val;
          if (props.validateEvent) {
            (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
          }
        });
        const handleChange = () => {
          const val = checked.value ? props.inactiveValue : props.activeValue;
          emit2(UPDATE_MODEL_EVENT, val);
          emit2(CHANGE_EVENT, val);
          emit2(INPUT_EVENT, val);
          nextTick(() => {
            input.value.checked = checked.value;
          });
        };
        const switchValue = () => {
          if (switchDisabled.value)
            return;
          const { beforeChange } = props;
          if (!beforeChange) {
            handleChange();
            return;
          }
          const shouldChange = beforeChange();
          const isPromiseOrBool = [
            isPromise(shouldChange),
            isBoolean$1(shouldChange)
          ].includes(true);
          if (!isPromiseOrBool) {
            throwError(COMPONENT_NAME$1, "beforeChange must return type `Promise<boolean>` or `boolean`");
          }
          if (isPromise(shouldChange)) {
            shouldChange.then((result) => {
              if (result) {
                handleChange();
              }
            }).catch((e3) => {
            });
          } else if (shouldChange) {
            handleChange();
          }
        };
        const styles = computed(() => {
          return ns.cssVarBlock(__spreadValues(__spreadValues(__spreadValues({}, props.activeColor ? { "on-color": props.activeColor } : null), props.inactiveColor ? { "off-color": props.inactiveColor } : null), props.borderColor ? { "border-color": props.borderColor } : null));
        });
        const focus = () => {
          var _a2, _b;
          (_b = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b.call(_a2);
        };
        onMounted(() => {
          input.value.checked = checked.value;
        });
        expose({
          focus,
          checked
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(unref(switchKls)),
            style: normalizeStyle(unref(styles)),
            onClick: withModifiers(switchValue, ["prevent"])
          }, [
            createBaseVNode("input", {
              id: unref(inputId),
              ref_key: "input",
              ref: input,
              class: normalizeClass(unref(ns).e("input")),
              type: "checkbox",
              role: "switch",
              "aria-checked": unref(checked),
              "aria-disabled": unref(switchDisabled),
              name: _ctx.name,
              "true-value": _ctx.activeValue,
              "false-value": _ctx.inactiveValue,
              disabled: unref(switchDisabled),
              tabindex: _ctx.tabindex,
              onChange: handleChange,
              onKeydown: withKeys(switchValue, ["enter"])
            }, null, 42, _hoisted_2$6),
            !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(labelLeftKls))
            }, [
              _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                key: 1,
                "aria-hidden": unref(checked)
              }, toDisplayString(_ctx.inactiveText), 9, _hoisted_3$4)) : createCommentVNode("v-if", true)
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("span", {
              ref_key: "core",
              ref: core,
              class: normalizeClass(unref(ns).e("core")),
              style: normalizeStyle(unref(coreStyle))
            }, [
              _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(ns).e("inner"))
              }, [
                _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns).is("icon"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(checked) ? _ctx.activeIcon : _ctx.inactiveIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : _ctx.activeText || _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass(unref(ns).is("text")),
                  "aria-hidden": !unref(checked)
                }, toDisplayString(unref(checked) ? _ctx.activeText : _ctx.inactiveText), 11, _hoisted_4$3)) : createCommentVNode("v-if", true)
              ], 2)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(ns).e("action"))
              }, [
                _ctx.loading ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(ns).is("loading"))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(loading_default))
                  ]),
                  _: 1
                }, 8, ["class"])) : _ctx.activeActionIcon && unref(checked) ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeActionIcon)))
                  ]),
                  _: 1
                })) : _ctx.inactiveActionIcon && !unref(checked) ? (openBlock(), createBlock(unref(ElIcon), { key: 2 }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveActionIcon)))
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true)
              ], 2)
            ], 6),
            !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(unref(labelRightKls))
            }, [
              _ctx.activeIcon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
                key: 1,
                "aria-hidden": !unref(checked)
              }, toDisplayString(_ctx.activeText), 9, _hoisted_5$3)) : createCommentVNode("v-if", true)
            ], 2)) : createCommentVNode("v-if", true)
          ], 14, _hoisted_1$7);
        };
      }
    }));
    var Switch = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
    const ElSwitch = withInstall(Switch);
    const uploadContextKey = Symbol("uploadContextKey");
    const SCOPE$1 = "ElUpload";
    class UploadAjaxError extends Error {
      constructor(message2, status, method, url) {
        super(message2);
        this.name = "UploadAjaxError";
        this.status = status;
        this.method = method;
        this.url = url;
      }
    }
    function getError(action, option, xhr) {
      let msg;
      if (xhr.response) {
        msg = `${xhr.response.error || xhr.response}`;
      } else if (xhr.responseText) {
        msg = `${xhr.responseText}`;
      } else {
        msg = `fail to ${option.method} ${action} ${xhr.status}`;
      }
      return new UploadAjaxError(msg, xhr.status, option.method, action);
    }
    function getBody(xhr) {
      const text = xhr.responseText || xhr.response;
      if (!text) {
        return text;
      }
      try {
        return JSON.parse(text);
      } catch (e3) {
        return text;
      }
    }
    const ajaxUpload = (option) => {
      if (typeof XMLHttpRequest === "undefined")
        throwError(SCOPE$1, "XMLHttpRequest is undefined");
      const xhr = new XMLHttpRequest();
      const action = option.action;
      if (xhr.upload) {
        xhr.upload.addEventListener("progress", (evt) => {
          const progressEvt = evt;
          progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
          option.onProgress(progressEvt);
        });
      }
      const formData = new FormData();
      if (option.data) {
        for (const [key, value] of Object.entries(option.data)) {
          if (Array.isArray(value))
            formData.append(key, ...value);
          else
            formData.append(key, value);
        }
      }
      formData.append(option.filename, option.file, option.file.name);
      xhr.addEventListener("error", () => {
        option.onError(getError(action, option, xhr));
      });
      xhr.addEventListener("load", () => {
        if (xhr.status < 200 || xhr.status >= 300) {
          return option.onError(getError(action, option, xhr));
        }
        option.onSuccess(getBody(xhr));
      });
      xhr.open(option.method, action, true);
      if (option.withCredentials && "withCredentials" in xhr) {
        xhr.withCredentials = true;
      }
      const headers = option.headers || {};
      if (headers instanceof Headers) {
        headers.forEach((value, key) => xhr.setRequestHeader(key, value));
      } else {
        for (const [key, value] of Object.entries(headers)) {
          if (isNil(value))
            continue;
          xhr.setRequestHeader(key, String(value));
        }
      }
      xhr.send(formData);
      return xhr;
    };
    const uploadListTypes = ["text", "picture", "picture-card"];
    let fileId = 1;
    const genFileId = () => Date.now() + fileId++;
    const uploadBaseProps = buildProps({
      action: {
        type: String,
        default: "#"
      },
      headers: {
        type: definePropType(Object)
      },
      method: {
        type: String,
        default: "post"
      },
      data: {
        type: Object,
        default: () => mutable({})
      },
      multiple: {
        type: Boolean,
        default: false
      },
      name: {
        type: String,
        default: "file"
      },
      drag: {
        type: Boolean,
        default: false
      },
      withCredentials: Boolean,
      showFileList: {
        type: Boolean,
        default: true
      },
      accept: {
        type: String,
        default: ""
      },
      type: {
        type: String,
        default: "select"
      },
      fileList: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      autoUpload: {
        type: Boolean,
        default: true
      },
      listType: {
        type: String,
        values: uploadListTypes,
        default: "text"
      },
      httpRequest: {
        type: definePropType(Function),
        default: ajaxUpload
      },
      disabled: Boolean,
      limit: Number
    });
    const uploadProps = buildProps(__spreadProps(__spreadValues({}, uploadBaseProps), {
      beforeUpload: {
        type: definePropType(Function),
        default: NOOP
      },
      beforeRemove: {
        type: definePropType(Function)
      },
      onRemove: {
        type: definePropType(Function),
        default: NOOP
      },
      onChange: {
        type: definePropType(Function),
        default: NOOP
      },
      onPreview: {
        type: definePropType(Function),
        default: NOOP
      },
      onSuccess: {
        type: definePropType(Function),
        default: NOOP
      },
      onProgress: {
        type: definePropType(Function),
        default: NOOP
      },
      onError: {
        type: definePropType(Function),
        default: NOOP
      },
      onExceed: {
        type: definePropType(Function),
        default: NOOP
      }
    }));
    const uploadListProps = buildProps({
      files: {
        type: definePropType(Array),
        default: () => mutable([])
      },
      disabled: {
        type: Boolean,
        default: false
      },
      handlePreview: {
        type: definePropType(Function),
        default: NOOP
      },
      listType: {
        type: String,
        values: uploadListTypes,
        default: "text"
      }
    });
    const uploadListEmits = {
      remove: (file) => !!file
    };
    const _hoisted_1$6 = ["onKeydown"];
    const _hoisted_2$5 = ["src"];
    const _hoisted_3$3 = ["onClick"];
    const _hoisted_4$2 = ["title"];
    const _hoisted_5$2 = ["onClick"];
    const _hoisted_6$2 = ["onClick"];
    const __default__$4 = defineComponent({
      name: "ElUploadList"
    });
    const _sfc_main$7 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$4), {
      props: uploadListProps,
      emits: uploadListEmits,
      setup(__props, { emit: emit2 }) {
        const { t } = useLocale();
        const nsUpload = useNamespace("upload");
        const nsIcon = useNamespace("icon");
        const nsList = useNamespace("list");
        const disabled = useFormDisabled();
        const focusing = ref(false);
        const handleRemove = (file) => {
          emit2("remove", file);
        };
        return (_ctx, _cache) => {
          return openBlock(), createBlock(TransitionGroup, {
            tag: "ul",
            class: normalizeClass([
              unref(nsUpload).b("list"),
              unref(nsUpload).bm("list", _ctx.listType),
              unref(nsUpload).is("disabled", unref(disabled))
            ]),
            name: unref(nsList).b()
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file) => {
                return openBlock(), createElementBlock("li", {
                  key: file.uid || file.name,
                  class: normalizeClass([
                    unref(nsUpload).be("list", "item"),
                    unref(nsUpload).is(file.status),
                    { focusing: focusing.value }
                  ]),
                  tabindex: "0",
                  onKeydown: withKeys(($event) => !unref(disabled) && handleRemove(file), ["delete"]),
                  onFocus: _cache[0] || (_cache[0] = ($event) => focusing.value = true),
                  onBlur: _cache[1] || (_cache[1] = ($event) => focusing.value = false),
                  onClick: _cache[2] || (_cache[2] = ($event) => focusing.value = false)
                }, [
                  renderSlot(_ctx.$slots, "default", { file }, () => [
                    _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("img", {
                      key: 0,
                      class: normalizeClass(unref(nsUpload).be("list", "item-thumbnail")),
                      src: file.url,
                      alt: ""
                    }, null, 10, _hoisted_2$5)) : createCommentVNode("v-if", true),
                    file.status === "uploading" || _ctx.listType !== "picture-card" ? (openBlock(), createElementBlock("div", {
                      key: 1,
                      class: normalizeClass(unref(nsUpload).be("list", "item-info"))
                    }, [
                      createBaseVNode("a", {
                        class: normalizeClass(unref(nsUpload).be("list", "item-name")),
                        onClick: withModifiers(($event) => _ctx.handlePreview(file), ["prevent"])
                      }, [
                        createVNode(unref(ElIcon), {
                          class: normalizeClass(unref(nsIcon).m("document"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(document_default))
                          ]),
                          _: 1
                        }, 8, ["class"]),
                        createBaseVNode("span", {
                          class: normalizeClass(unref(nsUpload).be("list", "item-file-name")),
                          title: file.name
                        }, toDisplayString(file.name), 11, _hoisted_4$2)
                      ], 10, _hoisted_3$3),
                      file.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                        key: 0,
                        type: _ctx.listType === "picture-card" ? "circle" : "line",
                        "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                        percentage: Number(file.percentage),
                        style: normalizeStyle(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                      }, null, 8, ["type", "stroke-width", "percentage", "style"])) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true),
                    createBaseVNode("label", {
                      class: normalizeClass(unref(nsUpload).be("list", "item-status-label"))
                    }, [
                      _ctx.listType === "text" ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 0,
                        class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("circle-check")])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(circle_check_default))
                        ]),
                        _: 1
                      }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createBlock(unref(ElIcon), {
                        key: 1,
                        class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("check")])
                      }, {
                        default: withCtx(() => [
                          createVNode(unref(check_default))
                        ]),
                        _: 1
                      }, 8, ["class"])) : createCommentVNode("v-if", true)
                    ], 2),
                    !unref(disabled) ? (openBlock(), createBlock(unref(ElIcon), {
                      key: 2,
                      class: normalizeClass(unref(nsIcon).m("close")),
                      onClick: ($event) => handleRemove(file)
                    }, {
                      default: withCtx(() => [
                        createVNode(unref(close_default))
                      ]),
                      _: 2
                    }, 1032, ["class", "onClick"])) : createCommentVNode("v-if", true),
                    createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                    createCommentVNode(" This is a bug which needs to be fixed "),
                    createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                    !unref(disabled) ? (openBlock(), createElementBlock("i", {
                      key: 3,
                      class: normalizeClass(unref(nsIcon).m("close-tip"))
                    }, toDisplayString(unref(t)("el.upload.deleteTip")), 3)) : createCommentVNode("v-if", true),
                    _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", {
                      key: 4,
                      class: normalizeClass(unref(nsUpload).be("list", "item-actions"))
                    }, [
                      createBaseVNode("span", {
                        class: normalizeClass(unref(nsUpload).be("list", "item-preview")),
                        onClick: ($event) => _ctx.handlePreview(file)
                      }, [
                        createVNode(unref(ElIcon), {
                          class: normalizeClass(unref(nsIcon).m("zoom-in"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(zoom_in_default))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, _hoisted_5$2),
                      !unref(disabled) ? (openBlock(), createElementBlock("span", {
                        key: 0,
                        class: normalizeClass(unref(nsUpload).be("list", "item-delete")),
                        onClick: ($event) => handleRemove(file)
                      }, [
                        createVNode(unref(ElIcon), {
                          class: normalizeClass(unref(nsIcon).m("delete"))
                        }, {
                          default: withCtx(() => [
                            createVNode(unref(delete_default))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 10, _hoisted_6$2)) : createCommentVNode("v-if", true)
                    ], 2)) : createCommentVNode("v-if", true)
                  ])
                ], 42, _hoisted_1$6);
              }), 128)),
              renderSlot(_ctx.$slots, "append")
            ]),
            _: 3
          }, 8, ["class", "name"]);
        };
      }
    }));
    var UploadList = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
    const uploadDraggerProps = buildProps({
      disabled: {
        type: Boolean,
        default: false
      }
    });
    const uploadDraggerEmits = {
      file: (file) => isArray$3(file)
    };
    const _hoisted_1$5 = ["onDrop", "onDragover"];
    const COMPONENT_NAME = "ElUploadDrag";
    const __default__$3 = defineComponent({
      name: COMPONENT_NAME
    });
    const _sfc_main$6 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$3), {
      props: uploadDraggerProps,
      emits: uploadDraggerEmits,
      setup(__props, { emit: emit2 }) {
        const uploaderContext = inject(uploadContextKey);
        if (!uploaderContext) {
          throwError(COMPONENT_NAME, "usage: <el-upload><el-upload-dragger /></el-upload>");
        }
        const ns = useNamespace("upload");
        const dragover = ref(false);
        const disabled = useFormDisabled();
        const onDrop = (e3) => {
          if (disabled.value)
            return;
          dragover.value = false;
          e3.stopPropagation();
          const files = Array.from(e3.dataTransfer.files);
          const accept = uploaderContext.accept.value;
          if (!accept) {
            emit2("file", files);
            return;
          }
          const filesFiltered = files.filter((file) => {
            const { type, name } = file;
            const extension = name.includes(".") ? `.${name.split(".").pop()}` : "";
            const baseType = type.replace(/\/.*$/, "");
            return accept.split(",").map((type2) => type2.trim()).filter((type2) => type2).some((acceptedType) => {
              if (acceptedType.startsWith(".")) {
                return extension === acceptedType;
              }
              if (/\/\*$/.test(acceptedType)) {
                return baseType === acceptedType.replace(/\/\*$/, "");
              }
              if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
                return type === acceptedType;
              }
              return false;
            });
          });
          emit2("file", filesFiltered);
        };
        const onDragover = () => {
          if (!disabled.value)
            dragover.value = true;
        };
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns).b("dragger"), unref(ns).is("dragover", dragover.value)]),
            onDrop: withModifiers(onDrop, ["prevent"]),
            onDragover: withModifiers(onDragover, ["prevent"]),
            onDragleave: _cache[0] || (_cache[0] = withModifiers(($event) => dragover.value = false, ["prevent"]))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 42, _hoisted_1$5);
        };
      }
    }));
    var UploadDragger = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
    const uploadContentProps = buildProps(__spreadProps(__spreadValues({}, uploadBaseProps), {
      beforeUpload: {
        type: definePropType(Function),
        default: NOOP
      },
      onRemove: {
        type: definePropType(Function),
        default: NOOP
      },
      onStart: {
        type: definePropType(Function),
        default: NOOP
      },
      onSuccess: {
        type: definePropType(Function),
        default: NOOP
      },
      onProgress: {
        type: definePropType(Function),
        default: NOOP
      },
      onError: {
        type: definePropType(Function),
        default: NOOP
      },
      onExceed: {
        type: definePropType(Function),
        default: NOOP
      }
    }));
    const _hoisted_1$4 = ["onKeydown"];
    const _hoisted_2$4 = ["name", "multiple", "accept"];
    const __default__$2 = defineComponent({
      name: "ElUploadContent",
      inheritAttrs: false
    });
    const _sfc_main$5 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$2), {
      props: uploadContentProps,
      setup(__props, { expose }) {
        const props = __props;
        const ns = useNamespace("upload");
        const disabled = useFormDisabled();
        const requests = shallowRef({});
        const inputRef = shallowRef();
        const uploadFiles = (files) => {
          if (files.length === 0)
            return;
          const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props;
          if (limit && fileList.length + files.length > limit) {
            onExceed(files, fileList);
            return;
          }
          if (!multiple) {
            files = files.slice(0, 1);
          }
          for (const file of files) {
            const rawFile = file;
            rawFile.uid = genFileId();
            onStart(rawFile);
            if (autoUpload)
              upload(rawFile);
          }
        };
        const upload = (rawFile) => __async(this, null, function* () {
          inputRef.value.value = "";
          if (!props.beforeUpload) {
            return doUpload(rawFile);
          }
          let hookResult;
          let beforeData = {};
          try {
            const originData = props.data;
            const beforeUploadPromise = props.beforeUpload(rawFile);
            beforeData = isObject$2(props.data) ? cloneDeep(props.data) : props.data;
            hookResult = yield beforeUploadPromise;
            if (isObject$2(props.data) && isEqual(originData, beforeData)) {
              beforeData = cloneDeep(props.data);
            }
          } catch (e3) {
            hookResult = false;
          }
          if (hookResult === false) {
            props.onRemove(rawFile);
            return;
          }
          let file = rawFile;
          if (hookResult instanceof Blob) {
            if (hookResult instanceof File) {
              file = hookResult;
            } else {
              file = new File([hookResult], rawFile.name, {
                type: rawFile.type
              });
            }
          }
          doUpload(Object.assign(file, {
            uid: rawFile.uid
          }), beforeData);
        });
        const doUpload = (rawFile, beforeData) => {
          const {
            headers,
            data,
            method,
            withCredentials,
            name: filename,
            action,
            onProgress,
            onSuccess,
            onError,
            httpRequest
          } = props;
          const { uid: uid2 } = rawFile;
          const options = {
            headers: headers || {},
            withCredentials,
            file: rawFile,
            data: beforeData != null ? beforeData : data,
            method,
            filename,
            action,
            onProgress: (evt) => {
              onProgress(evt, rawFile);
            },
            onSuccess: (res) => {
              onSuccess(res, rawFile);
              delete requests.value[uid2];
            },
            onError: (err) => {
              onError(err, rawFile);
              delete requests.value[uid2];
            }
          };
          const request2 = httpRequest(options);
          requests.value[uid2] = request2;
          if (request2 instanceof Promise) {
            request2.then(options.onSuccess, options.onError);
          }
        };
        const handleChange = (e3) => {
          const files = e3.target.files;
          if (!files)
            return;
          uploadFiles(Array.from(files));
        };
        const handleClick = () => {
          if (!disabled.value) {
            inputRef.value.value = "";
            inputRef.value.click();
          }
        };
        const handleKeydown = () => {
          handleClick();
        };
        const abort = (file) => {
          const _reqs = entriesOf(requests.value).filter(file ? ([uid2]) => String(file.uid) === uid2 : () => true);
          _reqs.forEach(([uid2, req]) => {
            if (req instanceof XMLHttpRequest)
              req.abort();
            delete requests.value[uid2];
          });
        };
        expose({
          abort,
          upload
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.listType), unref(ns).is("drag", _ctx.drag)]),
            tabindex: "0",
            onClick: handleClick,
            onKeydown: withKeys(withModifiers(handleKeydown, ["self"]), ["enter", "space"])
          }, [
            _ctx.drag ? (openBlock(), createBlock(UploadDragger, {
              key: 0,
              disabled: unref(disabled),
              onFile: uploadFiles
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["disabled"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
            createBaseVNode("input", {
              ref_key: "inputRef",
              ref: inputRef,
              class: normalizeClass(unref(ns).e("input")),
              name: _ctx.name,
              multiple: _ctx.multiple,
              accept: _ctx.accept,
              type: "file",
              onChange: handleChange,
              onClick: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"]))
            }, null, 42, _hoisted_2$4)
          ], 42, _hoisted_1$4);
        };
      }
    }));
    var UploadContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
    const SCOPE = "ElUpload";
    const revokeObjectURL = (file) => {
      var _a2;
      if ((_a2 = file.url) == null ? void 0 : _a2.startsWith("blob:")) {
        URL.revokeObjectURL(file.url);
      }
    };
    const useHandlers = (props, uploadRef) => {
      const uploadFiles = useVModel(props, "fileList", void 0, { passive: true });
      const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
      function abort(file) {
        var _a2;
        (_a2 = uploadRef.value) == null ? void 0 : _a2.abort(file);
      }
      function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
        uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
      }
      const handleError2 = (err, rawFile) => {
        const file = getFile(rawFile);
        if (!file)
          return;
        console.error(err);
        file.status = "fail";
        uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
        props.onError(err, file, uploadFiles.value);
        props.onChange(file, uploadFiles.value);
      };
      const handleProgress = (evt, rawFile) => {
        const file = getFile(rawFile);
        if (!file)
          return;
        props.onProgress(evt, file, uploadFiles.value);
        file.status = "uploading";
        file.percentage = Math.round(evt.percent);
      };
      const handleSuccess = (response, rawFile) => {
        const file = getFile(rawFile);
        if (!file)
          return;
        file.status = "success";
        file.response = response;
        props.onSuccess(response, file, uploadFiles.value);
        props.onChange(file, uploadFiles.value);
      };
      const handleStart = (file) => {
        if (isNil(file.uid))
          file.uid = genFileId();
        const uploadFile = {
          name: file.name,
          percentage: 0,
          status: "ready",
          size: file.size,
          raw: file,
          uid: file.uid
        };
        if (props.listType === "picture-card" || props.listType === "picture") {
          try {
            uploadFile.url = URL.createObjectURL(file);
          } catch (err) {
            debugWarn(SCOPE, err.message);
            props.onError(err, uploadFile, uploadFiles.value);
          }
        }
        uploadFiles.value = [...uploadFiles.value, uploadFile];
        props.onChange(uploadFile, uploadFiles.value);
      };
      const handleRemove = (file) => __async(exports, null, function* () {
        const uploadFile = file instanceof File ? getFile(file) : file;
        if (!uploadFile)
          throwError(SCOPE, "file to be removed not found");
        const doRemove = (file2) => {
          abort(file2);
          const fileList = uploadFiles.value;
          fileList.splice(fileList.indexOf(file2), 1);
          props.onRemove(file2, fileList);
          revokeObjectURL(file2);
        };
        if (props.beforeRemove) {
          const before = yield props.beforeRemove(uploadFile, uploadFiles.value);
          if (before !== false)
            doRemove(uploadFile);
        } else {
          doRemove(uploadFile);
        }
      });
      function submit() {
        uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
          var _a2;
          return raw && ((_a2 = uploadRef.value) == null ? void 0 : _a2.upload(raw));
        });
      }
      watch(() => props.listType, (val) => {
        if (val !== "picture-card" && val !== "picture") {
          return;
        }
        uploadFiles.value = uploadFiles.value.map((file) => {
          const { raw, url } = file;
          if (!url && raw) {
            try {
              file.url = URL.createObjectURL(raw);
            } catch (err) {
              props.onError(err, file, uploadFiles.value);
            }
          }
          return file;
        });
      });
      watch(uploadFiles, (files) => {
        for (const file of files) {
          file.uid || (file.uid = genFileId());
          file.status || (file.status = "success");
        }
      }, { immediate: true, deep: true });
      return {
        uploadFiles,
        abort,
        clearFiles,
        handleError: handleError2,
        handleProgress,
        handleStart,
        handleSuccess,
        handleRemove,
        submit
      };
    };
    const __default__$1 = defineComponent({
      name: "ElUpload"
    });
    const _sfc_main$4 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$1), {
      props: uploadProps,
      setup(__props, { expose }) {
        const props = __props;
        const slots = useSlots();
        const disabled = useFormDisabled();
        const uploadRef = shallowRef();
        const {
          abort,
          submit,
          clearFiles,
          uploadFiles,
          handleStart,
          handleError: handleError2,
          handleRemove,
          handleSuccess,
          handleProgress
        } = useHandlers(props, uploadRef);
        const isPictureCard = computed(() => props.listType === "picture-card");
        const uploadContentProps2 = computed(() => __spreadProps(__spreadValues({}, props), {
          fileList: uploadFiles.value,
          onStart: handleStart,
          onProgress: handleProgress,
          onSuccess: handleSuccess,
          onError: handleError2,
          onRemove: handleRemove
        }));
        onBeforeUnmount(() => {
          uploadFiles.value.forEach(({ url }) => {
            if (url == null ? void 0 : url.startsWith("blob:"))
              URL.revokeObjectURL(url);
          });
        });
        provide(uploadContextKey, {
          accept: toRef(props, "accept")
        });
        expose({
          abort,
          submit,
          clearFiles,
          handleStart,
          handleRemove
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", null, [
            unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
              key: 0,
              disabled: unref(disabled),
              "list-type": _ctx.listType,
              files: unref(uploadFiles),
              "handle-preview": _ctx.onPreview,
              onRemove: unref(handleRemove)
            }, createSlots({
              append: withCtx(() => [
                createVNode(UploadContent, mergeProps({
                  ref_key: "uploadRef",
                  ref: uploadRef
                }, unref(uploadContentProps2)), {
                  default: withCtx(() => [
                    unref(slots).trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                    !unref(slots).trigger && unref(slots).default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
                  ]),
                  _: 3
                }, 16)
              ]),
              _: 2
            }, [
              _ctx.$slots.file ? {
                name: "default",
                fn: withCtx(({ file }) => [
                  renderSlot(_ctx.$slots, "file", { file })
                ])
              } : void 0
            ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true),
            !unref(isPictureCard) || unref(isPictureCard) && !_ctx.showFileList ? (openBlock(), createBlock(UploadContent, mergeProps({
              key: 1,
              ref_key: "uploadRef",
              ref: uploadRef
            }, unref(uploadContentProps2)), {
              default: withCtx(() => [
                unref(slots).trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                !unref(slots).trigger && unref(slots).default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16)) : createCommentVNode("v-if", true),
            _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "tip"),
            !unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
              key: 3,
              disabled: unref(disabled),
              "list-type": _ctx.listType,
              files: unref(uploadFiles),
              "handle-preview": _ctx.onPreview,
              onRemove: unref(handleRemove)
            }, createSlots({ _: 2 }, [
              _ctx.$slots.file ? {
                name: "default",
                fn: withCtx(({ file }) => [
                  renderSlot(_ctx.$slots, "file", { file })
                ])
              } : void 0
            ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true)
          ]);
        };
      }
    }));
    var Upload = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
    const ElUpload = withInstall(Upload);
    function createLoadingComponent(options) {
      let afterLeaveTimer;
      const afterLeaveFlag = ref(false);
      const data = reactive(__spreadProps(__spreadValues({}, options), {
        originalPosition: "",
        originalOverflow: "",
        visible: false
      }));
      function setText(text) {
        data.text = text;
      }
      function destroySelf() {
        const target = data.parent;
        const ns = vm.ns;
        if (!target.vLoadingAddClassList) {
          let loadingNumber = target.getAttribute("loading-number");
          loadingNumber = Number.parseInt(loadingNumber) - 1;
          if (!loadingNumber) {
            removeClass(target, ns.bm("parent", "relative"));
            target.removeAttribute("loading-number");
          } else {
            target.setAttribute("loading-number", loadingNumber.toString());
          }
          removeClass(target, ns.bm("parent", "hidden"));
        }
        removeElLoadingChild();
        loadingInstance.unmount();
      }
      function removeElLoadingChild() {
        var _a2, _b;
        (_b = (_a2 = vm.$el) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(vm.$el);
      }
      function close() {
        var _a2;
        if (options.beforeClose && !options.beforeClose())
          return;
        afterLeaveFlag.value = true;
        clearTimeout(afterLeaveTimer);
        afterLeaveTimer = window.setTimeout(handleAfterLeave, 400);
        data.visible = false;
        (_a2 = options.closed) == null ? void 0 : _a2.call(options);
      }
      function handleAfterLeave() {
        if (!afterLeaveFlag.value)
          return;
        const target = data.parent;
        afterLeaveFlag.value = false;
        target.vLoadingAddClassList = void 0;
        destroySelf();
      }
      const elLoadingComponent = defineComponent({
        name: "ElLoading",
        setup(_, { expose }) {
          const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("loading");
          expose({
            ns,
            zIndex: zIndex2
          });
          return () => {
            const svg = data.spinner || data.svg;
            const spinner = h("svg", __spreadValues({
              class: "circular",
              viewBox: data.svgViewBox ? data.svgViewBox : "0 0 50 50"
            }, svg ? { innerHTML: svg } : {}), [
              h("circle", {
                class: "path",
                cx: "25",
                cy: "25",
                r: "20",
                fill: "none"
              })
            ]);
            const spinnerText = data.text ? h("p", { class: ns.b("text") }, [data.text]) : void 0;
            return h(Transition$1, {
              name: ns.b("fade"),
              onAfterLeave: handleAfterLeave
            }, {
              default: withCtx(() => [
                withDirectives(createVNode("div", {
                  style: {
                    backgroundColor: data.background || ""
                  },
                  class: [
                    ns.b("mask"),
                    data.customClass,
                    data.fullscreen ? "is-fullscreen" : ""
                  ]
                }, [
                  h("div", {
                    class: ns.b("spinner")
                  }, [spinner, spinnerText])
                ]), [[vShow, data.visible]])
              ])
            });
          };
        }
      });
      const loadingInstance = createApp(elLoadingComponent);
      const vm = loadingInstance.mount(document.createElement("div"));
      return __spreadProps(__spreadValues({}, toRefs(data)), {
        setText,
        removeElLoadingChild,
        close,
        handleAfterLeave,
        vm,
        get $el() {
          return vm.$el;
        }
      });
    }
    let fullscreenInstance = void 0;
    const Loading = function(options = {}) {
      if (!isClient)
        return void 0;
      const resolved = resolveOptions(options);
      if (resolved.fullscreen && fullscreenInstance) {
        return fullscreenInstance;
      }
      const instance = createLoadingComponent(__spreadProps(__spreadValues({}, resolved), {
        closed: () => {
          var _a2;
          (_a2 = resolved.closed) == null ? void 0 : _a2.call(resolved);
          if (resolved.fullscreen)
            fullscreenInstance = void 0;
        }
      }));
      addStyle(resolved, resolved.parent, instance);
      addClassList(resolved, resolved.parent, instance);
      resolved.parent.vLoadingAddClassList = () => addClassList(resolved, resolved.parent, instance);
      let loadingNumber = resolved.parent.getAttribute("loading-number");
      if (!loadingNumber) {
        loadingNumber = "1";
      } else {
        loadingNumber = `${Number.parseInt(loadingNumber) + 1}`;
      }
      resolved.parent.setAttribute("loading-number", loadingNumber);
      resolved.parent.appendChild(instance.$el);
      nextTick(() => instance.visible.value = resolved.visible);
      if (resolved.fullscreen) {
        fullscreenInstance = instance;
      }
      return instance;
    };
    const resolveOptions = (options) => {
      var _a2, _b, _c, _d;
      let target;
      if (isString$2(options.target)) {
        target = (_a2 = document.querySelector(options.target)) != null ? _a2 : document.body;
      } else {
        target = options.target || document.body;
      }
      return {
        parent: target === document.body || options.body ? document.body : target,
        background: options.background || "",
        svg: options.svg || "",
        svgViewBox: options.svgViewBox || "",
        spinner: options.spinner || false,
        text: options.text || "",
        fullscreen: target === document.body && ((_b = options.fullscreen) != null ? _b : true),
        lock: (_c = options.lock) != null ? _c : false,
        customClass: options.customClass || "",
        visible: (_d = options.visible) != null ? _d : true,
        target
      };
    };
    const addStyle = (options, parent, instance) => __async(exports, null, function* () {
      const { nextZIndex } = instance.vm.zIndex || instance.vm._.exposed.zIndex;
      const maskStyle = {};
      if (options.fullscreen) {
        instance.originalPosition.value = getStyle(document.body, "position");
        instance.originalOverflow.value = getStyle(document.body, "overflow");
        maskStyle.zIndex = nextZIndex();
      } else if (options.parent === document.body) {
        instance.originalPosition.value = getStyle(document.body, "position");
        yield nextTick();
        for (const property of ["top", "left"]) {
          const scroll = property === "top" ? "scrollTop" : "scrollLeft";
          maskStyle[property] = `${options.target.getBoundingClientRect()[property] + document.body[scroll] + document.documentElement[scroll] - Number.parseInt(getStyle(document.body, `margin-${property}`), 10)}px`;
        }
        for (const property of ["height", "width"]) {
          maskStyle[property] = `${options.target.getBoundingClientRect()[property]}px`;
        }
      } else {
        instance.originalPosition.value = getStyle(parent, "position");
      }
      for (const [key, value] of Object.entries(maskStyle)) {
        instance.$el.style[key] = value;
      }
    });
    const addClassList = (options, parent, instance) => {
      const ns = instance.vm.ns || instance.vm._.exposed.ns;
      if (!["absolute", "fixed", "sticky"].includes(instance.originalPosition.value)) {
        addClass(parent, ns.bm("parent", "relative"));
      } else {
        removeClass(parent, ns.bm("parent", "relative"));
      }
      if (options.fullscreen && options.lock) {
        addClass(parent, ns.bm("parent", "hidden"));
      } else {
        removeClass(parent, ns.bm("parent", "hidden"));
      }
    };
    const INSTANCE_KEY = Symbol("ElLoading");
    const createInstance$1 = (el, binding) => {
      var _a2, _b, _c, _d;
      const vm = binding.instance;
      const getBindingProp = (key) => isObject$2(binding.value) ? binding.value[key] : void 0;
      const resolveExpression = (key) => {
        const data = isString$2(key) && (vm == null ? void 0 : vm[key]) || key;
        if (data)
          return ref(data);
        else
          return data;
      };
      const getProp = (name) => resolveExpression(getBindingProp(name) || el.getAttribute(`element-loading-${hyphenate(name)}`));
      const fullscreen = (_a2 = getBindingProp("fullscreen")) != null ? _a2 : binding.modifiers.fullscreen;
      const options = {
        text: getProp("text"),
        svg: getProp("svg"),
        svgViewBox: getProp("svgViewBox"),
        spinner: getProp("spinner"),
        background: getProp("background"),
        customClass: getProp("customClass"),
        fullscreen,
        target: (_b = getBindingProp("target")) != null ? _b : fullscreen ? void 0 : el,
        body: (_c = getBindingProp("body")) != null ? _c : binding.modifiers.body,
        lock: (_d = getBindingProp("lock")) != null ? _d : binding.modifiers.lock
      };
      el[INSTANCE_KEY] = {
        options,
        instance: Loading(options)
      };
    };
    const updateOptions = (newOptions, originalOptions) => {
      for (const key of Object.keys(originalOptions)) {
        if (isRef(originalOptions[key]))
          originalOptions[key].value = newOptions[key];
      }
    };
    const vLoading = {
      mounted(el, binding) {
        if (binding.value) {
          createInstance$1(el, binding);
        }
      },
      updated(el, binding) {
        const instance = el[INSTANCE_KEY];
        if (binding.oldValue !== binding.value) {
          if (binding.value && !binding.oldValue) {
            createInstance$1(el, binding);
          } else if (binding.value && binding.oldValue) {
            if (isObject$2(binding.value))
              updateOptions(binding.value, instance.options);
          } else {
            instance == null ? void 0 : instance.instance.close();
          }
        }
      },
      unmounted(el) {
        var _a2;
        (_a2 = el[INSTANCE_KEY]) == null ? void 0 : _a2.instance.close();
      }
    };
    const messageTypes = ["success", "info", "warning", "error"];
    const messageDefaults = mutable({
      customClass: "",
      center: false,
      dangerouslyUseHTMLString: false,
      duration: 3e3,
      icon: void 0,
      id: "",
      message: "",
      onClose: void 0,
      showClose: false,
      type: "info",
      offset: 16,
      zIndex: 0,
      grouping: false,
      repeatNum: 1,
      appendTo: isClient ? document.body : void 0
    });
    const messageProps = buildProps({
      customClass: {
        type: String,
        default: messageDefaults.customClass
      },
      center: {
        type: Boolean,
        default: messageDefaults.center
      },
      dangerouslyUseHTMLString: {
        type: Boolean,
        default: messageDefaults.dangerouslyUseHTMLString
      },
      duration: {
        type: Number,
        default: messageDefaults.duration
      },
      icon: {
        type: iconPropType,
        default: messageDefaults.icon
      },
      id: {
        type: String,
        default: messageDefaults.id
      },
      message: {
        type: definePropType([
          String,
          Object,
          Function
        ]),
        default: messageDefaults.message
      },
      onClose: {
        type: definePropType(Function),
        required: false
      },
      showClose: {
        type: Boolean,
        default: messageDefaults.showClose
      },
      type: {
        type: String,
        values: messageTypes,
        default: messageDefaults.type
      },
      offset: {
        type: Number,
        default: messageDefaults.offset
      },
      zIndex: {
        type: Number,
        default: messageDefaults.zIndex
      },
      grouping: {
        type: Boolean,
        default: messageDefaults.grouping
      },
      repeatNum: {
        type: Number,
        default: messageDefaults.repeatNum
      }
    });
    const messageEmits = {
      destroy: () => true
    };
    const instances = shallowReactive([]);
    const getInstance = (id2) => {
      const idx = instances.findIndex((instance) => instance.id === id2);
      const current = instances[idx];
      let prev;
      if (idx > 0) {
        prev = instances[idx - 1];
      }
      return { current, prev };
    };
    const getLastOffset = (id2) => {
      const { prev } = getInstance(id2);
      if (!prev)
        return 0;
      return prev.vm.exposed.bottom.value;
    };
    const getOffsetOrSpace = (id2, offset) => {
      const idx = instances.findIndex((instance) => instance.id === id2);
      return idx > 0 ? 20 : offset;
    };
    const _hoisted_1$3 = ["id"];
    const _hoisted_2$3 = ["innerHTML"];
    const __default__ = defineComponent({
      name: "ElMessage"
    });
    const _sfc_main$3 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__), {
      props: messageProps,
      emits: messageEmits,
      setup(__props, { expose }) {
        const props = __props;
        const { Close } = TypeComponents;
        const { ns, zIndex: zIndex2 } = useGlobalComponentSettings("message");
        const { currentZIndex, nextZIndex } = zIndex2;
        const messageRef = ref();
        const visible = ref(false);
        const height = ref(0);
        let stopTimer = void 0;
        const badgeType = computed(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
        const typeClass = computed(() => {
          const type = props.type;
          return { [ns.bm("icon", type)]: type && TypeComponentsMap[type] };
        });
        const iconComponent = computed(() => props.icon || TypeComponentsMap[props.type] || "");
        const lastOffset = computed(() => getLastOffset(props.id));
        const offset = computed(() => getOffsetOrSpace(props.id, props.offset) + lastOffset.value);
        const bottom = computed(() => height.value + offset.value);
        const customStyle = computed(() => ({
          top: `${offset.value}px`,
          zIndex: currentZIndex.value
        }));
        function startTimer() {
          if (props.duration === 0)
            return;
          ({ stop: stopTimer } = useTimeoutFn(() => {
            close();
          }, props.duration));
        }
        function clearTimer() {
          stopTimer == null ? void 0 : stopTimer();
        }
        function close() {
          visible.value = false;
        }
        function keydown({ code }) {
          if (code === EVENT_CODE.esc) {
            close();
          }
        }
        onMounted(() => {
          startTimer();
          nextZIndex();
          visible.value = true;
        });
        watch(() => props.repeatNum, () => {
          clearTimer();
          startTimer();
        });
        useEventListener(document, "keydown", keydown);
        useResizeObserver(messageRef, () => {
          height.value = messageRef.value.getBoundingClientRect().height;
        });
        expose({
          visible,
          bottom,
          close
        });
        return (_ctx, _cache) => {
          return openBlock(), createBlock(Transition$1, {
            name: unref(ns).b("fade"),
            onBeforeLeave: _ctx.onClose,
            onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy")),
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                id: _ctx.id,
                ref_key: "messageRef",
                ref: messageRef,
                class: normalizeClass([
                  unref(ns).b(),
                  { [unref(ns).m(_ctx.type)]: _ctx.type && !_ctx.icon },
                  unref(ns).is("center", _ctx.center),
                  unref(ns).is("closable", _ctx.showClose),
                  _ctx.customClass
                ]),
                style: normalizeStyle(unref(customStyle)),
                role: "alert",
                onMouseenter: clearTimer,
                onMouseleave: startTimer
              }, [
                _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref(ElBadge), {
                  key: 0,
                  value: _ctx.repeatNum,
                  type: unref(badgeType),
                  class: normalizeClass(unref(ns).e("badge"))
                }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
                unref(iconComponent) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass([unref(ns).e("icon"), unref(typeClass)])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(iconComponent))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default", {}, () => [
                  !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                    key: 0,
                    class: normalizeClass(unref(ns).e("content"))
                  }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                    createBaseVNode("p", {
                      class: normalizeClass(unref(ns).e("content")),
                      innerHTML: _ctx.message
                    }, null, 10, _hoisted_2$3)
                  ], 2112))
                ]),
                _ctx.showClose ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 2,
                  class: normalizeClass(unref(ns).e("closeBtn")),
                  onClick: withModifiers(close, ["stop"])
                }, {
                  default: withCtx(() => [
                    createVNode(unref(Close))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
              ], 46, _hoisted_1$3), [
                [vShow, visible.value]
              ])
            ]),
            _: 3
          }, 8, ["name", "onBeforeLeave"]);
        };
      }
    }));
    var MessageConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
    let seed = 1;
    const normalizeOptions = (params) => {
      const options = !params || isString$2(params) || isVNode(params) || isFunction$3(params) ? { message: params } : params;
      const normalized = __spreadValues(__spreadValues({}, messageDefaults), options);
      if (!normalized.appendTo) {
        normalized.appendTo = document.body;
      } else if (isString$2(normalized.appendTo)) {
        let appendTo = document.querySelector(normalized.appendTo);
        if (!isElement(appendTo)) {
          appendTo = document.body;
        }
        normalized.appendTo = appendTo;
      }
      return normalized;
    };
    const closeMessage = (instance) => {
      const idx = instances.indexOf(instance);
      if (idx === -1)
        return;
      instances.splice(idx, 1);
      const { handler } = instance;
      handler.close();
    };
    const createMessage = (_a2, context) => {
      var _b = _a2, { appendTo } = _b, options = __objRest(_b, ["appendTo"]);
      const id2 = `message_${seed++}`;
      const userOnClose = options.onClose;
      const container = document.createElement("div");
      const props = __spreadProps(__spreadValues({}, options), {
        id: id2,
        onClose: () => {
          userOnClose == null ? void 0 : userOnClose();
          closeMessage(instance);
        },
        onDestroy: () => {
          render(null, container);
        }
      });
      const vnode = createVNode(MessageConstructor, props, isFunction$3(props.message) || isVNode(props.message) ? {
        default: isFunction$3(props.message) ? props.message : () => props.message
      } : null);
      vnode.appContext = context || message._context;
      render(vnode, container);
      appendTo.appendChild(container.firstElementChild);
      const vm = vnode.component;
      const handler = {
        close: () => {
          vm.exposed.visible.value = false;
        }
      };
      const instance = {
        id: id2,
        vnode,
        vm,
        handler,
        props: vnode.component.props
      };
      return instance;
    };
    const message = (options = {}, context) => {
      if (!isClient)
        return { close: () => void 0 };
      if (isNumber$1(messageConfig.max) && instances.length >= messageConfig.max) {
        return { close: () => void 0 };
      }
      const normalized = normalizeOptions(options);
      if (normalized.grouping && instances.length) {
        const instance2 = instances.find(({ vnode: vm }) => {
          var _a2;
          return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
        });
        if (instance2) {
          instance2.props.repeatNum += 1;
          instance2.props.type = normalized.type;
          return instance2.handler;
        }
      }
      const instance = createMessage(normalized, context);
      instances.push(instance);
      return instance.handler;
    };
    messageTypes.forEach((type) => {
      message[type] = (options = {}, appContext) => {
        const normalized = normalizeOptions(options);
        return message(__spreadProps(__spreadValues({}, normalized), { type }), appContext);
      };
    });
    function closeAll(type) {
      for (const instance of instances) {
        if (!type || type === instance.props.type) {
          instance.handler.close();
        }
      }
    }
    message.closeAll = closeAll;
    message._context = null;
    const ElMessage = withInstallFunction(message, "$message");
    const base = "";
    const elLoading = "";
    const elContainer = "";
    const elAside = "";
    const elFooter = "";
    const elHeader = "";
    const elMain = "";
    const elRow = "";
    const elUpload = "";
    const elProgress = "";
    const elSwitch = "";
    const elButton = "";
    const elAutocomplete = "";
    const elInput = "";
    const elScrollbar = "";
    const elPopper = "";
    const elCol = "";
    const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
    function tickSpec(start2, stop, count) {
      const step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
      let i1, i2, inc;
      if (power < 0) {
        inc = Math.pow(10, -power) / factor;
        i1 = Math.round(start2 * inc);
        i2 = Math.round(stop * inc);
        if (i1 / inc < start2)
          ++i1;
        if (i2 / inc > stop)
          --i2;
        inc = -inc;
      } else {
        inc = Math.pow(10, power) * factor;
        i1 = Math.round(start2 / inc);
        i2 = Math.round(stop / inc);
        if (i1 * inc < start2)
          ++i1;
        if (i2 * inc > stop)
          --i2;
      }
      if (i2 < i1 && 0.5 <= count && count < 2)
        return tickSpec(start2, stop, count * 2);
      return [i1, i2, inc];
    }
    function ticks(start2, stop, count) {
      stop = +stop, start2 = +start2, count = +count;
      if (!(count > 0))
        return [];
      if (start2 === stop)
        return [start2];
      const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count) : tickSpec(start2, stop, count);
      if (!(i2 >= i1))
        return [];
      const n = i2 - i1 + 1, ticks2 = new Array(n);
      if (reverse) {
        if (inc < 0)
          for (let i3 = 0; i3 < n; ++i3)
            ticks2[i3] = (i2 - i3) / -inc;
        else
          for (let i3 = 0; i3 < n; ++i3)
            ticks2[i3] = (i2 - i3) * inc;
      } else {
        if (inc < 0)
          for (let i3 = 0; i3 < n; ++i3)
            ticks2[i3] = (i1 + i3) / -inc;
        else
          for (let i3 = 0; i3 < n; ++i3)
            ticks2[i3] = (i1 + i3) * inc;
      }
      return ticks2;
    }
    function tickIncrement(start2, stop, count) {
      stop = +stop, start2 = +start2, count = +count;
      return tickSpec(start2, stop, count)[2];
    }
    function tickStep(start2, stop, count) {
      stop = +stop, start2 = +start2, count = +count;
      const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count) : tickIncrement(start2, stop, count);
      return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
    }
    var noop$1 = { value: () => {
    } };
    function dispatch() {
      for (var i2 = 0, n = arguments.length, _ = {}, t; i2 < n; ++i2) {
        if (!(t = arguments[i2] + "") || t in _ || /[\s.]/.test(t))
          throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }
    function Dispatch(_) {
      this._ = _;
    }
    function parseTypenames$2(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i2 = t.indexOf(".");
        if (i2 >= 0)
          name = t.slice(i2 + 1), t = t.slice(0, i2);
        if (t && !types.hasOwnProperty(t))
          throw new Error("unknown type: " + t);
        return { type: t, name };
      });
    }
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._, T2 = parseTypenames$2(typename + "", _), t, i2 = -1, n = T2.length;
        if (arguments.length < 2) {
          while (++i2 < n)
            if ((t = (typename = T2[i2]).type) && (t = get$1(_[t], typename.name)))
              return t;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i2 < n) {
          if (t = (typename = T2[i2]).type)
            _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null)
            for (t in _)
              _[t] = set$1(_[t], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy2 = {}, _ = this._;
        for (var t in _)
          copy2[t] = _[t].slice();
        return new Dispatch(copy2);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0)
          for (var args = new Array(n), i2 = 0, n, t; i2 < n; ++i2)
            args[i2] = arguments[i2 + 2];
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (t = this._[type], i2 = 0, n = t.length; i2 < n; ++i2)
          t[i2].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (var t = this._[type], i2 = 0, n = t.length; i2 < n; ++i2)
          t[i2].value.apply(that, args);
      }
    };
    function get$1(type, name) {
      for (var i2 = 0, n = type.length, c2; i2 < n; ++i2) {
        if ((c2 = type[i2]).name === name) {
          return c2.value;
        }
      }
    }
    function set$1(type, name, callback) {
      for (var i2 = 0, n = type.length; i2 < n; ++i2) {
        if (type[i2].name === name) {
          type[i2] = noop$1, type = type.slice(0, i2).concat(type.slice(i2 + 1));
          break;
        }
      }
      if (callback != null)
        type.push({ name, value: callback });
      return type;
    }
    var xhtml$1 = "http://www.w3.org/1999/xhtml";
    const namespaces$1 = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml$1,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
    function namespace$1(name) {
      var prefix2 = name += "", i2 = prefix2.indexOf(":");
      if (i2 >= 0 && (prefix2 = name.slice(0, i2)) !== "xmlns")
        name = name.slice(i2 + 1);
      return namespaces$1.hasOwnProperty(prefix2) ? { space: namespaces$1[prefix2], local: name } : name;
    }
    function creatorInherit$1(name) {
      return function() {
        var document2 = this.ownerDocument, uri = this.namespaceURI;
        return uri === xhtml$1 && document2.documentElement.namespaceURI === xhtml$1 ? document2.createElement(name) : document2.createElementNS(uri, name);
      };
    }
    function creatorFixed$1(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }
    function creator$1(name) {
      var fullname = namespace$1(name);
      return (fullname.local ? creatorFixed$1 : creatorInherit$1)(fullname);
    }
    function none$1() {
    }
    function selector$1(selector2) {
      return selector2 == null ? none$1 : function() {
        return this.querySelector(selector2);
      };
    }
    function selection_select$1(select2) {
      if (typeof select2 !== "function")
        select2 = selector$1(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i2 = 0; i2 < n; ++i2) {
          if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
            if ("__data__" in node)
              subnode.__data__ = node.__data__;
            subgroup[i2] = subnode;
          }
        }
      }
      return new Selection$2(subgroups, this._parents);
    }
    function array(x2) {
      return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
    }
    function empty$1() {
      return [];
    }
    function selectorAll$1(selector2) {
      return selector2 == null ? empty$1 : function() {
        return this.querySelectorAll(selector2);
      };
    }
    function arrayAll(select2) {
      return function() {
        return array(select2.apply(this, arguments));
      };
    }
    function selection_selectAll$1(select2) {
      if (typeof select2 === "function")
        select2 = arrayAll(select2);
      else
        select2 = selectorAll$1(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
          if (node = group[i2]) {
            subgroups.push(select2.call(node, node.__data__, i2, group));
            parents.push(node);
          }
        }
      }
      return new Selection$2(subgroups, parents);
    }
    function matcher$1(selector2) {
      return function() {
        return this.matches(selector2);
      };
    }
    function childMatcher(selector2) {
      return function(node) {
        return node.matches(selector2);
      };
    }
    var find$1 = Array.prototype.find;
    function childFind(match) {
      return function() {
        return find$1.call(this.children, match);
      };
    }
    function childFirst() {
      return this.firstElementChild;
    }
    function selection_selectChild(match) {
      return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
    }
    var filter = Array.prototype.filter;
    function children() {
      return Array.from(this.children);
    }
    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }
    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }
    function selection_filter$1(match) {
      if (typeof match !== "function")
        match = matcher$1(match);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n; ++i2) {
          if ((node = group[i2]) && match.call(node, node.__data__, i2, group)) {
            subgroup.push(node);
          }
        }
      }
      return new Selection$2(subgroups, this._parents);
    }
    function sparse$1(update) {
      return new Array(update.length);
    }
    function selection_enter$1() {
      return new Selection$2(this._enter || this._groups.map(sparse$1), this._parents);
    }
    function EnterNode$1(parent, datum2) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum2;
    }
    EnterNode$1.prototype = {
      constructor: EnterNode$1,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function(selector2) {
        return this._parent.querySelector(selector2);
      },
      querySelectorAll: function(selector2) {
        return this._parent.querySelectorAll(selector2);
      }
    };
    function constant$5(x2) {
      return function() {
        return x2;
      };
    }
    function bindIndex$1(parent, group, enter, update, exit, data) {
      var i2 = 0, node, groupLength = group.length, dataLength = data.length;
      for (; i2 < dataLength; ++i2) {
        if (node = group[i2]) {
          node.__data__ = data[i2];
          update[i2] = node;
        } else {
          enter[i2] = new EnterNode$1(parent, data[i2]);
        }
      }
      for (; i2 < groupLength; ++i2) {
        if (node = group[i2]) {
          exit[i2] = node;
        }
      }
    }
    function bindKey$1(parent, group, enter, update, exit, data, key) {
      var i2, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
      for (i2 = 0; i2 < groupLength; ++i2) {
        if (node = group[i2]) {
          keyValues[i2] = keyValue = key.call(node, node.__data__, i2, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i2] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }
      for (i2 = 0; i2 < dataLength; ++i2) {
        keyValue = key.call(parent, data[i2], i2, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i2] = node;
          node.__data__ = data[i2];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i2] = new EnterNode$1(parent, data[i2]);
        }
      }
      for (i2 = 0; i2 < groupLength; ++i2) {
        if ((node = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node) {
          exit[i2] = node;
        }
      }
    }
    function datum(node) {
      return node.__data__;
    }
    function selection_data$1(value, key) {
      if (!arguments.length)
        return Array.from(this, datum);
      var bind2 = key ? bindKey$1 : bindIndex$1, parents = this._parents, groups = this._groups;
      if (typeof value !== "function")
        value = constant$5(value);
      for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
        var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
        bind2(parent, group, enterGroup, updateGroup, exitGroup, data, key);
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1)
              i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength)
              ;
            previous._next = next || null;
          }
        }
      }
      update = new Selection$2(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }
    function arraylike(data) {
      return typeof data === "object" && "length" in data ? data : Array.from(data);
    }
    function selection_exit$1() {
      return new Selection$2(this._exit || this._groups.map(sparse$1), this._parents);
    }
    function selection_join$1(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter)
          enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update)
          update = update.selection();
      }
      if (onexit == null)
        exit.remove();
      else
        onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }
    function selection_merge$1(context) {
      var selection2 = context.selection ? context.selection() : context;
      for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
          if (node = group0[i2] || group1[i2]) {
            merge2[i2] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Selection$2(merges, this._parents);
    }
    function selection_order$1() {
      for (var groups = this._groups, j = -1, m2 = groups.length; ++j < m2; ) {
        for (var group = groups[j], i2 = group.length - 1, next = group[i2], node; --i2 >= 0; ) {
          if (node = group[i2]) {
            if (next && node.compareDocumentPosition(next) ^ 4)
              next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }
      return this;
    }
    function selection_sort$1(compare) {
      if (!compare)
        compare = ascending$1;
      function compareNode(a2, b) {
        return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
      }
      for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
          if (node = group[i2]) {
            sortgroup[i2] = node;
          }
        }
        sortgroup.sort(compareNode);
      }
      return new Selection$2(sortgroups, this._parents).order();
    }
    function ascending$1(a2, b) {
      return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
    }
    function selection_call$1() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }
    function selection_nodes$1() {
      return Array.from(this);
    }
    function selection_node$1() {
      for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
        for (var group = groups[j], i2 = 0, n = group.length; i2 < n; ++i2) {
          var node = group[i2];
          if (node)
            return node;
        }
      }
      return null;
    }
    function selection_size$1() {
      let size2 = 0;
      for (const node of this)
        ++size2;
      return size2;
    }
    function selection_empty$1() {
      return !this.node();
    }
    function selection_each$1(callback) {
      for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
        for (var group = groups[j], i2 = 0, n = group.length, node; i2 < n; ++i2) {
          if (node = group[i2])
            callback.call(node, node.__data__, i2, group);
        }
      }
      return this;
    }
    function attrRemove$2(name) {
      return function() {
        this.removeAttribute(name);
      };
    }
    function attrRemoveNS$2(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant$2(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }
    function attrConstantNS$2(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }
    function attrFunction$2(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.removeAttribute(name);
        else
          this.setAttribute(name, v);
      };
    }
    function attrFunctionNS$2(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.removeAttributeNS(fullname.space, fullname.local);
        else
          this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }
    function selection_attr$1(name, value) {
      var fullname = namespace$1(name);
      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
      }
      return this.each((value == null ? fullname.local ? attrRemoveNS$2 : attrRemove$2 : typeof value === "function" ? fullname.local ? attrFunctionNS$2 : attrFunction$2 : fullname.local ? attrConstantNS$2 : attrConstant$2)(fullname, value));
    }
    function defaultView$1(node) {
      return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
    }
    function styleRemove$2(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }
    function styleConstant$2(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }
    function styleFunction$2(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.style.removeProperty(name);
        else
          this.style.setProperty(name, v, priority);
      };
    }
    function selection_style$1(name, value, priority) {
      return arguments.length > 1 ? this.each((value == null ? styleRemove$2 : typeof value === "function" ? styleFunction$2 : styleConstant$2)(name, value, priority == null ? "" : priority)) : styleValue$1(this.node(), name);
    }
    function styleValue$1(node, name) {
      return node.style.getPropertyValue(name) || defaultView$1(node).getComputedStyle(node, null).getPropertyValue(name);
    }
    function propertyRemove$1(name) {
      return function() {
        delete this[name];
      };
    }
    function propertyConstant$1(name, value) {
      return function() {
        this[name] = value;
      };
    }
    function propertyFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          delete this[name];
        else
          this[name] = v;
      };
    }
    function selection_property$1(name, value) {
      return arguments.length > 1 ? this.each((value == null ? propertyRemove$1 : typeof value === "function" ? propertyFunction$1 : propertyConstant$1)(name, value)) : this.node()[name];
    }
    function classArray$1(string) {
      return string.trim().split(/^|\s+/);
    }
    function classList$1(node) {
      return node.classList || new ClassList$1(node);
    }
    function ClassList$1(node) {
      this._node = node;
      this._names = classArray$1(node.getAttribute("class") || "");
    }
    ClassList$1.prototype = {
      add: function(name) {
        var i2 = this._names.indexOf(name);
        if (i2 < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i2 = this._names.indexOf(name);
        if (i2 >= 0) {
          this._names.splice(i2, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };
    function classedAdd$1(node, names2) {
      var list = classList$1(node), i2 = -1, n = names2.length;
      while (++i2 < n)
        list.add(names2[i2]);
    }
    function classedRemove$1(node, names2) {
      var list = classList$1(node), i2 = -1, n = names2.length;
      while (++i2 < n)
        list.remove(names2[i2]);
    }
    function classedTrue$1(names2) {
      return function() {
        classedAdd$1(this, names2);
      };
    }
    function classedFalse$1(names2) {
      return function() {
        classedRemove$1(this, names2);
      };
    }
    function classedFunction$1(names2, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd$1 : classedRemove$1)(this, names2);
      };
    }
    function selection_classed$1(name, value) {
      var names2 = classArray$1(name + "");
      if (arguments.length < 2) {
        var list = classList$1(this.node()), i2 = -1, n = names2.length;
        while (++i2 < n)
          if (!list.contains(names2[i2]))
            return false;
        return true;
      }
      return this.each((typeof value === "function" ? classedFunction$1 : value ? classedTrue$1 : classedFalse$1)(names2, value));
    }
    function textRemove$1() {
      this.textContent = "";
    }
    function textConstant$2(value) {
      return function() {
        this.textContent = value;
      };
    }
    function textFunction$2(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }
    function selection_text$1(value) {
      return arguments.length ? this.each(value == null ? textRemove$1 : (typeof value === "function" ? textFunction$2 : textConstant$2)(value)) : this.node().textContent;
    }
    function htmlRemove$1() {
      this.innerHTML = "";
    }
    function htmlConstant$1(value) {
      return function() {
        this.innerHTML = value;
      };
    }
    function htmlFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }
    function selection_html$1(value) {
      return arguments.length ? this.each(value == null ? htmlRemove$1 : (typeof value === "function" ? htmlFunction$1 : htmlConstant$1)(value)) : this.node().innerHTML;
    }
    function raise$1() {
      if (this.nextSibling)
        this.parentNode.appendChild(this);
    }
    function selection_raise$1() {
      return this.each(raise$1);
    }
    function lower$1() {
      if (this.previousSibling)
        this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower$1() {
      return this.each(lower$1);
    }
    function selection_append$1(name) {
      var create2 = typeof name === "function" ? name : creator$1(name);
      return this.select(function() {
        return this.appendChild(create2.apply(this, arguments));
      });
    }
    function constantNull$1() {
      return null;
    }
    function selection_insert$1(name, before) {
      var create2 = typeof name === "function" ? name : creator$1(name), select2 = before == null ? constantNull$1 : typeof before === "function" ? before : selector$1(before);
      return this.select(function() {
        return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
      });
    }
    function remove$1() {
      var parent = this.parentNode;
      if (parent)
        parent.removeChild(this);
    }
    function selection_remove$1() {
      return this.each(remove$1);
    }
    function selection_cloneShallow$1() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep$1() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone$1(deep) {
      return this.select(deep ? selection_cloneDeep$1 : selection_cloneShallow$1);
    }
    function selection_datum$1(value) {
      return arguments.length ? this.property("__data__", value) : this.node().__data__;
    }
    function contextListener$1(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }
    function parseTypenames$1(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i2 = t.indexOf(".");
        if (i2 >= 0)
          name = t.slice(i2 + 1), t = t.slice(0, i2);
        return { type: t, name };
      });
    }
    function onRemove$1(typename) {
      return function() {
        var on2 = this.__on;
        if (!on2)
          return;
        for (var j = 0, i2 = -1, m2 = on2.length, o; j < m2; ++j) {
          if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on2[++i2] = o;
          }
        }
        if (++i2)
          on2.length = i2;
        else
          delete this.__on;
      };
    }
    function onAdd$1(typename, value, options) {
      return function() {
        var on2 = this.__on, o, listener = contextListener$1(value);
        if (on2)
          for (var j = 0, m2 = on2.length; j < m2; ++j) {
            if ((o = on2[j]).type === typename.type && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.options);
              this.addEventListener(o.type, o.listener = listener, o.options = options);
              o.value = value;
              return;
            }
          }
        this.addEventListener(typename.type, listener, options);
        o = { type: typename.type, name: typename.name, value, listener, options };
        if (!on2)
          this.__on = [o];
        else
          on2.push(o);
      };
    }
    function selection_on$1(typename, value, options) {
      var typenames = parseTypenames$1(typename + ""), i2, n = typenames.length, t;
      if (arguments.length < 2) {
        var on2 = this.node().__on;
        if (on2)
          for (var j = 0, m2 = on2.length, o; j < m2; ++j) {
            for (i2 = 0, o = on2[j]; i2 < n; ++i2) {
              if ((t = typenames[i2]).type === o.type && t.name === o.name) {
                return o.value;
              }
            }
          }
        return;
      }
      on2 = value ? onAdd$1 : onRemove$1;
      for (i2 = 0; i2 < n; ++i2)
        this.each(on2(typenames[i2], value, options));
      return this;
    }
    function dispatchEvent$1(node, type, params) {
      var window2 = defaultView$1(node), event = window2.CustomEvent;
      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window2.document.createEvent("Event");
        if (params)
          event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else
          event.initEvent(type, false, false);
      }
      node.dispatchEvent(event);
    }
    function dispatchConstant$1(type, params) {
      return function() {
        return dispatchEvent$1(this, type, params);
      };
    }
    function dispatchFunction$1(type, params) {
      return function() {
        return dispatchEvent$1(this, type, params.apply(this, arguments));
      };
    }
    function selection_dispatch$1(type, params) {
      return this.each((typeof params === "function" ? dispatchFunction$1 : dispatchConstant$1)(type, params));
    }
    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
        for (var group = groups[j], i2 = 0, n = group.length, node; i2 < n; ++i2) {
          if (node = group[i2])
            yield node;
        }
      }
    }
    var root$1 = [null];
    function Selection$2(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }
    function selection$1() {
      return new Selection$2([[document.documentElement]], root$1);
    }
    function selection_selection() {
      return this;
    }
    Selection$2.prototype = selection$1.prototype = {
      constructor: Selection$2,
      select: selection_select$1,
      selectAll: selection_selectAll$1,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter$1,
      data: selection_data$1,
      enter: selection_enter$1,
      exit: selection_exit$1,
      join: selection_join$1,
      merge: selection_merge$1,
      selection: selection_selection,
      order: selection_order$1,
      sort: selection_sort$1,
      call: selection_call$1,
      nodes: selection_nodes$1,
      node: selection_node$1,
      size: selection_size$1,
      empty: selection_empty$1,
      each: selection_each$1,
      attr: selection_attr$1,
      style: selection_style$1,
      property: selection_property$1,
      classed: selection_classed$1,
      text: selection_text$1,
      html: selection_html$1,
      raise: selection_raise$1,
      lower: selection_lower$1,
      append: selection_append$1,
      insert: selection_insert$1,
      remove: selection_remove$1,
      clone: selection_clone$1,
      datum: selection_datum$1,
      on: selection_on$1,
      dispatch: selection_dispatch$1,
      [Symbol.iterator]: selection_iterator
    };
    function select$1(selector2) {
      return typeof selector2 === "string" ? new Selection$2([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$2([[selector2]], root$1);
    }
    function sourceEvent(event) {
      let sourceEvent2;
      while (sourceEvent2 = event.sourceEvent)
        event = sourceEvent2;
      return event;
    }
    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === void 0)
        node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }
    function selectAll(selector2) {
      return typeof selector2 === "string" ? new Selection$2([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection$2([array(selector2)], root$1);
    }
    const nonpassive = { passive: false };
    const nonpassivecapture = { capture: true, passive: false };
    function nopropagation$1(event) {
      event.stopImmediatePropagation();
    }
    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    function dragDisable(view) {
      var root2 = view.document.documentElement, selection2 = select$1(view).on("dragstart.drag", noevent$1, nonpassivecapture);
      if ("onselectstart" in root2) {
        selection2.on("selectstart.drag", noevent$1, nonpassivecapture);
      } else {
        root2.__noselect = root2.style.MozUserSelect;
        root2.style.MozUserSelect = "none";
      }
    }
    function yesdrag(view, noclick) {
      var root2 = view.document.documentElement, selection2 = select$1(view).on("dragstart.drag", null);
      if (noclick) {
        selection2.on("click.drag", noevent$1, nonpassivecapture);
        setTimeout(function() {
          selection2.on("click.drag", null);
        }, 0);
      }
      if ("onselectstart" in root2) {
        selection2.on("selectstart.drag", null);
      } else {
        root2.style.MozUserSelect = root2.__noselect;
        delete root2.__noselect;
      }
    }
    const constant$4 = (x2) => () => x2;
    function DragEvent(type, {
      sourceEvent: sourceEvent2,
      subject,
      target,
      identifier,
      active,
      x: x2,
      y: y2,
      dx,
      dy,
      dispatch: dispatch2
    }) {
      Object.defineProperties(this, {
        type: { value: type, enumerable: true, configurable: true },
        sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
        subject: { value: subject, enumerable: true, configurable: true },
        target: { value: target, enumerable: true, configurable: true },
        identifier: { value: identifier, enumerable: true, configurable: true },
        active: { value: active, enumerable: true, configurable: true },
        x: { value: x2, enumerable: true, configurable: true },
        y: { value: y2, enumerable: true, configurable: true },
        dx: { value: dx, enumerable: true, configurable: true },
        dy: { value: dy, enumerable: true, configurable: true },
        _: { value: dispatch2 }
      });
    }
    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };
    function defaultFilter$1(event) {
      return !event.ctrlKey && !event.button;
    }
    function defaultContainer() {
      return this.parentNode;
    }
    function defaultSubject(event, d) {
      return d == null ? { x: event.x, y: event.y } : d;
    }
    function defaultTouchable$1() {
      return navigator.maxTouchPoints || "ontouchstart" in this;
    }
    function drag() {
      var filter2 = defaultFilter$1, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$1, gestures = {}, listeners = dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
      function drag2(selection2) {
        selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }
      function mousedowned(event, d) {
        if (touchending || !filter2.call(this, event, d))
          return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture)
          return;
        select$1(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation$1(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }
      function mousemoved(event) {
        noevent$1(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }
      function mouseupped(event) {
        select$1(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$1(event);
        gestures.mouse("end", event);
      }
      function touchstarted(event, d) {
        if (!filter2.call(this, event, d))
          return;
        var touches = event.changedTouches, c2 = container.call(this, event, d), n = touches.length, i2, gesture;
        for (i2 = 0; i2 < n; ++i2) {
          if (gesture = beforestart(this, c2, event, d, touches[i2].identifier, touches[i2])) {
            nopropagation$1(event);
            gesture("start", event, touches[i2]);
          }
        }
      }
      function touchmoved(event) {
        var touches = event.changedTouches, n = touches.length, i2, gesture;
        for (i2 = 0; i2 < n; ++i2) {
          if (gesture = gestures[touches[i2].identifier]) {
            noevent$1(event);
            gesture("drag", event, touches[i2]);
          }
        }
      }
      function touchended(event) {
        var touches = event.changedTouches, n = touches.length, i2, gesture;
        if (touchending)
          clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
        for (i2 = 0; i2 < n; ++i2) {
          if (gesture = gestures[touches[i2].identifier]) {
            nopropagation$1(event);
            gesture("end", event, touches[i2]);
          }
        }
      }
      function beforestart(that, container2, event, d, identifier, touch) {
        var dispatch2 = listeners.copy(), p2 = pointer(touch || event, container2), dx, dy, s;
        if ((s = subject.call(that, new DragEvent("beforestart", {
          sourceEvent: event,
          target: drag2,
          identifier,
          active,
          x: p2[0],
          y: p2[1],
          dx: 0,
          dy: 0,
          dispatch: dispatch2
        }), d)) == null)
          return;
        dx = s.x - p2[0] || 0;
        dy = s.y - p2[1] || 0;
        return function gesture(type, event2, touch2) {
          var p0 = p2, n;
          switch (type) {
            case "start":
              gestures[identifier] = gesture, n = active++;
              break;
            case "end":
              delete gestures[identifier], --active;
            case "drag":
              p2 = pointer(touch2 || event2, container2), n = active;
              break;
          }
          dispatch2.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event2,
              subject: s,
              target: drag2,
              identifier,
              active: n,
              x: p2[0] + dx,
              y: p2[1] + dy,
              dx: p2[0] - p0[0],
              dy: p2[1] - p0[1],
              dispatch: dispatch2
            }),
            d
          );
        };
      }
      drag2.filter = function(_) {
        return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant$4(!!_), drag2) : filter2;
      };
      drag2.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$4(_), drag2) : container;
      };
      drag2.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$4(_), drag2) : subject;
      };
      drag2.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$4(!!_), drag2) : touchable;
      };
      drag2.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag2 : value;
      };
      drag2.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
      };
      return drag2;
    }
    function define(constructor, factory, prototype2) {
      constructor.prototype = factory.prototype = prototype2;
      prototype2.constructor = constructor;
    }
    function extend$1(parent, definition) {
      var prototype2 = Object.create(parent.prototype);
      for (var key in definition)
        prototype2[key] = definition[key];
      return prototype2;
    }
    function Color() {
    }
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    var named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define(Color, color$2, {
      copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    function color_formatHex() {
      return this.rgb().formatHex();
    }
    function color_formatHex8() {
      return this.rgb().formatHex8();
    }
    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }
    function color_formatRgb() {
      return this.rgb().formatRgb();
    }
    function color$2(format2) {
      var m2, l;
      format2 = (format2 + "").trim().toLowerCase();
      return (m2 = reHex.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }
    function rgbn(n) {
      return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
    }
    function rgba(r, g, b, a2) {
      if (a2 <= 0)
        r = g = b = NaN;
      return new Rgb(r, g, b, a2);
    }
    function rgbConvert(o) {
      if (!(o instanceof Color))
        o = color$2(o);
      if (!o)
        return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb$1(r, g, b, opacity2) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity2 == null ? 1 : opacity2);
    }
    function Rgb(r, g, b, opacity2) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity2;
    }
    define(Rgb, rgb$1, extend$1(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }
    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }
    function rgb_formatRgb() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
    }
    function clampa(opacity2) {
      return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
    }
    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }
    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla(h2, s, l, a2) {
      if (a2 <= 0)
        h2 = s = l = NaN;
      else if (l <= 0 || l >= 1)
        h2 = s = NaN;
      else if (s <= 0)
        h2 = NaN;
      return new Hsl(h2, s, l, a2);
    }
    function hslConvert(o) {
      if (o instanceof Hsl)
        return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color))
        o = color$2(o);
      if (!o)
        return new Hsl();
      if (o instanceof Hsl)
        return o;
      o = o.rgb();
      var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h2 = NaN, s = max - min, l = (max + min) / 2;
      if (s) {
        if (r === max)
          h2 = (g - b) / s + (g < b) * 6;
        else if (g === max)
          h2 = (b - r) / s + 2;
        else
          h2 = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h2 *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h2;
      }
      return new Hsl(h2, s, l, o.opacity);
    }
    function hsl$1(h2, s, l, opacity2) {
      return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity2 == null ? 1 : opacity2);
    }
    function Hsl(h2, s, l, opacity2) {
      this.h = +h2;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity2;
    }
    define(Hsl, hsl$1, extend$1(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
          hsl2rgb(h2, m1, m2),
          hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a2 = clampa(this.opacity);
        return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
      }
    }));
    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }
    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }
    function hsl2rgb(h2, m1, m2) {
      return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
    }
    const radians = Math.PI / 180;
    const degrees$1 = 180 / Math.PI;
    var A$1 = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E$1 = 1.97294, ED = E$1 * D, EB$1 = E$1 * B, BC_DA = B * C - D * A$1;
    function cubehelixConvert(o) {
      if (o instanceof Cubehelix)
        return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb))
        o = rgbConvert(o);
      var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB$1 * g) / (BC_DA + ED - EB$1), bl = b - l, k = (E$1 * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E$1 * l * (1 - l)), h2 = s ? Math.atan2(k, bl) * degrees$1 - 120 : NaN;
      return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s, l, o.opacity);
    }
    function cubehelix$1(h2, s, l, opacity2) {
      return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s, l, opacity2 == null ? 1 : opacity2);
    }
    function Cubehelix(h2, s, l, opacity2) {
      this.h = +h2;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity2;
    }
    define(Cubehelix, cubehelix$1, extend$1(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h2 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
        return new Rgb(
          255 * (l + a2 * (A$1 * cosh2 + B * sinh2)),
          255 * (l + a2 * (C * cosh2 + D * sinh2)),
          255 * (l + a2 * (E$1 * cosh2)),
          this.opacity
        );
      }
    }));
    const constant$3 = (x2) => () => x2;
    function linear(a2, d) {
      return function(t) {
        return a2 + t * d;
      };
    }
    function exponential(a2, b, y2) {
      return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
        return Math.pow(a2 + t * b, y2);
      };
    }
    function hue(a2, b) {
      var d = b - a2;
      return d ? linear(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a2) ? b : a2);
    }
    function gamma(y2) {
      return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
        return b - a2 ? exponential(a2, b, y2) : constant$3(isNaN(a2) ? b : a2);
      };
    }
    function nogamma(a2, b) {
      var d = b - a2;
      return d ? linear(a2, d) : constant$3(isNaN(a2) ? b : a2);
    }
    const interpolateRgb = function rgbGamma(y2) {
      var color2 = gamma(y2);
      function rgb2(start2, end) {
        var r = color2((start2 = rgb$1(start2)).r, (end = rgb$1(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
        return function(t) {
          start2.r = r(t);
          start2.g = g(t);
          start2.b = b(t);
          start2.opacity = opacity2(t);
          return start2 + "";
        };
      }
      rgb2.gamma = rgbGamma;
      return rgb2;
    }(1);
    function numberArray(a2, b) {
      if (!b)
        b = [];
      var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i2;
      return function(t) {
        for (i2 = 0; i2 < n; ++i2)
          c2[i2] = a2[i2] * (1 - t) + b[i2] * t;
        return c2;
      };
    }
    function isNumberArray(x2) {
      return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
    }
    function genericArray(a2, b) {
      var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i2;
      for (i2 = 0; i2 < na; ++i2)
        x2[i2] = interpolate$1(a2[i2], b[i2]);
      for (; i2 < nb; ++i2)
        c2[i2] = b[i2];
      return function(t) {
        for (i2 = 0; i2 < na; ++i2)
          c2[i2] = x2[i2](t);
        return c2;
      };
    }
    function date(a2, b) {
      var d = /* @__PURE__ */ new Date();
      return a2 = +a2, b = +b, function(t) {
        return d.setTime(a2 * (1 - t) + b * t), d;
      };
    }
    function interpolateNumber(a2, b) {
      return a2 = +a2, b = +b, function(t) {
        return a2 * (1 - t) + b * t;
      };
    }
    function object(a2, b) {
      var i2 = {}, c2 = {}, k;
      if (a2 === null || typeof a2 !== "object")
        a2 = {};
      if (b === null || typeof b !== "object")
        b = {};
      for (k in b) {
        if (k in a2) {
          i2[k] = interpolate$1(a2[k], b[k]);
        } else {
          c2[k] = b[k];
        }
      }
      return function(t) {
        for (k in i2)
          c2[k] = i2[k](t);
        return c2;
      };
    }
    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
    function zero(b) {
      return function() {
        return b;
      };
    }
    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }
    function interpolateString(a2, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s = [], q2 = [];
      a2 = a2 + "", b = b + "";
      while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) {
          bs = b.slice(bi, bs);
          if (s[i2])
            s[i2] += bs;
          else
            s[++i2] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
          if (s[i2])
            s[i2] += bm;
          else
            s[++i2] = bm;
        } else {
          s[++i2] = null;
          q2.push({ i: i2, x: interpolateNumber(am, bm) });
        }
        bi = reB.lastIndex;
      }
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i2])
          s[i2] += bs;
        else
          s[++i2] = bs;
      }
      return s.length < 2 ? q2[0] ? one(q2[0].x) : zero(b) : (b = q2.length, function(t) {
        for (var i3 = 0, o; i3 < b; ++i3)
          s[(o = q2[i3]).i] = o.x(t);
        return s.join("");
      });
    }
    function interpolate$1(a2, b) {
      var t = typeof b, c2;
      return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? interpolateNumber : t === "string" ? (c2 = color$2(b)) ? (b = c2, interpolateRgb) : interpolateString : b instanceof color$2 ? interpolateRgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a2, b);
    }
    function interpolateRound(a2, b) {
      return a2 = +a2, b = +b, function(t) {
        return Math.round(a2 * (1 - t) + b * t);
      };
    }
    var degrees = 180 / Math.PI;
    var identity$3 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
    function decompose(a2, b, c2, d, e3, f2) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a2 * a2 + b * b))
        a2 /= scaleX, b /= scaleX;
      if (skewX = a2 * c2 + b * d)
        c2 -= a2 * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c2 * c2 + d * d))
        c2 /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a2 * d < b * c2)
        a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e3,
        translateY: f2,
        rotate: Math.atan2(b, a2) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX,
        scaleY
      };
    }
    var svgNode;
    function parseCss(value) {
      const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m2.isIdentity ? identity$3 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
    }
    function parseSvg(value) {
      if (value == null)
        return identity$3;
      if (!svgNode)
        svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate()))
        return identity$3;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }
    function interpolateTransform(parse2, pxComma, pxParen, degParen) {
      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }
      function translate2(xa, ya, xb, yb, s, q2) {
        if (xa !== xb || ya !== yb) {
          var i2 = s.push("translate(", null, pxComma, null, pxParen);
          q2.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }
      function rotate(a2, b, s, q2) {
        if (a2 !== b) {
          if (a2 - b > 180)
            b += 360;
          else if (b - a2 > 180)
            a2 += 360;
          q2.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b) });
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }
      function skewX(a2, b, s, q2) {
        if (a2 !== b) {
          q2.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b) });
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }
      function scale(xa, ya, xb, yb, s, q2) {
        if (xa !== xb || ya !== yb) {
          var i2 = s.push(pop(s) + "scale(", null, ",", null, ")");
          q2.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }
      return function(a2, b) {
        var s = [], q2 = [];
        a2 = parse2(a2), b = parse2(b);
        translate2(a2.translateX, a2.translateY, b.translateX, b.translateY, s, q2);
        rotate(a2.rotate, b.rotate, s, q2);
        skewX(a2.skewX, b.skewX, s, q2);
        scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s, q2);
        a2 = b = null;
        return function(t) {
          var i2 = -1, n = q2.length, o;
          while (++i2 < n)
            s[(o = q2[i2]).i] = o.x(t);
          return s.join("");
        };
      };
    }
    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
    var epsilon2 = 1e-12;
    function cosh(x2) {
      return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
    }
    function sinh(x2) {
      return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
    }
    function tanh(x2) {
      return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
    }
    const interpolateZoom = function zoomRho(rho, rho2, rho4) {
      function zoom2(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S;
        if (d2 < epsilon2) {
          S = Math.log(w1 / w0) / rho;
          i2 = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        } else {
          var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i2 = function(t) {
            var s = t * S, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u2 * dx,
              uy0 + u2 * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }
        i2.duration = S * 1e3 * rho / Math.SQRT2;
        return i2;
      }
      zoom2.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };
      return zoom2;
    }(Math.SQRT2, 2, 4);
    function cubehelix(hue2) {
      return function cubehelixGamma(y2) {
        y2 = +y2;
        function cubehelix2(start2, end) {
          var h2 = hue2((start2 = cubehelix$1(start2)).h, (end = cubehelix$1(end)).h), s = nogamma(start2.s, end.s), l = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
          return function(t) {
            start2.h = h2(t);
            start2.s = s(t);
            start2.l = l(Math.pow(t, y2));
            start2.opacity = opacity2(t);
            return start2 + "";
          };
        }
        cubehelix2.gamma = cubehelixGamma;
        return cubehelix2;
      }(1);
    }
    cubehelix(hue);
    var cubehelixLong = cubehelix(nogamma);
    var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
      setTimeout(f2, 17);
    };
    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }
    function clearNow() {
      clockNow = 0;
    }
    function Timer() {
      this._call = this._time = this._next = null;
    }
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time2) {
        if (typeof callback !== "function")
          throw new TypeError("callback is not a function");
        time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail)
            taskTail._next = this;
          else
            taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time2;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
    function timer(callback, delay, time2) {
      var t = new Timer();
      t.restart(callback, delay, time2);
      return t;
    }
    function timerFlush() {
      now();
      ++frame;
      var t = taskHead, e3;
      while (t) {
        if ((e3 = clockNow - t._time) >= 0)
          t._call.call(void 0, e3);
        t = t._next;
      }
      --frame;
    }
    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }
    function poke() {
      var now2 = clock.now(), delay = now2 - clockLast;
      if (delay > pokeDelay)
        clockSkew -= delay, clockLast = now2;
    }
    function nap() {
      var t0, t1 = taskHead, t2, time2 = Infinity;
      while (t1) {
        if (t1._call) {
          if (time2 > t1._time)
            time2 = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time2);
    }
    function sleep(time2) {
      if (frame)
        return;
      if (timeout$1)
        timeout$1 = clearTimeout(timeout$1);
      var delay = time2 - clockNow;
      if (delay > 24) {
        if (time2 < Infinity)
          timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
        if (interval)
          interval = clearInterval(interval);
      } else {
        if (!interval)
          clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }
    function timeout(callback, delay, time2) {
      var t = new Timer();
      delay = delay == null ? 0 : +delay;
      t.restart((elapsed) => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time2);
      return t;
    }
    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];
    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;
    function schedule(node, name, id2, index2, group, timing) {
      var schedules = node.__transition;
      if (!schedules)
        node.__transition = {};
      else if (id2 in schedules)
        return;
      create(node, id2, {
        name,
        index: index2,
        // For context during callback.
        group,
        // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }
    function init(node, id2) {
      var schedule2 = get(node, id2);
      if (schedule2.state > CREATED)
        throw new Error("too late; already scheduled");
      return schedule2;
    }
    function set(node, id2) {
      var schedule2 = get(node, id2);
      if (schedule2.state > STARTED)
        throw new Error("too late; already running");
      return schedule2;
    }
    function get(node, id2) {
      var schedule2 = node.__transition;
      if (!schedule2 || !(schedule2 = schedule2[id2]))
        throw new Error("transition not found");
      return schedule2;
    }
    function create(node, id2, self2) {
      var schedules = node.__transition, tween;
      schedules[id2] = self2;
      self2.timer = timer(schedule2, 0, self2.time);
      function schedule2(elapsed) {
        self2.state = SCHEDULED;
        self2.timer.restart(start2, self2.delay, self2.time);
        if (self2.delay <= elapsed)
          start2(elapsed - self2.delay);
      }
      function start2(elapsed) {
        var i2, j, n, o;
        if (self2.state !== SCHEDULED)
          return stop();
        for (i2 in schedules) {
          o = schedules[i2];
          if (o.name !== self2.name)
            continue;
          if (o.state === STARTED)
            return timeout(start2);
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i2];
          } else if (+i2 < id2) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i2];
          }
        }
        timeout(function() {
          if (self2.state === STARTED) {
            self2.state = RUNNING;
            self2.timer.restart(tick, self2.delay, self2.time);
            tick(elapsed);
          }
        });
        self2.state = STARTING;
        self2.on.call("start", node, node.__data__, self2.index, self2.group);
        if (self2.state !== STARTING)
          return;
        self2.state = STARTED;
        tween = new Array(n = self2.tween.length);
        for (i2 = 0, j = -1; i2 < n; ++i2) {
          if (o = self2.tween[i2].value.call(node, node.__data__, self2.index, self2.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }
      function tick(elapsed) {
        var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n = tween.length;
        while (++i2 < n) {
          tween[i2].call(node, t);
        }
        if (self2.state === ENDING) {
          self2.on.call("end", node, node.__data__, self2.index, self2.group);
          stop();
        }
      }
      function stop() {
        self2.state = ENDED;
        self2.timer.stop();
        delete schedules[id2];
        for (var i2 in schedules)
          return;
        delete node.__transition;
      }
    }
    function interrupt(node, name) {
      var schedules = node.__transition, schedule2, active, empty2 = true, i2;
      if (!schedules)
        return;
      name = name == null ? null : name + "";
      for (i2 in schedules) {
        if ((schedule2 = schedules[i2]).name !== name) {
          empty2 = false;
          continue;
        }
        active = schedule2.state > STARTING && schedule2.state < ENDING;
        schedule2.state = ENDED;
        schedule2.timer.stop();
        schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
        delete schedules[i2];
      }
      if (empty2)
        delete node.__transition;
    }
    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }
    function tweenRemove(id2, name) {
      var tween0, tween1;
      return function() {
        var schedule2 = set(this, id2), tween = schedule2.tween;
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i2 = 0, n = tween1.length; i2 < n; ++i2) {
            if (tween1[i2].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i2, 1);
              break;
            }
          }
        }
        schedule2.tween = tween1;
      };
    }
    function tweenFunction(id2, name, value) {
      var tween0, tween1;
      if (typeof value !== "function")
        throw new Error();
      return function() {
        var schedule2 = set(this, id2), tween = schedule2.tween;
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = { name, value }, i2 = 0, n = tween1.length; i2 < n; ++i2) {
            if (tween1[i2].name === name) {
              tween1[i2] = t;
              break;
            }
          }
          if (i2 === n)
            tween1.push(t);
        }
        schedule2.tween = tween1;
      };
    }
    function transition_tween(name, value) {
      var id2 = this._id;
      name += "";
      if (arguments.length < 2) {
        var tween = get(this.node(), id2).tween;
        for (var i2 = 0, n = tween.length, t; i2 < n; ++i2) {
          if ((t = tween[i2]).name === name) {
            return t.value;
          }
        }
        return null;
      }
      return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
    }
    function tweenValue(transition, name, value) {
      var id2 = transition._id;
      transition.each(function() {
        var schedule2 = set(this, id2);
        (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
      });
      return function(node) {
        return get(node, id2).value[name];
      };
    }
    function interpolate(a2, b) {
      var c2;
      return (typeof b === "number" ? interpolateNumber : b instanceof color$2 ? interpolateRgb : (c2 = color$2(b)) ? (b = c2, interpolateRgb) : interpolateString)(a2, b);
    }
    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }
    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant$1(name, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function attrConstantNS$1(fullname, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function attrFunction$1(name, interpolate2, value) {
      var string00, string10, interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null)
          return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function attrFunctionNS$1(fullname, interpolate2, value) {
      var string00, string10, interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null)
          return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function transition_attr(name, value) {
      var fullname = namespace$1(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate;
      return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname) : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i2, value));
    }
    function attrInterpolate(name, i2) {
      return function(t) {
        this.setAttribute(name, i2.call(this, t));
      };
    }
    function attrInterpolateNS(fullname, i2) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t));
      };
    }
    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i2 = value.apply(this, arguments);
        if (i2 !== i0)
          t0 = (i0 = i2) && attrInterpolateNS(fullname, i2);
        return t0;
      }
      tween._value = value;
      return tween;
    }
    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i2 = value.apply(this, arguments);
        if (i2 !== i0)
          t0 = (i0 = i2) && attrInterpolate(name, i2);
        return t0;
      }
      tween._value = value;
      return tween;
    }
    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2)
        return (key = this.tween(key)) && key._value;
      if (value == null)
        return this.tween(key, null);
      if (typeof value !== "function")
        throw new Error();
      var fullname = namespace$1(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }
    function delayFunction(id2, value) {
      return function() {
        init(this, id2).delay = +value.apply(this, arguments);
      };
    }
    function delayConstant(id2, value) {
      return value = +value, function() {
        init(this, id2).delay = value;
      };
    }
    function transition_delay(value) {
      var id2 = this._id;
      return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
    }
    function durationFunction(id2, value) {
      return function() {
        set(this, id2).duration = +value.apply(this, arguments);
      };
    }
    function durationConstant(id2, value) {
      return value = +value, function() {
        set(this, id2).duration = value;
      };
    }
    function transition_duration(value) {
      var id2 = this._id;
      return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
    }
    function easeConstant(id2, value) {
      if (typeof value !== "function")
        throw new Error();
      return function() {
        set(this, id2).ease = value;
      };
    }
    function transition_ease(value) {
      var id2 = this._id;
      return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
    }
    function easeVarying(id2, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function")
          throw new Error();
        set(this, id2).ease = v;
      };
    }
    function transition_easeVarying(value) {
      if (typeof value !== "function")
        throw new Error();
      return this.each(easeVarying(this._id, value));
    }
    function transition_filter(match) {
      if (typeof match !== "function")
        match = matcher$1(match);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n; ++i2) {
          if ((node = group[i2]) && match.call(node, node.__data__, i2, group)) {
            subgroup.push(node);
          }
        }
      }
      return new Transition(subgroups, this._parents, this._name, this._id);
    }
    function transition_merge(transition) {
      if (transition._id !== this._id)
        throw new Error();
      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
          if (node = group0[i2] || group1[i2]) {
            merge2[i2] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Transition(merges, this._parents, this._name, this._id);
    }
    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i2 = t.indexOf(".");
        if (i2 >= 0)
          t = t.slice(0, i2);
        return !t || t === "start";
      });
    }
    function onFunction(id2, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule2 = sit(this, id2), on2 = schedule2.on;
        if (on2 !== on0)
          (on1 = (on0 = on2).copy()).on(name, listener);
        schedule2.on = on1;
      };
    }
    function transition_on(name, listener) {
      var id2 = this._id;
      return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
    }
    function removeFunction(id2) {
      return function() {
        var parent = this.parentNode;
        for (var i2 in this.__transition)
          if (+i2 !== id2)
            return;
        if (parent)
          parent.removeChild(this);
      };
    }
    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }
    function transition_select(select2) {
      var name = this._name, id2 = this._id;
      if (typeof select2 !== "function")
        select2 = selector$1(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i2 = 0; i2 < n; ++i2) {
          if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
            if ("__data__" in node)
              subnode.__data__ = node.__data__;
            subgroup[i2] = subnode;
            schedule(subgroup[i2], name, id2, i2, subgroup, get(node, id2));
          }
        }
      }
      return new Transition(subgroups, this._parents, name, id2);
    }
    function transition_selectAll(select2) {
      var name = this._name, id2 = this._id;
      if (typeof select2 !== "function")
        select2 = selectorAll$1(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
          if (node = group[i2]) {
            for (var children2 = select2.call(node, node.__data__, i2, group), child, inherit2 = get(node, id2), k = 0, l = children2.length; k < l; ++k) {
              if (child = children2[k]) {
                schedule(child, name, id2, k, children2, inherit2);
              }
            }
            subgroups.push(children2);
            parents.push(node);
          }
        }
      }
      return new Transition(subgroups, parents, name, id2);
    }
    var Selection$1 = selection$1.prototype.constructor;
    function transition_selection() {
      return new Selection$1(this._groups, this._parents);
    }
    function styleNull(name, interpolate2) {
      var string00, string10, interpolate0;
      return function() {
        var string0 = styleValue$1(this, name), string1 = (this.style.removeProperty(name), styleValue$1(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
      };
    }
    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }
    function styleConstant$1(name, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = styleValue$1(this, name);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function styleFunction$1(name, interpolate2, value) {
      var string00, string10, interpolate0;
      return function() {
        var string0 = styleValue$1(this, name), value1 = value(this), string1 = value1 + "";
        if (value1 == null)
          string1 = value1 = (this.style.removeProperty(name), styleValue$1(this, name));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function styleMaybeRemove(id2, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
      return function() {
        var schedule2 = set(this, id2), on2 = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove$1(name)) : void 0;
        if (on2 !== on0 || listener0 !== listener)
          (on1 = (on0 = on2).copy()).on(event, listener0 = listener);
        schedule2.on = on1;
      };
    }
    function transition_style(name, value, priority) {
      var i2 = (name += "") === "transform" ? interpolateTransformCss : interpolate;
      return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove$1(name)) : typeof value === "function" ? this.styleTween(name, styleFunction$1(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant$1(name, i2, value), priority).on("end.style." + name, null);
    }
    function styleInterpolate(name, i2, priority) {
      return function(t) {
        this.style.setProperty(name, i2.call(this, t), priority);
      };
    }
    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i2 = value.apply(this, arguments);
        if (i2 !== i0)
          t = (i0 = i2) && styleInterpolate(name, i2, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }
    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2)
        return (key = this.tween(key)) && key._value;
      if (value == null)
        return this.tween(key, null);
      if (typeof value !== "function")
        throw new Error();
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }
    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }
    function textFunction$1(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }
    function transition_text(value) {
      return this.tween("text", typeof value === "function" ? textFunction$1(tweenValue(this, "text", value)) : textConstant$1(value == null ? "" : value + ""));
    }
    function textInterpolate(i2) {
      return function(t) {
        this.textContent = i2.call(this, t);
      };
    }
    function textTween(value) {
      var t0, i0;
      function tween() {
        var i2 = value.apply(this, arguments);
        if (i2 !== i0)
          t0 = (i0 = i2) && textInterpolate(i2);
        return t0;
      }
      tween._value = value;
      return tween;
    }
    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1)
        return (key = this.tween(key)) && key._value;
      if (value == null)
        return this.tween(key, null);
      if (typeof value !== "function")
        throw new Error();
      return this.tween(key, textTween(value));
    }
    function transition_transition() {
      var name = this._name, id0 = this._id, id1 = newId();
      for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
          if (node = group[i2]) {
            var inherit2 = get(node, id0);
            schedule(node, name, id1, i2, group, {
              time: inherit2.time + inherit2.delay + inherit2.duration,
              delay: 0,
              duration: inherit2.duration,
              ease: inherit2.ease
            });
          }
        }
      }
      return new Transition(groups, this._parents, name, id1);
    }
    function transition_end() {
      var on0, on1, that = this, id2 = that._id, size2 = that.size();
      return new Promise(function(resolve2, reject) {
        var cancel = { value: reject }, end = { value: function() {
          if (--size2 === 0)
            resolve2();
        } };
        that.each(function() {
          var schedule2 = set(this, id2), on2 = schedule2.on;
          if (on2 !== on0) {
            on1 = (on0 = on2).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }
          schedule2.on = on1;
        });
        if (size2 === 0)
          resolve2();
      });
    }
    var id = 0;
    function Transition(groups, parents, name, id2) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id2;
    }
    function newId() {
      return ++id;
    }
    var selection_prototype = selection$1.prototype;
    Transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };
    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }
    var defaultTiming = {
      time: null,
      // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };
    function inherit(node, id2) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id2])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id2} not found`);
        }
      }
      return timing;
    }
    function selection_transition(name) {
      var id2, timing;
      if (name instanceof Transition) {
        id2 = name._id, name = name._name;
      } else {
        id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }
      for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
          if (node = group[i2]) {
            schedule(node, name, id2, i2, group, timing || inherit(node, id2));
          }
        }
      }
      return new Transition(groups, this._parents, name, id2);
    }
    selection$1.prototype.interrupt = selection_interrupt;
    selection$1.prototype.transition = selection_transition;
    function center(x2, y2) {
      var nodes, strength = 1;
      if (x2 == null)
        x2 = 0;
      if (y2 == null)
        y2 = 0;
      function force() {
        var i2, n = nodes.length, node, sx = 0, sy = 0;
        for (i2 = 0; i2 < n; ++i2) {
          node = nodes[i2], sx += node.x, sy += node.y;
        }
        for (sx = (sx / n - x2) * strength, sy = (sy / n - y2) * strength, i2 = 0; i2 < n; ++i2) {
          node = nodes[i2], node.x -= sx, node.y -= sy;
        }
      }
      force.initialize = function(_) {
        nodes = _;
      };
      force.x = function(_) {
        return arguments.length ? (x2 = +_, force) : x2;
      };
      force.y = function(_) {
        return arguments.length ? (y2 = +_, force) : y2;
      };
      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };
      return force;
    }
    function tree_add(d) {
      const x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);
      return add(this.cover(x2, y2), x2, y2, d);
    }
    function add(tree, x2, y2, d) {
      if (isNaN(x2) || isNaN(y2))
        return tree;
      var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i2, j;
      if (!node)
        return tree._root = leaf, tree;
      while (node.length) {
        if (right = x2 >= (xm = (x0 + x1) / 2))
          x0 = xm;
        else
          x1 = xm;
        if (bottom = y2 >= (ym = (y0 + y1) / 2))
          y0 = ym;
        else
          y1 = ym;
        if (parent = node, !(node = node[i2 = bottom << 1 | right]))
          return parent[i2] = leaf, tree;
      }
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x2 === xp && y2 === yp)
        return leaf.next = node, parent ? parent[i2] = leaf : tree._root = leaf, tree;
      do {
        parent = parent ? parent[i2] = new Array(4) : tree._root = new Array(4);
        if (right = x2 >= (xm = (x0 + x1) / 2))
          x0 = xm;
        else
          x1 = xm;
        if (bottom = y2 >= (ym = (y0 + y1) / 2))
          y0 = ym;
        else
          y1 = ym;
      } while ((i2 = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
      return parent[j] = node, parent[i2] = leaf, tree;
    }
    function addAll(data) {
      var d, i2, n = data.length, x2, y2, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
      for (i2 = 0; i2 < n; ++i2) {
        if (isNaN(x2 = +this._x.call(null, d = data[i2])) || isNaN(y2 = +this._y.call(null, d)))
          continue;
        xz[i2] = x2;
        yz[i2] = y2;
        if (x2 < x0)
          x0 = x2;
        if (x2 > x1)
          x1 = x2;
        if (y2 < y0)
          y0 = y2;
        if (y2 > y1)
          y1 = y2;
      }
      if (x0 > x1 || y0 > y1)
        return this;
      this.cover(x0, y0).cover(x1, y1);
      for (i2 = 0; i2 < n; ++i2) {
        add(this, xz[i2], yz[i2], data[i2]);
      }
      return this;
    }
    function tree_cover(x2, y2) {
      if (isNaN(x2 = +x2) || isNaN(y2 = +y2))
        return this;
      var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x2)) + 1;
        y1 = (y0 = Math.floor(y2)) + 1;
      } else {
        var z2 = x1 - x0 || 1, node = this._root, parent, i2;
        while (x0 > x2 || x2 >= x1 || y0 > y2 || y2 >= y1) {
          i2 = (y2 < y0) << 1 | x2 < x0;
          parent = new Array(4), parent[i2] = node, node = parent, z2 *= 2;
          switch (i2) {
            case 0:
              x1 = x0 + z2, y1 = y0 + z2;
              break;
            case 1:
              x0 = x1 - z2, y1 = y0 + z2;
              break;
            case 2:
              x1 = x0 + z2, y0 = y1 - z2;
              break;
            case 3:
              x0 = x1 - z2, y0 = y1 - z2;
              break;
          }
        }
        if (this._root && this._root.length)
          this._root = node;
      }
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }
    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length)
          do
            data.push(node.data);
          while (node = node.next);
      });
      return data;
    }
    function tree_extent(_) {
      return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
    }
    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }
    function tree_find(x2, y2, radius) {
      var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q2, i2;
      if (node)
        quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null)
        radius = Infinity;
      else {
        x0 = x2 - radius, y0 = y2 - radius;
        x3 = x2 + radius, y3 = y2 + radius;
        radius *= radius;
      }
      while (q2 = quads.pop()) {
        if (!(node = q2.node) || (x1 = q2.x0) > x3 || (y1 = q2.y0) > y3 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0)
          continue;
        if (node.length) {
          var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
          quads.push(
            new Quad(node[3], xm, ym, x22, y22),
            new Quad(node[2], x1, ym, xm, y22),
            new Quad(node[1], xm, y1, x22, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );
          if (i2 = (y2 >= ym) << 1 | x2 >= xm) {
            q2 = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i2];
            quads[quads.length - 1 - i2] = q2;
          }
        } else {
          var dx = x2 - +this._x.call(null, node.data), dy = y2 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x2 - d, y0 = y2 - d;
            x3 = x2 + d, y3 = y2 + d;
            data = node.data;
          }
        }
      }
      return data;
    }
    function tree_remove(d) {
      if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d)))
        return this;
      var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x2, y2, xm, ym, right, bottom, i2, j;
      if (!node)
        return this;
      if (node.length)
        while (true) {
          if (right = x2 >= (xm = (x0 + x1) / 2))
            x0 = xm;
          else
            x1 = xm;
          if (bottom = y2 >= (ym = (y0 + y1) / 2))
            y0 = ym;
          else
            y1 = ym;
          if (!(parent = node, node = node[i2 = bottom << 1 | right]))
            return this;
          if (!node.length)
            break;
          if (parent[i2 + 1 & 3] || parent[i2 + 2 & 3] || parent[i2 + 3 & 3])
            retainer = parent, j = i2;
        }
      while (node.data !== d)
        if (!(previous = node, node = node.next))
          return this;
      if (next = node.next)
        delete node.next;
      if (previous)
        return next ? previous.next = next : delete previous.next, this;
      if (!parent)
        return this._root = next, this;
      next ? parent[i2] = next : delete parent[i2];
      if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
        if (retainer)
          retainer[j] = node;
        else
          this._root = node;
      }
      return this;
    }
    function removeAll(data) {
      for (var i2 = 0, n = data.length; i2 < n; ++i2)
        this.remove(data[i2]);
      return this;
    }
    function tree_root() {
      return this._root;
    }
    function tree_size() {
      var size2 = 0;
      this.visit(function(node) {
        if (!node.length)
          do
            ++size2;
          while (node = node.next);
      });
      return size2;
    }
    function tree_visit(callback) {
      var quads = [], q2, node = this._root, child, x0, y0, x1, y1;
      if (node)
        quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q2 = quads.pop()) {
        if (!callback(node = q2.node, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3])
            quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2])
            quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1])
            quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0])
            quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }
    function tree_visitAfter(callback) {
      var quads = [], next = [], q2;
      if (this._root)
        quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q2 = quads.pop()) {
        var node = q2.node;
        if (node.length) {
          var child, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0])
            quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1])
            quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2])
            quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3])
            quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q2);
      }
      while (q2 = next.pop()) {
        callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
      }
      return this;
    }
    function defaultX(d) {
      return d[0];
    }
    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }
    function defaultY(d) {
      return d[1];
    }
    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }
    function quadtree(nodes, x2, y2) {
      var tree = new Quadtree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }
    function Quadtree(x2, y2, x0, y0, x1, y1) {
      this._x = x2;
      this._y = y2;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = void 0;
    }
    function leaf_copy(leaf) {
      var copy2 = { data: leaf.data }, next = copy2;
      while (leaf = leaf.next)
        next = next.next = { data: leaf.data };
      return copy2;
    }
    var treeProto = quadtree.prototype = Quadtree.prototype;
    treeProto.copy = function() {
      var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
      if (!node)
        return copy2;
      if (!node.length)
        return copy2._root = leaf_copy(node), copy2;
      nodes = [{ source: node, target: copy2._root = new Array(4) }];
      while (node = nodes.pop()) {
        for (var i2 = 0; i2 < 4; ++i2) {
          if (child = node.source[i2]) {
            if (child.length)
              nodes.push({ source: child, target: node.target[i2] = new Array(4) });
            else
              node.target[i2] = leaf_copy(child);
          }
        }
      }
      return copy2;
    };
    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;
    function constant$2(x2) {
      return function() {
        return x2;
      };
    }
    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }
    function index$1(d) {
      return d.index;
    }
    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node)
        throw new Error("node not found: " + nodeId);
      return node;
    }
    function link(links) {
      var id2 = index$1, strength = defaultStrength, strengths, distance2 = constant$2(30), distances, nodes, count, bias, random, iterations = 1;
      if (links == null)
        links = [];
      function defaultStrength(link2) {
        return 1 / Math.min(count[link2.source.index], count[link2.target.index]);
      }
      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i2 = 0, link2, source, target, x2, y2, l, b; i2 < n; ++i2) {
            link2 = links[i2], source = link2.source, target = link2.target;
            x2 = target.x + target.vx - source.x - source.vx || jiggle(random);
            y2 = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x2 * x2 + y2 * y2);
            l = (l - distances[i2]) / l * alpha * strengths[i2];
            x2 *= l, y2 *= l;
            target.vx -= x2 * (b = bias[i2]);
            target.vy -= y2 * b;
            source.vx += x2 * (b = 1 - b);
            source.vy += y2 * b;
          }
        }
      }
      function initialize() {
        if (!nodes)
          return;
        var i2, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d, i3) => [id2(d, i3, nodes), d])), link2;
        for (i2 = 0, count = new Array(n); i2 < m2; ++i2) {
          link2 = links[i2], link2.index = i2;
          if (typeof link2.source !== "object")
            link2.source = find(nodeById, link2.source);
          if (typeof link2.target !== "object")
            link2.target = find(nodeById, link2.target);
          count[link2.source.index] = (count[link2.source.index] || 0) + 1;
          count[link2.target.index] = (count[link2.target.index] || 0) + 1;
        }
        for (i2 = 0, bias = new Array(m2); i2 < m2; ++i2) {
          link2 = links[i2], bias[i2] = count[link2.source.index] / (count[link2.source.index] + count[link2.target.index]);
        }
        strengths = new Array(m2), initializeStrength();
        distances = new Array(m2), initializeDistance();
      }
      function initializeStrength() {
        if (!nodes)
          return;
        for (var i2 = 0, n = links.length; i2 < n; ++i2) {
          strengths[i2] = +strength(links[i2], i2, links);
        }
      }
      function initializeDistance() {
        if (!nodes)
          return;
        for (var i2 = 0, n = links.length; i2 < n; ++i2) {
          distances[i2] = +distance2(links[i2], i2, links);
        }
      }
      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };
      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };
      force.id = function(_) {
        return arguments.length ? (id2 = _, force) : id2;
      };
      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };
      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initializeStrength(), force) : strength;
      };
      force.distance = function(_) {
        return arguments.length ? (distance2 = typeof _ === "function" ? _ : constant$2(+_), initializeDistance(), force) : distance2;
      };
      return force;
    }
    const a$1 = 1664525;
    const c$1 = 1013904223;
    const m = 4294967296;
    function lcg() {
      let s = 1;
      return () => (s = (a$1 * s + c$1) % m) / m;
    }
    function x$1(d) {
      return d.x;
    }
    function y$1(d) {
      return d.y;
    }
    var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
    function simulation(nodes) {
      var simulation2, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch("tick", "end"), random = lcg();
      if (nodes == null)
        nodes = [];
      function step() {
        tick();
        event.call("tick", simulation2);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation2);
        }
      }
      function tick(iterations) {
        var i2, n = nodes.length, node;
        if (iterations === void 0)
          iterations = 1;
        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;
          forces.forEach(function(force) {
            force(alpha);
          });
          for (i2 = 0; i2 < n; ++i2) {
            node = nodes[i2];
            if (node.fx == null)
              node.x += node.vx *= velocityDecay;
            else
              node.x = node.fx, node.vx = 0;
            if (node.fy == null)
              node.y += node.vy *= velocityDecay;
            else
              node.y = node.fy, node.vy = 0;
          }
        }
        return simulation2;
      }
      function initializeNodes() {
        for (var i2 = 0, n = nodes.length, node; i2 < n; ++i2) {
          node = nodes[i2], node.index = i2;
          if (node.fx != null)
            node.x = node.fx;
          if (node.fy != null)
            node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i2), angle2 = i2 * initialAngle;
            node.x = radius * Math.cos(angle2);
            node.y = radius * Math.sin(angle2);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }
      function initializeForce(force) {
        if (force.initialize)
          force.initialize(nodes, random);
        return force;
      }
      initializeNodes();
      return simulation2 = {
        tick,
        restart: function() {
          return stepper.restart(step), simulation2;
        },
        stop: function() {
          return stepper.stop(), simulation2;
        },
        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation2) : nodes;
        },
        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation2) : alpha;
        },
        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation2) : alphaMin;
        },
        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation2) : +alphaDecay;
        },
        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation2) : alphaTarget;
        },
        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation2) : 1 - velocityDecay;
        },
        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation2) : random;
        },
        force: function(name, _) {
          return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation2) : forces.get(name);
        },
        find: function(x2, y2, radius) {
          var i2 = 0, n = nodes.length, dx, dy, d2, node, closest;
          if (radius == null)
            radius = Infinity;
          else
            radius *= radius;
          for (i2 = 0; i2 < n; ++i2) {
            node = nodes[i2];
            dx = x2 - node.x;
            dy = y2 - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius)
              closest = node, radius = d2;
          }
          return closest;
        },
        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation2) : event.on(name);
        }
      };
    }
    function manyBody() {
      var nodes, node, random, alpha, strength = constant$2(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
      function force(_) {
        var i2, n = nodes.length, tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate);
        for (alpha = _, i2 = 0; i2 < n; ++i2)
          node = nodes[i2], tree.visit(apply);
      }
      function initialize() {
        if (!nodes)
          return;
        var i2, n = nodes.length, node2;
        strengths = new Array(n);
        for (i2 = 0; i2 < n; ++i2)
          node2 = nodes[i2], strengths[node2.index] = +strength(node2, i2, nodes);
      }
      function accumulate(quad) {
        var strength2 = 0, q2, c2, weight = 0, x2, y2, i2;
        if (quad.length) {
          for (x2 = y2 = i2 = 0; i2 < 4; ++i2) {
            if ((q2 = quad[i2]) && (c2 = Math.abs(q2.value))) {
              strength2 += q2.value, weight += c2, x2 += c2 * q2.x, y2 += c2 * q2.y;
            }
          }
          quad.x = x2 / weight;
          quad.y = y2 / weight;
        } else {
          q2 = quad;
          q2.x = q2.data.x;
          q2.y = q2.data.y;
          do
            strength2 += strengths[q2.data.index];
          while (q2 = q2.next);
        }
        quad.value = strength2;
      }
      function apply(quad, x1, _, x2) {
        if (!quad.value)
          return true;
        var x3 = quad.x - node.x, y2 = quad.y - node.y, w = x2 - x1, l = x3 * x3 + y2 * y2;
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x3 === 0)
              x3 = jiggle(random), l += x3 * x3;
            if (y2 === 0)
              y2 = jiggle(random), l += y2 * y2;
            if (l < distanceMin2)
              l = Math.sqrt(distanceMin2 * l);
            node.vx += x3 * quad.value * alpha / l;
            node.vy += y2 * quad.value * alpha / l;
          }
          return true;
        } else if (quad.length || l >= distanceMax2)
          return;
        if (quad.data !== node || quad.next) {
          if (x3 === 0)
            x3 = jiggle(random), l += x3 * x3;
          if (y2 === 0)
            y2 = jiggle(random), l += y2 * y2;
          if (l < distanceMin2)
            l = Math.sqrt(distanceMin2 * l);
        }
        do
          if (quad.data !== node) {
            w = strengths[quad.data.index] * alpha / l;
            node.vx += x3 * w;
            node.vy += y2 * w;
          }
        while (quad = quad.next);
      }
      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };
      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
      };
      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };
      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };
      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };
      return force;
    }
    function x(x2) {
      var strength = constant$2(0.1), nodes, strengths, xz;
      if (typeof x2 !== "function")
        x2 = constant$2(x2 == null ? 0 : +x2);
      function force(alpha) {
        for (var i2 = 0, n = nodes.length, node; i2 < n; ++i2) {
          node = nodes[i2], node.vx += (xz[i2] - node.x) * strengths[i2] * alpha;
        }
      }
      function initialize() {
        if (!nodes)
          return;
        var i2, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i2 = 0; i2 < n; ++i2) {
          strengths[i2] = isNaN(xz[i2] = +x2(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
        }
      }
      force.initialize = function(_) {
        nodes = _;
        initialize();
      };
      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
      };
      force.x = function(_) {
        return arguments.length ? (x2 = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : x2;
      };
      return force;
    }
    function y(y2) {
      var strength = constant$2(0.1), nodes, strengths, yz;
      if (typeof y2 !== "function")
        y2 = constant$2(y2 == null ? 0 : +y2);
      function force(alpha) {
        for (var i2 = 0, n = nodes.length, node; i2 < n; ++i2) {
          node = nodes[i2], node.vy += (yz[i2] - node.y) * strengths[i2] * alpha;
        }
      }
      function initialize() {
        if (!nodes)
          return;
        var i2, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i2 = 0; i2 < n; ++i2) {
          strengths[i2] = isNaN(yz[i2] = +y2(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
        }
      }
      force.initialize = function(_) {
        nodes = _;
        initialize();
      };
      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : strength;
      };
      force.y = function(_) {
        return arguments.length ? (y2 = typeof _ === "function" ? _ : constant$2(+_), initialize(), force) : y2;
      };
      return force;
    }
    function formatDecimal(x2) {
      return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
    }
    function formatDecimalParts(x2, p2) {
      if ((i2 = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0)
        return null;
      var i2, coefficient = x2.slice(0, i2);
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x2.slice(i2 + 1)
      ];
    }
    function exponent(x2) {
      return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
    }
    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i2 = value.length, t = [], j = 0, g = grouping[0], length = 0;
        while (i2 > 0 && g > 0) {
          if (length + g + 1 > width)
            g = Math.max(1, width - length);
          t.push(value.substring(i2 -= g, i2 + g));
          if ((length += g + 1) > width)
            break;
          g = grouping[j = (j + 1) % grouping.length];
        }
        return t.reverse().join(thousands);
      };
    }
    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i2) {
          return numerals[+i2];
        });
      };
    }
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier)))
        throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }
    formatSpecifier.prototype = FormatSpecifier.prototype;
    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
      this.align = specifier.align === void 0 ? ">" : specifier.align + "";
      this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === void 0 ? void 0 : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === void 0 ? "" : specifier.type + "";
    }
    FormatSpecifier.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
    function formatTrim(s) {
      out:
        for (var n = s.length, i2 = 1, i0 = -1, i1; i2 < n; ++i2) {
          switch (s[i2]) {
            case ".":
              i0 = i1 = i2;
              break;
            case "0":
              if (i0 === 0)
                i0 = i2;
              i1 = i2;
              break;
            default:
              if (!+s[i2])
                break out;
              if (i0 > 0)
                i0 = 0;
              break;
          }
        }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }
    var prefixExponent;
    function formatPrefixAuto(x2, p2) {
      var d = formatDecimalParts(x2, p2);
      if (!d)
        return x2 + "";
      var coefficient = d[0], exponent2 = d[1], i2 = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
      return i2 === n ? coefficient : i2 > n ? coefficient + new Array(i2 - n + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i2 - 1))[0];
    }
    function formatRounded(x2, p2) {
      var d = formatDecimalParts(x2, p2);
      if (!d)
        return x2 + "";
      var coefficient = d[0], exponent2 = d[1];
      return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
    }
    const formatTypes = {
      "%": (x2, p2) => (x2 * 100).toFixed(p2),
      "b": (x2) => Math.round(x2).toString(2),
      "c": (x2) => x2 + "",
      "d": formatDecimal,
      "e": (x2, p2) => x2.toExponential(p2),
      "f": (x2, p2) => x2.toFixed(p2),
      "g": (x2, p2) => x2.toPrecision(p2),
      "o": (x2) => Math.round(x2).toString(8),
      "p": (x2, p2) => formatRounded(x2 * 100, p2),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
      "x": (x2) => Math.round(x2).toString(16)
    };
    function identity$2(x2) {
      return x2;
    }
    var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale(locale2) {
      var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$2 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$2 : formatNumerals(map$1.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);
        var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
        if (type === "n")
          comma = true, type = "g";
        else if (!formatTypes[type])
          precision === void 0 && (precision = 12), trim2 = true, type = "g";
        if (zero2 || fill === "0" && align === "=")
          zero2 = true, fill = "0", align = "=";
        var prefix2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
        var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
        precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
        function format2(value) {
          var valuePrefix = prefix2, valueSuffix = suffix, i2, n, c2;
          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;
            var valueNegative = value < 0 || 1 / value < 0;
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
            if (trim2)
              value = formatTrim(value);
            if (valueNegative && +value === 0 && sign !== "+")
              valueNegative = false;
            valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
            if (maybeSuffix) {
              i2 = -1, n = value.length;
              while (++i2 < n) {
                if (c2 = value.charCodeAt(i2), 48 > c2 || c2 > 57) {
                  valueSuffix = (c2 === 46 ? decimal + value.slice(i2 + 1) : value.slice(i2)) + valueSuffix;
                  value = value.slice(0, i2);
                  break;
                }
              }
            }
          }
          if (comma && !zero2)
            value = group(value, Infinity);
          var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
          if (comma && zero2)
            value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
          switch (align) {
            case "<":
              value = valuePrefix + value + valueSuffix + padding;
              break;
            case "=":
              value = valuePrefix + padding + value + valueSuffix;
              break;
            case "^":
              value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
              break;
            default:
              value = padding + valuePrefix + value + valueSuffix;
              break;
          }
          return numerals(value);
        }
        format2.toString = function() {
          return specifier + "";
        };
        return format2;
      }
      function formatPrefix2(specifier, value) {
        var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e3), prefix2 = prefixes[8 + e3 / 3];
        return function(value2) {
          return f2(k * value2) + prefix2;
        };
      }
      return {
        format: newFormat,
        formatPrefix: formatPrefix2
      };
    }
    var locale;
    var format;
    var formatPrefix;
    defaultLocale({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
    function defaultLocale(definition) {
      locale = formatLocale(definition);
      format = locale.format;
      formatPrefix = locale.formatPrefix;
      return locale;
    }
    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }
    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }
    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }
    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0:
          break;
        case 1: {
          if (typeof domain === "function")
            this.interpolator(domain);
          else
            this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function")
            this.interpolator(interpolator);
          else
            this.range(interpolator);
          break;
        }
      }
      return this;
    }
    function identity$1(x2) {
      return x2;
    }
    function tickFormat(start2, stop, count, specifier) {
      var step = tickStep(start2, stop, count), precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start2), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
            specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop)))))
            specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
            specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }
    function linearish(scale) {
      var domain = scale.domain;
      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };
      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };
      scale.nice = function(count) {
        if (count == null)
          count = 10;
        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start2 = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;
        if (stop < start2) {
          step = start2, start2 = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        while (maxIter-- > 0) {
          step = tickIncrement(start2, stop, count);
          if (step === prestep) {
            d[i0] = start2;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start2 = Math.floor(start2 / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start2 = Math.ceil(start2 * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }
        return scale;
      };
      return scale;
    }
    function transformer() {
      var x0 = 0, x1 = 1, t0, t1, k10, transform2, interpolator = identity$1, clamp = false, unknown;
      function scale(x2) {
        return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform2(x2) - t0) * k10, clamp ? Math.max(0, Math.min(1, x2)) : x2));
      }
      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform2(x0 = +x0), t1 = transform2(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };
      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };
      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };
      function range(interpolate2) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }
      scale.range = range(interpolate$1);
      scale.rangeRound = range(interpolateRound);
      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };
      return function(t) {
        transform2 = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }
    function copy(source, target) {
      return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
    }
    function sequential() {
      var scale = linearish(transformer()(identity$1));
      scale.copy = function() {
        return copy(scale, sequential());
      };
      return initInterpolator.apply(scale, arguments);
    }
    cubehelixLong(cubehelix$1(-100, 0.75, 0.35), cubehelix$1(80, 1.5, 0.8));
    cubehelixLong(cubehelix$1(260, 0.75, 0.35), cubehelix$1(80, 1.5, 0.8));
    var c = cubehelix$1();
    function rainbow(t) {
      if (t < 0 || t > 1)
        t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c.h = 360 * t - 100;
      c.s = 1.5 - 1.5 * ts;
      c.l = 0.8 - 0.9 * ts;
      return c + "";
    }
    const constant$1 = (x2) => () => x2;
    function ZoomEvent(type, {
      sourceEvent: sourceEvent2,
      target,
      transform: transform2,
      dispatch: dispatch2
    }) {
      Object.defineProperties(this, {
        type: { value: type, enumerable: true, configurable: true },
        sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
        target: { value: target, enumerable: true, configurable: true },
        transform: { value: transform2, enumerable: true, configurable: true },
        _: { value: dispatch2 }
      });
    }
    function Transform(k, x2, y2) {
      this.k = k;
      this.x = x2;
      this.y = y2;
    }
    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x2, y2) {
        return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x2) {
        return x2 * this.k + this.x;
      },
      applyY: function(y2) {
        return y2 * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x2) {
        return (x2 - this.x) / this.k;
      },
      invertY: function(y2) {
        return (y2 - this.y) / this.k;
      },
      rescaleX: function(x2) {
        return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
      },
      rescaleY: function(y2) {
        return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };
    var identity = new Transform(1, 0, 0);
    Transform.prototype;
    function nopropagation(event) {
      event.stopImmediatePropagation();
    }
    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === "wheel") && !event.button;
    }
    function defaultExtent() {
      var e3 = this;
      if (e3 instanceof SVGElement) {
        e3 = e3.ownerSVGElement || e3;
        if (e3.hasAttribute("viewBox")) {
          e3 = e3.viewBox.baseVal;
          return [[e3.x, e3.y], [e3.x + e3.width, e3.y + e3.height]];
        }
        return [[0, 0], [e3.width.baseVal.value, e3.height.baseVal.value]];
      }
      return [[0, 0], [e3.clientWidth, e3.clientHeight]];
    }
    function defaultTransform() {
      return this.__zoom || identity;
    }
    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
    }
    function defaultTouchable() {
      return navigator.maxTouchPoints || "ontouchstart" in this;
    }
    function defaultConstrain(transform2, extent, translateExtent) {
      var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
      return transform2.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }
    function zoom() {
      var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration2 = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
      function zoom2(selection2) {
        selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }
      zoom2.transform = function(collection, transform2, point, event) {
        var selection2 = collection.selection ? collection.selection() : collection;
        selection2.property("__zoom", defaultTransform);
        if (collection !== selection2) {
          schedule2(collection, transform2, point, event);
        } else {
          selection2.interrupt().each(function() {
            gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
          });
        }
      };
      zoom2.scaleBy = function(selection2, k, p2, event) {
        zoom2.scaleTo(selection2, function() {
          var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p2, event);
      };
      zoom2.scaleTo = function(selection2, k, p2, event) {
        zoom2.transform(selection2, function() {
          var e3 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p2 == null ? centroid(e3) : typeof p2 === "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate2(scale(t0, k1), p0, p1), e3, translateExtent);
        }, p2, event);
      };
      zoom2.translateBy = function(selection2, x2, y2, event) {
        zoom2.transform(selection2, function() {
          return constrain(this.__zoom.translate(
            typeof x2 === "function" ? x2.apply(this, arguments) : x2,
            typeof y2 === "function" ? y2.apply(this, arguments) : y2
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };
      zoom2.translateTo = function(selection2, x2, y2, p2, event) {
        zoom2.transform(selection2, function() {
          var e3 = extent.apply(this, arguments), t = this.__zoom, p0 = p2 == null ? centroid(e3) : typeof p2 === "function" ? p2.apply(this, arguments) : p2;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
            typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
          ), e3, translateExtent);
        }, p2, event);
      };
      function scale(transform2, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
      }
      function translate2(transform2, p0, p1) {
        var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
        return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
      }
      function centroid(extent2) {
        return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
      }
      function schedule2(transition, transform2, point, event) {
        transition.on("start.zoom", function() {
          gesture(this, arguments).event(event).start();
        }).on("interrupt.zoom end.zoom", function() {
          gesture(this, arguments).event(event).end();
        }).tween("zoom", function() {
          var that = this, args = arguments, g = gesture(that, args).event(event), e3 = extent.apply(that, args), p2 = point == null ? centroid(e3) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e3[1][0] - e3[0][0], e3[1][1] - e3[0][1]), a2 = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i2 = interpolate2(a2.invert(p2).concat(w / a2.k), b.invert(p2).concat(w / b.k));
          return function(t) {
            if (t === 1)
              t = b;
            else {
              var l = i2(t), k = w / l[2];
              t = new Transform(k, p2[0] - l[0] * k, p2[1] - l[1] * k);
            }
            g.zoom(null, t);
          };
        });
      }
      function gesture(that, args, clean) {
        return !clean && that.__zooming || new Gesture(that, args);
      }
      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }
      Gesture.prototype = {
        event: function(event) {
          if (event)
            this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform2) {
          if (this.mouse && key !== "mouse")
            this.mouse[1] = transform2.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch")
            this.touch0[1] = transform2.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch")
            this.touch1[1] = transform2.invert(this.touch1[0]);
          this.that.__zoom = transform2;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select$1(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom2,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };
      function wheeled(event, ...args) {
        if (!filter2.apply(this, arguments))
          return;
        var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p2 = pointer(event);
        if (g.wheel) {
          if (g.mouse[0][0] !== p2[0] || g.mouse[0][1] !== p2[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p2);
          }
          clearTimeout(g.wheel);
        } else if (t.k === k)
          return;
        else {
          g.mouse = [p2, t.invert(p2)];
          interrupt(this);
          g.start();
        }
        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate2(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }
      function mousedowned(event, ...args) {
        if (touchending || !filter2.apply(this, arguments))
          return;
        var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select$1(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p2 = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p2, this.__zoom.invert(p2)];
        interrupt(this);
        g.start();
        function mousemoved(event2) {
          noevent(event2);
          if (!g.moved) {
            var dx = event2.clientX - x0, dy = event2.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event2).zoom("mouse", constrain(translate2(g.that.__zoom, g.mouse[0] = pointer(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }
        function mouseupped(event2) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event2.view, g.moved);
          noevent(event2);
          g.event(event2).end();
        }
      }
      function dblclicked(event, ...args) {
        if (!filter2.apply(this, arguments))
          return;
        var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate2(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
        noevent(event);
        if (duration2 > 0)
          select$1(this).transition().duration(duration2).call(schedule2, t1, p0, event);
        else
          select$1(this).call(zoom2.transform, t1, p0, event);
      }
      function touchstarted(event, ...args) {
        if (!filter2.apply(this, arguments))
          return;
        var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i2, t, p2;
        nopropagation(event);
        for (i2 = 0; i2 < n; ++i2) {
          t = touches[i2], p2 = pointer(t, this);
          p2 = [p2, this.__zoom.invert(p2), t.identifier];
          if (!g.touch0)
            g.touch0 = p2, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p2[2])
            g.touch1 = p2, g.taps = 0;
        }
        if (touchstarting)
          touchstarting = clearTimeout(touchstarting);
        if (started) {
          if (g.taps < 2)
            touchfirst = p2[0], touchstarting = setTimeout(function() {
              touchstarting = null;
            }, touchDelay);
          interrupt(this);
          g.start();
        }
      }
      function touchmoved(event, ...args) {
        if (!this.__zooming)
          return;
        var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i2, t, p2, l;
        noevent(event);
        for (i2 = 0; i2 < n; ++i2) {
          t = touches[i2], p2 = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier)
            g.touch0[0] = p2;
          else if (g.touch1 && g.touch1[2] === t.identifier)
            g.touch1[0] = p2;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        } else if (g.touch0)
          p2 = g.touch0[0], l = g.touch0[1];
        else
          return;
        g.zoom("touch", constrain(translate2(t, p2, l), g.extent, translateExtent));
      }
      function touchended(event, ...args) {
        if (!this.__zooming)
          return;
        var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i2, t;
        nopropagation(event);
        if (touchending)
          clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, touchDelay);
        for (i2 = 0; i2 < n; ++i2) {
          t = touches[i2];
          if (g.touch0 && g.touch0[2] === t.identifier)
            delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier)
            delete g.touch1;
        }
        if (g.touch1 && !g.touch0)
          g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0)
          g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p2 = select$1(this).on("dblclick.zoom");
              if (p2)
                p2.apply(this, arguments);
            }
          }
        }
      }
      zoom2.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$1(+_), zoom2) : wheelDelta;
      };
      zoom2.filter = function(_) {
        return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant$1(!!_), zoom2) : filter2;
      };
      zoom2.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$1(!!_), zoom2) : touchable;
      };
      zoom2.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$1([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
      };
      zoom2.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
      };
      zoom2.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };
      zoom2.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom2) : constrain;
      };
      zoom2.duration = function(_) {
        return arguments.length ? (duration2 = +_, zoom2) : duration2;
      };
      zoom2.interpolate = function(_) {
        return arguments.length ? (interpolate2 = _, zoom2) : interpolate2;
      };
      zoom2.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom2 : value;
      };
      zoom2.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
      };
      zoom2.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
      };
      return zoom2;
    }
    var prefix = "$";
    function Map$1() {
    }
    Map$1.prototype = map.prototype = {
      constructor: Map$1,
      has: function(key) {
        return prefix + key in this;
      },
      get: function(key) {
        return this[prefix + key];
      },
      set: function(key, value) {
        this[prefix + key] = value;
        return this;
      },
      remove: function(key) {
        var property = prefix + key;
        return property in this && delete this[property];
      },
      clear: function() {
        for (var property in this)
          if (property[0] === prefix)
            delete this[property];
      },
      keys: function() {
        var keys2 = [];
        for (var property in this)
          if (property[0] === prefix)
            keys2.push(property.slice(1));
        return keys2;
      },
      values: function() {
        var values = [];
        for (var property in this)
          if (property[0] === prefix)
            values.push(this[property]);
        return values;
      },
      entries: function() {
        var entries = [];
        for (var property in this)
          if (property[0] === prefix)
            entries.push({ key: property.slice(1), value: this[property] });
        return entries;
      },
      size: function() {
        var size2 = 0;
        for (var property in this)
          if (property[0] === prefix)
            ++size2;
        return size2;
      },
      empty: function() {
        for (var property in this)
          if (property[0] === prefix)
            return false;
        return true;
      },
      each: function(f2) {
        for (var property in this)
          if (property[0] === prefix)
            f2(this[property], property.slice(1), this);
      }
    };
    function map(object2, f2) {
      var map2 = new Map$1();
      if (object2 instanceof Map$1)
        object2.each(function(value, key2) {
          map2.set(key2, value);
        });
      else if (Array.isArray(object2)) {
        var i2 = -1, n = object2.length, o;
        if (f2 == null)
          while (++i2 < n)
            map2.set(i2, object2[i2]);
        else
          while (++i2 < n)
            map2.set(f2(o = object2[i2], i2, object2), o);
      } else if (object2)
        for (var key in object2)
          map2.set(key, object2[key]);
      return map2;
    }
    function Set$1() {
    }
    var proto = map.prototype;
    Set$1.prototype = {
      constructor: Set$1,
      has: proto.has,
      add: function(value) {
        value += "";
        this[prefix + value] = value;
        return this;
      },
      remove: proto.remove,
      clear: proto.clear,
      values: proto.keys,
      size: proto.size,
      empty: proto.empty,
      each: proto.each
    };
    var xhtml = "http://www.w3.org/1999/xhtml";
    const namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
    function namespace(name) {
      var prefix2 = name += "", i2 = prefix2.indexOf(":");
      if (i2 >= 0 && (prefix2 = name.slice(0, i2)) !== "xmlns")
        name = name.slice(i2 + 1);
      return namespaces.hasOwnProperty(prefix2) ? { space: namespaces[prefix2], local: name } : name;
    }
    function creatorInherit(name) {
      return function() {
        var document2 = this.ownerDocument, uri = this.namespaceURI;
        return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
      };
    }
    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }
    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local ? creatorFixed : creatorInherit)(fullname);
    }
    function none() {
    }
    function selector(selector2) {
      return selector2 == null ? none : function() {
        return this.querySelector(selector2);
      };
    }
    function selection_select(select2) {
      if (typeof select2 !== "function")
        select2 = selector(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i2 = 0; i2 < n; ++i2) {
          if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
            if ("__data__" in node)
              subnode.__data__ = node.__data__;
            subgroup[i2] = subnode;
          }
        }
      }
      return new Selection(subgroups, this._parents);
    }
    function empty() {
      return [];
    }
    function selectorAll(selector2) {
      return selector2 == null ? empty : function() {
        return this.querySelectorAll(selector2);
      };
    }
    function selection_selectAll(select2) {
      if (typeof select2 !== "function")
        select2 = selectorAll(select2);
      for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
          if (node = group[i2]) {
            subgroups.push(select2.call(node, node.__data__, i2, group));
            parents.push(node);
          }
        }
      }
      return new Selection(subgroups, parents);
    }
    function matcher(selector2) {
      return function() {
        return this.matches(selector2);
      };
    }
    function selection_filter(match) {
      if (typeof match !== "function")
        match = matcher(match);
      for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n; ++i2) {
          if ((node = group[i2]) && match.call(node, node.__data__, i2, group)) {
            subgroup.push(node);
          }
        }
      }
      return new Selection(subgroups, this._parents);
    }
    function sparse(update) {
      return new Array(update.length);
    }
    function selection_enter() {
      return new Selection(this._enter || this._groups.map(sparse), this._parents);
    }
    function EnterNode(parent, datum2) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum2;
    }
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function(selector2) {
        return this._parent.querySelector(selector2);
      },
      querySelectorAll: function(selector2) {
        return this._parent.querySelectorAll(selector2);
      }
    };
    function constant(x2) {
      return function() {
        return x2;
      };
    }
    var keyPrefix = "$";
    function bindIndex(parent, group, enter, update, exit, data) {
      var i2 = 0, node, groupLength = group.length, dataLength = data.length;
      for (; i2 < dataLength; ++i2) {
        if (node = group[i2]) {
          node.__data__ = data[i2];
          update[i2] = node;
        } else {
          enter[i2] = new EnterNode(parent, data[i2]);
        }
      }
      for (; i2 < groupLength; ++i2) {
        if (node = group[i2]) {
          exit[i2] = node;
        }
      }
    }
    function bindKey(parent, group, enter, update, exit, data, key) {
      var i2, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
      for (i2 = 0; i2 < groupLength; ++i2) {
        if (node = group[i2]) {
          keyValues[i2] = keyValue = keyPrefix + key.call(node, node.__data__, i2, group);
          if (keyValue in nodeByKeyValue) {
            exit[i2] = node;
          } else {
            nodeByKeyValue[keyValue] = node;
          }
        }
      }
      for (i2 = 0; i2 < dataLength; ++i2) {
        keyValue = keyPrefix + key.call(parent, data[i2], i2, data);
        if (node = nodeByKeyValue[keyValue]) {
          update[i2] = node;
          node.__data__ = data[i2];
          nodeByKeyValue[keyValue] = null;
        } else {
          enter[i2] = new EnterNode(parent, data[i2]);
        }
      }
      for (i2 = 0; i2 < groupLength; ++i2) {
        if ((node = group[i2]) && nodeByKeyValue[keyValues[i2]] === node) {
          exit[i2] = node;
        }
      }
    }
    function selection_data(value, key) {
      if (!value) {
        data = new Array(this.size()), j = -1;
        this.each(function(d) {
          data[++j] = d;
        });
        return data;
      }
      var bind2 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
      if (typeof value !== "function")
        value = constant(value);
      for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
        var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
        bind2(parent, group, enterGroup, updateGroup, exitGroup, data, key);
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1)
              i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength)
              ;
            previous._next = next || null;
          }
        }
      }
      update = new Selection(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }
    function selection_exit() {
      return new Selection(this._exit || this._groups.map(sparse), this._parents);
    }
    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
      if (onupdate != null)
        update = onupdate(update);
      if (onexit == null)
        exit.remove();
      else
        onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }
    function selection_merge(selection2) {
      for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
          if (node = group0[i2] || group1[i2]) {
            merge2[i2] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Selection(merges, this._parents);
    }
    function selection_order() {
      for (var groups = this._groups, j = -1, m2 = groups.length; ++j < m2; ) {
        for (var group = groups[j], i2 = group.length - 1, next = group[i2], node; --i2 >= 0; ) {
          if (node = group[i2]) {
            if (next && node.compareDocumentPosition(next) ^ 4)
              next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }
      return this;
    }
    function selection_sort(compare) {
      if (!compare)
        compare = ascending;
      function compareNode(a2, b) {
        return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
      }
      for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
          if (node = group[i2]) {
            sortgroup[i2] = node;
          }
        }
        sortgroup.sort(compareNode);
      }
      return new Selection(sortgroups, this._parents).order();
    }
    function ascending(a2, b) {
      return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
    }
    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }
    function selection_nodes() {
      var nodes = new Array(this.size()), i2 = -1;
      this.each(function() {
        nodes[++i2] = this;
      });
      return nodes;
    }
    function selection_node() {
      for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
        for (var group = groups[j], i2 = 0, n = group.length; i2 < n; ++i2) {
          var node = group[i2];
          if (node)
            return node;
        }
      }
      return null;
    }
    function selection_size() {
      var size2 = 0;
      this.each(function() {
        ++size2;
      });
      return size2;
    }
    function selection_empty() {
      return !this.node();
    }
    function selection_each(callback) {
      for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
        for (var group = groups[j], i2 = 0, n = group.length, node; i2 < n; ++i2) {
          if (node = group[i2])
            callback.call(node, node.__data__, i2, group);
        }
      }
      return this;
    }
    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }
    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }
    function attrConstantNS(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }
    function attrFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.removeAttribute(name);
        else
          this.setAttribute(name, v);
      };
    }
    function attrFunctionNS(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.removeAttributeNS(fullname.space, fullname.local);
        else
          this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }
    function selection_attr(name, value) {
      var fullname = namespace(name);
      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
      }
      return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
    }
    function defaultView(node) {
      return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
    }
    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }
    function styleConstant(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }
    function styleFunction(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.style.removeProperty(name);
        else
          this.style.setProperty(name, v, priority);
      };
    }
    function selection_style(name, value, priority) {
      return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
    }
    function styleValue(node, name) {
      return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }
    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }
    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }
    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          delete this[name];
        else
          this[name] = v;
      };
    }
    function selection_property(name, value) {
      return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
    }
    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }
    function classList(node) {
      return node.classList || new ClassList(node);
    }
    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }
    ClassList.prototype = {
      add: function(name) {
        var i2 = this._names.indexOf(name);
        if (i2 < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i2 = this._names.indexOf(name);
        if (i2 >= 0) {
          this._names.splice(i2, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };
    function classedAdd(node, names2) {
      var list = classList(node), i2 = -1, n = names2.length;
      while (++i2 < n)
        list.add(names2[i2]);
    }
    function classedRemove(node, names2) {
      var list = classList(node), i2 = -1, n = names2.length;
      while (++i2 < n)
        list.remove(names2[i2]);
    }
    function classedTrue(names2) {
      return function() {
        classedAdd(this, names2);
      };
    }
    function classedFalse(names2) {
      return function() {
        classedRemove(this, names2);
      };
    }
    function classedFunction(names2, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names2);
      };
    }
    function selection_classed(name, value) {
      var names2 = classArray(name + "");
      if (arguments.length < 2) {
        var list = classList(this.node()), i2 = -1, n = names2.length;
        while (++i2 < n)
          if (!list.contains(names2[i2]))
            return false;
        return true;
      }
      return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names2, value));
    }
    function textRemove() {
      this.textContent = "";
    }
    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }
    function textFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }
    function selection_text(value) {
      return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
    }
    function htmlRemove() {
      this.innerHTML = "";
    }
    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }
    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }
    function selection_html(value) {
      return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
    }
    function raise() {
      if (this.nextSibling)
        this.parentNode.appendChild(this);
    }
    function selection_raise() {
      return this.each(raise);
    }
    function lower() {
      if (this.previousSibling)
        this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower() {
      return this.each(lower);
    }
    function selection_append(name) {
      var create2 = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create2.apply(this, arguments));
      });
    }
    function constantNull() {
      return null;
    }
    function selection_insert(name, before) {
      var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
      });
    }
    function remove() {
      var parent = this.parentNode;
      if (parent)
        parent.removeChild(this);
    }
    function selection_remove() {
      return this.each(remove);
    }
    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }
    function selection_datum(value) {
      return arguments.length ? this.property("__data__", value) : this.node().__data__;
    }
    var filterEvents = {};
    if (typeof document !== "undefined") {
      var element = document.documentElement;
      if (!("onmouseenter" in element)) {
        filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
      }
    }
    function filterContextListener(listener, index2, group) {
      listener = contextListener(listener, index2, group);
      return function(event) {
        var related = event.relatedTarget;
        if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
          listener.call(this, event);
        }
      };
    }
    function contextListener(listener, index2, group) {
      return function(event1) {
        try {
          listener.call(this, this.__data__, index2, group);
        } finally {
        }
      };
    }
    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i2 = t.indexOf(".");
        if (i2 >= 0)
          name = t.slice(i2 + 1), t = t.slice(0, i2);
        return { type: t, name };
      });
    }
    function onRemove(typename) {
      return function() {
        var on2 = this.__on;
        if (!on2)
          return;
        for (var j = 0, i2 = -1, m2 = on2.length, o; j < m2; ++j) {
          if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.capture);
          } else {
            on2[++i2] = o;
          }
        }
        if (++i2)
          on2.length = i2;
        else
          delete this.__on;
      };
    }
    function onAdd(typename, value, capture) {
      var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
      return function(d, i2, group) {
        var on2 = this.__on, o, listener = wrap(value, i2, group);
        if (on2)
          for (var j = 0, m2 = on2.length; j < m2; ++j) {
            if ((o = on2[j]).type === typename.type && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.capture);
              this.addEventListener(o.type, o.listener = listener, o.capture = capture);
              o.value = value;
              return;
            }
          }
        this.addEventListener(typename.type, listener, capture);
        o = { type: typename.type, name: typename.name, value, listener, capture };
        if (!on2)
          this.__on = [o];
        else
          on2.push(o);
      };
    }
    function selection_on(typename, value, capture) {
      var typenames = parseTypenames(typename + ""), i2, n = typenames.length, t;
      if (arguments.length < 2) {
        var on2 = this.node().__on;
        if (on2)
          for (var j = 0, m2 = on2.length, o; j < m2; ++j) {
            for (i2 = 0, o = on2[j]; i2 < n; ++i2) {
              if ((t = typenames[i2]).type === o.type && t.name === o.name) {
                return o.value;
              }
            }
          }
        return;
      }
      on2 = value ? onAdd : onRemove;
      if (capture == null)
        capture = false;
      for (i2 = 0; i2 < n; ++i2)
        this.each(on2(typenames[i2], value, capture));
      return this;
    }
    function dispatchEvent(node, type, params) {
      var window2 = defaultView(node), event = window2.CustomEvent;
      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window2.document.createEvent("Event");
        if (params)
          event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else
          event.initEvent(type, false, false);
      }
      node.dispatchEvent(event);
    }
    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }
    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }
    function selection_dispatch(type, params) {
      return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
    }
    var root = [null];
    function Selection(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }
    function selection() {
      return new Selection([[document.documentElement]], root);
    }
    Selection.prototype = selection.prototype = {
      constructor: Selection,
      select: selection_select,
      selectAll: selection_selectAll,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch
    };
    function select(selector2) {
      return typeof selector2 === "string" ? new Selection([[document.querySelector(selector2)]], [document.documentElement]) : new Selection([[selector2]], root);
    }
    function d3tip() {
      var direction2 = d3TipDirection, offset = d3TipOffset, html = d3TipHTML, rootElement = document.body, node = initNode(), svg = null, point = null, target = null;
      function tip(vis) {
        svg = getSVGNode(vis);
        if (!svg)
          return;
        point = svg.createSVGPoint();
        rootElement.appendChild(node);
      }
      tip.show = function() {
        var args = Array.prototype.slice.call(arguments);
        if (args[args.length - 1] instanceof SVGElement)
          target = args.pop();
        var content2 = html.apply(this, args), poffset = offset.apply(this, args), dir = direction2.apply(this, args), nodel = getNodeEl(), i2 = directions.length, coords, scrollTop = document.documentElement.scrollTop || rootElement.scrollTop, scrollLeft = document.documentElement.scrollLeft || rootElement.scrollLeft;
        nodel.html(content2).style("opacity", 1).style("pointer-events", "all");
        while (i2--)
          nodel.classed(directions[i2], false);
        coords = directionCallbacks.get(dir).apply(this);
        nodel.classed(dir, true).style("top", coords.top + poffset[0] + scrollTop + "px").style("left", coords.left + poffset[1] + scrollLeft + "px");
        return tip;
      };
      tip.hide = function() {
        var nodel = getNodeEl();
        nodel.style("opacity", 0).style("pointer-events", "none");
        return tip;
      };
      tip.attr = function(n, v) {
        if (arguments.length < 2 && typeof n === "string") {
          return getNodeEl().attr(n);
        }
        var args = Array.prototype.slice.call(arguments);
        selection.prototype.attr.apply(getNodeEl(), args);
        return tip;
      };
      tip.style = function(n, v) {
        if (arguments.length < 2 && typeof n === "string") {
          return getNodeEl().style(n);
        }
        var args = Array.prototype.slice.call(arguments);
        selection.prototype.style.apply(getNodeEl(), args);
        return tip;
      };
      tip.direction = function(v) {
        if (!arguments.length)
          return direction2;
        direction2 = v == null ? v : functor(v);
        return tip;
      };
      tip.offset = function(v) {
        if (!arguments.length)
          return offset;
        offset = v == null ? v : functor(v);
        return tip;
      };
      tip.html = function(v) {
        if (!arguments.length)
          return html;
        html = v == null ? v : functor(v);
        return tip;
      };
      tip.rootElement = function(v) {
        if (!arguments.length)
          return rootElement;
        rootElement = v == null ? v : functor(v);
        return tip;
      };
      tip.destroy = function() {
        if (node) {
          getNodeEl().remove();
          node = null;
        }
        return tip;
      };
      function d3TipDirection() {
        return "n";
      }
      function d3TipOffset() {
        return [0, 0];
      }
      function d3TipHTML() {
        return " ";
      }
      var directionCallbacks = map({
        n: directionNorth,
        s: directionSouth,
        e: directionEast,
        w: directionWest,
        nw: directionNorthWest,
        ne: directionNorthEast,
        sw: directionSouthWest,
        se: directionSouthEast
      }), directions = directionCallbacks.keys();
      function directionNorth() {
        var bbox = getScreenBBox(this);
        return {
          top: bbox.n.y - node.offsetHeight,
          left: bbox.n.x - node.offsetWidth / 2
        };
      }
      function directionSouth() {
        var bbox = getScreenBBox(this);
        return {
          top: bbox.s.y,
          left: bbox.s.x - node.offsetWidth / 2
        };
      }
      function directionEast() {
        var bbox = getScreenBBox(this);
        return {
          top: bbox.e.y - node.offsetHeight / 2,
          left: bbox.e.x
        };
      }
      function directionWest() {
        var bbox = getScreenBBox(this);
        return {
          top: bbox.w.y - node.offsetHeight / 2,
          left: bbox.w.x - node.offsetWidth
        };
      }
      function directionNorthWest() {
        var bbox = getScreenBBox(this);
        return {
          top: bbox.nw.y - node.offsetHeight,
          left: bbox.nw.x - node.offsetWidth
        };
      }
      function directionNorthEast() {
        var bbox = getScreenBBox(this);
        return {
          top: bbox.ne.y - node.offsetHeight,
          left: bbox.ne.x
        };
      }
      function directionSouthWest() {
        var bbox = getScreenBBox(this);
        return {
          top: bbox.sw.y,
          left: bbox.sw.x - node.offsetWidth
        };
      }
      function directionSouthEast() {
        var bbox = getScreenBBox(this);
        return {
          top: bbox.se.y,
          left: bbox.se.x
        };
      }
      function initNode() {
        var div = select(document.createElement("div"));
        div.style("position", "absolute").style("top", 0).style("opacity", 0).style("pointer-events", "none").style("box-sizing", "border-box");
        return div.node();
      }
      function getSVGNode(element2) {
        var svgNode2 = element2.node();
        if (!svgNode2)
          return null;
        if (svgNode2.tagName.toLowerCase() === "svg")
          return svgNode2;
        return svgNode2.ownerSVGElement;
      }
      function getNodeEl() {
        if (node == null) {
          node = initNode();
          rootElement.appendChild(node);
        }
        return select(node);
      }
      function getScreenBBox(targetShape) {
        var targetel = target || targetShape;
        while (targetel.getScreenCTM == null && targetel.parentNode != null) {
          targetel = targetel.parentNode;
        }
        var bbox = {}, matrix2 = targetel.getScreenCTM(), tbbox = targetel.getBBox(), width = tbbox.width, height = tbbox.height, x2 = tbbox.x, y2 = tbbox.y;
        point.x = x2;
        point.y = y2;
        bbox.nw = point.matrixTransform(matrix2);
        point.x += width;
        bbox.ne = point.matrixTransform(matrix2);
        point.y += height;
        bbox.se = point.matrixTransform(matrix2);
        point.x -= width;
        bbox.sw = point.matrixTransform(matrix2);
        point.y -= height / 2;
        bbox.w = point.matrixTransform(matrix2);
        point.x += width;
        bbox.e = point.matrixTransform(matrix2);
        point.x -= width / 2;
        point.y -= height / 2;
        bbox.n = point.matrixTransform(matrix2);
        point.y += height;
        bbox.s = point.matrixTransform(matrix2);
        return bbox;
      }
      function functor(v) {
        return typeof v === "function" ? v : function() {
          return v;
        };
      }
      return tip;
    }
    const methodMap = [
      [
        "requestFullscreen",
        "exitFullscreen",
        "fullscreenElement",
        "fullscreenEnabled",
        "fullscreenchange",
        "fullscreenerror"
      ],
      // New WebKit
      [
        "webkitRequestFullscreen",
        "webkitExitFullscreen",
        "webkitFullscreenElement",
        "webkitFullscreenEnabled",
        "webkitfullscreenchange",
        "webkitfullscreenerror"
      ],
      // Old WebKit
      [
        "webkitRequestFullScreen",
        "webkitCancelFullScreen",
        "webkitCurrentFullScreenElement",
        "webkitCancelFullScreen",
        "webkitfullscreenchange",
        "webkitfullscreenerror"
      ],
      [
        "mozRequestFullScreen",
        "mozCancelFullScreen",
        "mozFullScreenElement",
        "mozFullScreenEnabled",
        "mozfullscreenchange",
        "mozfullscreenerror"
      ],
      [
        "msRequestFullscreen",
        "msExitFullscreen",
        "msFullscreenElement",
        "msFullscreenEnabled",
        "MSFullscreenChange",
        "MSFullscreenError"
      ]
    ];
    const nativeAPI = (() => {
      if (typeof document === "undefined") {
        return false;
      }
      const unprefixedMethods = methodMap[0];
      const returnValue = {};
      for (const methodList of methodMap) {
        const exitFullscreenMethod = methodList == null ? void 0 : methodList[1];
        if (exitFullscreenMethod in document) {
          for (const [index2, method] of methodList.entries()) {
            returnValue[unprefixedMethods[index2]] = method;
          }
          return returnValue;
        }
      }
      return false;
    })();
    const eventNameMap = {
      change: nativeAPI.fullscreenchange,
      error: nativeAPI.fullscreenerror
    };
    let screenfull = {
      // eslint-disable-next-line default-param-last
      request(element2 = document.documentElement, options) {
        return new Promise((resolve2, reject) => {
          const onFullScreenEntered = () => {
            screenfull.off("change", onFullScreenEntered);
            resolve2();
          };
          screenfull.on("change", onFullScreenEntered);
          const returnPromise = element2[nativeAPI.requestFullscreen](options);
          if (returnPromise instanceof Promise) {
            returnPromise.then(onFullScreenEntered).catch(reject);
          }
        });
      },
      exit() {
        return new Promise((resolve2, reject) => {
          if (!screenfull.isFullscreen) {
            resolve2();
            return;
          }
          const onFullScreenExit = () => {
            screenfull.off("change", onFullScreenExit);
            resolve2();
          };
          screenfull.on("change", onFullScreenExit);
          const returnPromise = document[nativeAPI.exitFullscreen]();
          if (returnPromise instanceof Promise) {
            returnPromise.then(onFullScreenExit).catch(reject);
          }
        });
      },
      toggle(element2, options) {
        return screenfull.isFullscreen ? screenfull.exit() : screenfull.request(element2, options);
      },
      onchange(callback) {
        screenfull.on("change", callback);
      },
      onerror(callback) {
        screenfull.on("error", callback);
      },
      on(event, callback) {
        const eventName = eventNameMap[event];
        if (eventName) {
          document.addEventListener(eventName, callback, false);
        }
      },
      off(event, callback) {
        const eventName = eventNameMap[event];
        if (eventName) {
          document.removeEventListener(eventName, callback, false);
        }
      },
      raw: nativeAPI
    };
    Object.defineProperties(screenfull, {
      isFullscreen: {
        get: () => Boolean(document[nativeAPI.fullscreenElement])
      },
      element: {
        enumerable: true,
        get: () => {
          var _a2;
          return (_a2 = document[nativeAPI.fullscreenElement]) != null ? _a2 : void 0;
        }
      },
      isEnabled: {
        enumerable: true,
        // Coerce to boolean in case of old WebKit.
        get: () => Boolean(document[nativeAPI.fullscreenEnabled])
      }
    });
    if (!nativeAPI) {
      screenfull = { isEnabled: false };
    }
    const screenfull$1 = screenfull;
    /*!
     * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
     * Released under MIT License
     */
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p2))
            d2[p2] = b2[p2];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s = arguments[i2];
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2))
              t[p2] = s[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __awaiter(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y2, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f2 = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done)
              return t;
            if (y2 = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e3) {
            op = [6, e3];
            y2 = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    }
    function __spreadArray(to, from, pack2) {
      if (pack2 || arguments.length === 2)
        for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || from);
    }
    var Bounds = (
      /** @class */
      function() {
        function Bounds2(left, top, width, height) {
          this.left = left;
          this.top = top;
          this.width = width;
          this.height = height;
        }
        Bounds2.prototype.add = function(x2, y2, w, h2) {
          return new Bounds2(this.left + x2, this.top + y2, this.width + w, this.height + h2);
        };
        Bounds2.fromClientRect = function(context, clientRect) {
          return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
        };
        Bounds2.fromDOMRectList = function(context, domRectList) {
          var domRect = Array.from(domRectList).find(function(rect) {
            return rect.width !== 0;
          });
          return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
        };
        Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
        return Bounds2;
      }()
    );
    var parseBounds = function(context, node) {
      return Bounds.fromClientRect(context, node.getBoundingClientRect());
    };
    var parseDocumentSize = function(document2) {
      var body = document2.body;
      var documentElement = document2.documentElement;
      if (!body || !documentElement) {
        throw new Error("Unable to get document size");
      }
      var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
      var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
      return new Bounds(0, 0, width, height);
    };
    var toCodePoints$1 = function(str) {
      var codePoints = [];
      var i2 = 0;
      var length = str.length;
      while (i2 < length) {
        var value = str.charCodeAt(i2++);
        if (value >= 55296 && value <= 56319 && i2 < length) {
          var extra = str.charCodeAt(i2++);
          if ((extra & 64512) === 56320) {
            codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            codePoints.push(value);
            i2--;
          }
        } else {
          codePoints.push(value);
        }
      }
      return codePoints;
    };
    var fromCodePoint$1 = function() {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
        return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
        return "";
      }
      var codeUnits = [];
      var index2 = -1;
      var result = "";
      while (++index2 < length) {
        var codePoint = codePoints[index2];
        if (codePoint <= 65535) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 65536;
          codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
        }
        if (index2 + 1 === length || codeUnits.length > 16384) {
          result += String.fromCharCode.apply(String, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
      lookup$2[chars$2.charCodeAt(i$2)] = i$2;
    }
    var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
      lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
    }
    var decode$1 = function(base642) {
      var bufferLength = base642.length * 0.75, len = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
      if (base642[base642.length - 1] === "=") {
        bufferLength--;
        if (base642[base642.length - 2] === "=") {
          bufferLength--;
        }
      }
      var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i2 = 0; i2 < len; i2 += 4) {
        encoded1 = lookup$1$1[base642.charCodeAt(i2)];
        encoded2 = lookup$1$1[base642.charCodeAt(i2 + 1)];
        encoded3 = lookup$1$1[base642.charCodeAt(i2 + 2)];
        encoded4 = lookup$1$1[base642.charCodeAt(i2 + 3)];
        bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return buffer;
    };
    var polyUint16Array$1 = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i2 = 0; i2 < length; i2 += 2) {
        bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
      }
      return bytes;
    };
    var polyUint32Array$1 = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i2 = 0; i2 < length; i2 += 4) {
        bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
      }
      return bytes;
    };
    var UTRIE2_SHIFT_2$1 = 5;
    var UTRIE2_SHIFT_1$1 = 6 + 5;
    var UTRIE2_INDEX_SHIFT$1 = 2;
    var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
    var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
    var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
    var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
    var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
    var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
    var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
    var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
    var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
    var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
    var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
    var slice16$1 = function(view, start2, end) {
      if (view.slice) {
        return view.slice(start2, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start2, end));
    };
    var slice32$1 = function(view, start2, end) {
      if (view.slice) {
        return view.slice(start2, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start2, end));
    };
    var createTrieFromBase64$1 = function(base642, _byteLength) {
      var buffer = decode$1(base642);
      var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data);
    };
    var Trie$1 = (
      /** @class */
      function() {
        function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
          this.initialValue = initialValue;
          this.errorValue = errorValue;
          this.highStart = highStart;
          this.highValueIndex = highValueIndex;
          this.index = index2;
          this.data = data;
        }
        Trie2.prototype.get = function(codePoint) {
          var ix;
          if (codePoint >= 0) {
            if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
              ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
              ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
              return this.data[ix];
            }
            if (codePoint <= 65535) {
              ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
              ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
              return this.data[ix];
            }
            if (codePoint < this.highStart) {
              ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
              ix = this.index[ix];
              ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
              ix = this.index[ix];
              ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
              return this.data[ix];
            }
            if (codePoint <= 1114111) {
              return this.data[this.highValueIndex];
            }
          }
          return this.errorValue;
        };
        return Trie2;
      }()
    );
    var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
      lookup$3[chars$3.charCodeAt(i$3)] = i$3;
    }
    var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
    var LETTER_NUMBER_MODIFIER = 50;
    var BK = 1;
    var CR$1 = 2;
    var LF$1 = 3;
    var CM = 4;
    var NL = 5;
    var WJ = 7;
    var ZW = 8;
    var GL = 9;
    var SP = 10;
    var ZWJ$1 = 11;
    var B2 = 12;
    var BA = 13;
    var BB = 14;
    var HY = 15;
    var CB = 16;
    var CL = 17;
    var CP = 18;
    var EX = 19;
    var IN = 20;
    var NS = 21;
    var OP = 22;
    var QU = 23;
    var IS = 24;
    var NU = 25;
    var PO = 26;
    var PR = 27;
    var SY = 28;
    var AI = 29;
    var AL = 30;
    var CJ = 31;
    var EB = 32;
    var EM = 33;
    var H2 = 34;
    var H3 = 35;
    var HL = 36;
    var ID = 37;
    var JL = 38;
    var JV = 39;
    var JT = 40;
    var RI$1 = 41;
    var SA = 42;
    var XX = 43;
    var ea_OP = [9001, 65288];
    var BREAK_MANDATORY = "!";
    var BREAK_NOT_ALLOWED$1 = "×";
    var BREAK_ALLOWED$1 = "÷";
    var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
    var ALPHABETICS = [AL, HL];
    var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
    var SPACE$1 = [SP, ZW];
    var PREFIX_POSTFIX = [PR, PO];
    var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
    var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
    var HYPHEN = [HY, BA];
    var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
      if (lineBreak2 === void 0) {
        lineBreak2 = "strict";
      }
      var types = [];
      var indices = [];
      var categories = [];
      codePoints.forEach(function(codePoint, index2) {
        var classType = UnicodeTrie$1.get(codePoint);
        if (classType > LETTER_NUMBER_MODIFIER) {
          categories.push(true);
          classType -= LETTER_NUMBER_MODIFIER;
        } else {
          categories.push(false);
        }
        if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
          if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
            indices.push(index2);
            return types.push(CB);
          }
        }
        if (classType === CM || classType === ZWJ$1) {
          if (index2 === 0) {
            indices.push(index2);
            return types.push(AL);
          }
          var prev = types[index2 - 1];
          if (LINE_BREAKS.indexOf(prev) === -1) {
            indices.push(indices[index2 - 1]);
            return types.push(prev);
          }
          indices.push(index2);
          return types.push(AL);
        }
        indices.push(index2);
        if (classType === CJ) {
          return types.push(lineBreak2 === "strict" ? NS : ID);
        }
        if (classType === SA) {
          return types.push(AL);
        }
        if (classType === AI) {
          return types.push(AL);
        }
        if (classType === XX) {
          if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
            return types.push(ID);
          } else {
            return types.push(AL);
          }
        }
        types.push(classType);
      });
      return [indices, types, categories];
    };
    var isAdjacentWithSpaceIgnored = function(a2, b, currentIndex, classTypes) {
      var current = classTypes[currentIndex];
      if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
        var i2 = currentIndex;
        while (i2 <= classTypes.length) {
          i2++;
          var next = classTypes[i2];
          if (next === b) {
            return true;
          }
          if (next !== SP) {
            break;
          }
        }
      }
      if (current === SP) {
        var i2 = currentIndex;
        while (i2 > 0) {
          i2--;
          var prev = classTypes[i2];
          if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
            var n = currentIndex;
            while (n <= classTypes.length) {
              n++;
              var next = classTypes[n];
              if (next === b) {
                return true;
              }
              if (next !== SP) {
                break;
              }
            }
          }
          if (prev !== SP) {
            break;
          }
        }
      }
      return false;
    };
    var previousNonSpaceClassType = function(currentIndex, classTypes) {
      var i2 = currentIndex;
      while (i2 >= 0) {
        var type = classTypes[i2];
        if (type === SP) {
          i2--;
        } else {
          return type;
        }
      }
      return 0;
    };
    var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
      if (indicies[index2] === 0) {
        return BREAK_NOT_ALLOWED$1;
      }
      var currentIndex = index2 - 1;
      if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
        return BREAK_NOT_ALLOWED$1;
      }
      var beforeIndex = currentIndex - 1;
      var afterIndex = currentIndex + 1;
      var current = classTypes[currentIndex];
      var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
      var next = classTypes[afterIndex];
      if (current === CR$1 && next === LF$1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
        return BREAK_MANDATORY;
      }
      if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (SPACE$1.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
        return BREAK_ALLOWED$1;
      }
      if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === WJ || next === WJ) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === GL) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === SP) {
        return BREAK_ALLOWED$1;
      }
      if (current === QU || next === QU) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (next === CB || current === CB) {
        return BREAK_ALLOWED$1;
      }
      if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (before === HL && HYPHEN.indexOf(current) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === SY && next === HL) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (next === IN) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (
        // (PR | PO) × ( OP | HY )? NU
        [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY ) × NU
        [OP, HY].indexOf(current) !== -1 && next === NU || // NU ×	(NU | SY | IS)
        current === NU && [NU, SY, IS].indexOf(next) !== -1
      ) {
        return BREAK_NOT_ALLOWED$1;
      }
      if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
        var prevIndex = currentIndex;
        while (prevIndex >= 0) {
          var type = classTypes[prevIndex];
          if (type === NU) {
            return BREAK_NOT_ALLOWED$1;
          } else if ([SY, IS].indexOf(type) !== -1) {
            prevIndex--;
          } else {
            break;
          }
        }
      }
      if ([PR, PO].indexOf(next) !== -1) {
        var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
        while (prevIndex >= 0) {
          var type = classTypes[prevIndex];
          if (type === NU) {
            return BREAK_NOT_ALLOWED$1;
          } else if ([SY, IS].indexOf(type) !== -1) {
            prevIndex--;
          } else {
            break;
          }
        }
      }
      if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
        return BREAK_NOT_ALLOWED$1;
      }
      if (current === RI$1 && next === RI$1) {
        var i2 = indicies[currentIndex];
        var count = 1;
        while (i2 > 0) {
          i2--;
          if (classTypes[i2] === RI$1) {
            count++;
          } else {
            break;
          }
        }
        if (count % 2 !== 0) {
          return BREAK_NOT_ALLOWED$1;
        }
      }
      if (current === EB && next === EM) {
        return BREAK_NOT_ALLOWED$1;
      }
      return BREAK_ALLOWED$1;
    };
    var cssFormattedClasses = function(codePoints, options) {
      if (!options) {
        options = { lineBreak: "normal", wordBreak: "normal" };
      }
      var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
      if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
        classTypes = classTypes.map(function(type) {
          return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
        });
      }
      var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i2) {
        return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;
      }) : void 0;
      return [indicies, classTypes, forbiddenBreakpoints];
    };
    var Break = (
      /** @class */
      function() {
        function Break2(codePoints, lineBreak2, start2, end) {
          this.codePoints = codePoints;
          this.required = lineBreak2 === BREAK_MANDATORY;
          this.start = start2;
          this.end = end;
        }
        Break2.prototype.slice = function() {
          return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
        };
        return Break2;
      }()
    );
    var LineBreaker = function(str, options) {
      var codePoints = toCodePoints$1(str);
      var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
      var length = codePoints.length;
      var lastEnd = 0;
      var nextIndex = 0;
      return {
        next: function() {
          if (nextIndex >= length) {
            return { done: true, value: null };
          }
          var lineBreak2 = BREAK_NOT_ALLOWED$1;
          while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
          }
          if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
            var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
            lastEnd = nextIndex;
            return { value, done: false };
          }
          return { done: true, value: null };
        }
      };
    };
    var FLAG_UNRESTRICTED = 1 << 0;
    var FLAG_ID = 1 << 1;
    var FLAG_INTEGER = 1 << 2;
    var FLAG_NUMBER = 1 << 3;
    var LINE_FEED = 10;
    var SOLIDUS = 47;
    var REVERSE_SOLIDUS = 92;
    var CHARACTER_TABULATION = 9;
    var SPACE = 32;
    var QUOTATION_MARK = 34;
    var EQUALS_SIGN = 61;
    var NUMBER_SIGN = 35;
    var DOLLAR_SIGN = 36;
    var PERCENTAGE_SIGN = 37;
    var APOSTROPHE = 39;
    var LEFT_PARENTHESIS = 40;
    var RIGHT_PARENTHESIS = 41;
    var LOW_LINE = 95;
    var HYPHEN_MINUS = 45;
    var EXCLAMATION_MARK = 33;
    var LESS_THAN_SIGN = 60;
    var GREATER_THAN_SIGN = 62;
    var COMMERCIAL_AT = 64;
    var LEFT_SQUARE_BRACKET = 91;
    var RIGHT_SQUARE_BRACKET = 93;
    var CIRCUMFLEX_ACCENT = 61;
    var LEFT_CURLY_BRACKET = 123;
    var QUESTION_MARK = 63;
    var RIGHT_CURLY_BRACKET = 125;
    var VERTICAL_LINE = 124;
    var TILDE = 126;
    var CONTROL = 128;
    var REPLACEMENT_CHARACTER = 65533;
    var ASTERISK = 42;
    var PLUS_SIGN = 43;
    var COMMA = 44;
    var COLON = 58;
    var SEMICOLON = 59;
    var FULL_STOP = 46;
    var NULL = 0;
    var BACKSPACE = 8;
    var LINE_TABULATION = 11;
    var SHIFT_OUT = 14;
    var INFORMATION_SEPARATOR_ONE = 31;
    var DELETE = 127;
    var EOF = -1;
    var ZERO = 48;
    var a = 97;
    var e = 101;
    var f = 102;
    var u = 117;
    var z = 122;
    var A = 65;
    var E = 69;
    var F = 70;
    var U = 85;
    var Z = 90;
    var isDigit = function(codePoint) {
      return codePoint >= ZERO && codePoint <= 57;
    };
    var isSurrogateCodePoint = function(codePoint) {
      return codePoint >= 55296 && codePoint <= 57343;
    };
    var isHex = function(codePoint) {
      return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a && codePoint <= f;
    };
    var isLowerCaseLetter = function(codePoint) {
      return codePoint >= a && codePoint <= z;
    };
    var isUpperCaseLetter = function(codePoint) {
      return codePoint >= A && codePoint <= Z;
    };
    var isLetter = function(codePoint) {
      return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
    };
    var isNonASCIICodePoint = function(codePoint) {
      return codePoint >= CONTROL;
    };
    var isWhiteSpace = function(codePoint) {
      return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
    };
    var isNameStartCodePoint = function(codePoint) {
      return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
    };
    var isNameCodePoint = function(codePoint) {
      return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
    };
    var isNonPrintableCodePoint = function(codePoint) {
      return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
    };
    var isValidEscape = function(c1, c2) {
      if (c1 !== REVERSE_SOLIDUS) {
        return false;
      }
      return c2 !== LINE_FEED;
    };
    var isIdentifierStart = function(c1, c2, c3) {
      if (c1 === HYPHEN_MINUS) {
        return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
      } else if (isNameStartCodePoint(c1)) {
        return true;
      } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
        return true;
      }
      return false;
    };
    var isNumberStart = function(c1, c2, c3) {
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
        if (isDigit(c2)) {
          return true;
        }
        return c2 === FULL_STOP && isDigit(c3);
      }
      if (c1 === FULL_STOP) {
        return isDigit(c2);
      }
      return isDigit(c1);
    };
    var stringToNumber = function(codePoints) {
      var c2 = 0;
      var sign = 1;
      if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
        if (codePoints[c2] === HYPHEN_MINUS) {
          sign = -1;
        }
        c2++;
      }
      var integers = [];
      while (isDigit(codePoints[c2])) {
        integers.push(codePoints[c2++]);
      }
      var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
      if (codePoints[c2] === FULL_STOP) {
        c2++;
      }
      var fraction = [];
      while (isDigit(codePoints[c2])) {
        fraction.push(codePoints[c2++]);
      }
      var fracd = fraction.length;
      var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
      if (codePoints[c2] === E || codePoints[c2] === e) {
        c2++;
      }
      var expsign = 1;
      if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
        if (codePoints[c2] === HYPHEN_MINUS) {
          expsign = -1;
        }
        c2++;
      }
      var exponent2 = [];
      while (isDigit(codePoints[c2])) {
        exponent2.push(codePoints[c2++]);
      }
      var exp = exponent2.length ? parseInt(fromCodePoint$1.apply(void 0, exponent2), 10) : 0;
      return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
    };
    var LEFT_PARENTHESIS_TOKEN = {
      type: 2
      /* LEFT_PARENTHESIS_TOKEN */
    };
    var RIGHT_PARENTHESIS_TOKEN = {
      type: 3
      /* RIGHT_PARENTHESIS_TOKEN */
    };
    var COMMA_TOKEN = {
      type: 4
      /* COMMA_TOKEN */
    };
    var SUFFIX_MATCH_TOKEN = {
      type: 13
      /* SUFFIX_MATCH_TOKEN */
    };
    var PREFIX_MATCH_TOKEN = {
      type: 8
      /* PREFIX_MATCH_TOKEN */
    };
    var COLUMN_TOKEN = {
      type: 21
      /* COLUMN_TOKEN */
    };
    var DASH_MATCH_TOKEN = {
      type: 9
      /* DASH_MATCH_TOKEN */
    };
    var INCLUDE_MATCH_TOKEN = {
      type: 10
      /* INCLUDE_MATCH_TOKEN */
    };
    var LEFT_CURLY_BRACKET_TOKEN = {
      type: 11
      /* LEFT_CURLY_BRACKET_TOKEN */
    };
    var RIGHT_CURLY_BRACKET_TOKEN = {
      type: 12
      /* RIGHT_CURLY_BRACKET_TOKEN */
    };
    var SUBSTRING_MATCH_TOKEN = {
      type: 14
      /* SUBSTRING_MATCH_TOKEN */
    };
    var BAD_URL_TOKEN = {
      type: 23
      /* BAD_URL_TOKEN */
    };
    var BAD_STRING_TOKEN = {
      type: 1
      /* BAD_STRING_TOKEN */
    };
    var CDO_TOKEN = {
      type: 25
      /* CDO_TOKEN */
    };
    var CDC_TOKEN = {
      type: 24
      /* CDC_TOKEN */
    };
    var COLON_TOKEN = {
      type: 26
      /* COLON_TOKEN */
    };
    var SEMICOLON_TOKEN = {
      type: 27
      /* SEMICOLON_TOKEN */
    };
    var LEFT_SQUARE_BRACKET_TOKEN = {
      type: 28
      /* LEFT_SQUARE_BRACKET_TOKEN */
    };
    var RIGHT_SQUARE_BRACKET_TOKEN = {
      type: 29
      /* RIGHT_SQUARE_BRACKET_TOKEN */
    };
    var WHITESPACE_TOKEN = {
      type: 31
      /* WHITESPACE_TOKEN */
    };
    var EOF_TOKEN = {
      type: 32
      /* EOF_TOKEN */
    };
    var Tokenizer = (
      /** @class */
      function() {
        function Tokenizer2() {
          this._value = [];
        }
        Tokenizer2.prototype.write = function(chunk) {
          this._value = this._value.concat(toCodePoints$1(chunk));
        };
        Tokenizer2.prototype.read = function() {
          var tokens = [];
          var token = this.consumeToken();
          while (token !== EOF_TOKEN) {
            tokens.push(token);
            token = this.consumeToken();
          }
          return tokens;
        };
        Tokenizer2.prototype.consumeToken = function() {
          var codePoint = this.consumeCodePoint();
          switch (codePoint) {
            case QUOTATION_MARK:
              return this.consumeStringToken(QUOTATION_MARK);
            case NUMBER_SIGN:
              var c1 = this.peekCodePoint(0);
              var c2 = this.peekCodePoint(1);
              var c3 = this.peekCodePoint(2);
              if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                var value = this.consumeName();
                return { type: 5, value, flags };
              }
              break;
            case DOLLAR_SIGN:
              if (this.peekCodePoint(0) === EQUALS_SIGN) {
                this.consumeCodePoint();
                return SUFFIX_MATCH_TOKEN;
              }
              break;
            case APOSTROPHE:
              return this.consumeStringToken(APOSTROPHE);
            case LEFT_PARENTHESIS:
              return LEFT_PARENTHESIS_TOKEN;
            case RIGHT_PARENTHESIS:
              return RIGHT_PARENTHESIS_TOKEN;
            case ASTERISK:
              if (this.peekCodePoint(0) === EQUALS_SIGN) {
                this.consumeCodePoint();
                return SUBSTRING_MATCH_TOKEN;
              }
              break;
            case PLUS_SIGN:
              if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                this.reconsumeCodePoint(codePoint);
                return this.consumeNumericToken();
              }
              break;
            case COMMA:
              return COMMA_TOKEN;
            case HYPHEN_MINUS:
              var e1 = codePoint;
              var e22 = this.peekCodePoint(0);
              var e3 = this.peekCodePoint(1);
              if (isNumberStart(e1, e22, e3)) {
                this.reconsumeCodePoint(codePoint);
                return this.consumeNumericToken();
              }
              if (isIdentifierStart(e1, e22, e3)) {
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
              }
              if (e22 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                this.consumeCodePoint();
                this.consumeCodePoint();
                return CDC_TOKEN;
              }
              break;
            case FULL_STOP:
              if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                this.reconsumeCodePoint(codePoint);
                return this.consumeNumericToken();
              }
              break;
            case SOLIDUS:
              if (this.peekCodePoint(0) === ASTERISK) {
                this.consumeCodePoint();
                while (true) {
                  var c4 = this.consumeCodePoint();
                  if (c4 === ASTERISK) {
                    c4 = this.consumeCodePoint();
                    if (c4 === SOLIDUS) {
                      return this.consumeToken();
                    }
                  }
                  if (c4 === EOF) {
                    return this.consumeToken();
                  }
                }
              }
              break;
            case COLON:
              return COLON_TOKEN;
            case SEMICOLON:
              return SEMICOLON_TOKEN;
            case LESS_THAN_SIGN:
              if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
                this.consumeCodePoint();
                this.consumeCodePoint();
                return CDO_TOKEN;
              }
              break;
            case COMMERCIAL_AT:
              var a1 = this.peekCodePoint(0);
              var a2 = this.peekCodePoint(1);
              var a3 = this.peekCodePoint(2);
              if (isIdentifierStart(a1, a2, a3)) {
                var value = this.consumeName();
                return { type: 7, value };
              }
              break;
            case LEFT_SQUARE_BRACKET:
              return LEFT_SQUARE_BRACKET_TOKEN;
            case REVERSE_SOLIDUS:
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
              }
              break;
            case RIGHT_SQUARE_BRACKET:
              return RIGHT_SQUARE_BRACKET_TOKEN;
            case CIRCUMFLEX_ACCENT:
              if (this.peekCodePoint(0) === EQUALS_SIGN) {
                this.consumeCodePoint();
                return PREFIX_MATCH_TOKEN;
              }
              break;
            case LEFT_CURLY_BRACKET:
              return LEFT_CURLY_BRACKET_TOKEN;
            case RIGHT_CURLY_BRACKET:
              return RIGHT_CURLY_BRACKET_TOKEN;
            case u:
            case U:
              var u1 = this.peekCodePoint(0);
              var u2 = this.peekCodePoint(1);
              if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
                this.consumeCodePoint();
                this.consumeUnicodeRangeToken();
              }
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            case VERTICAL_LINE:
              if (this.peekCodePoint(0) === EQUALS_SIGN) {
                this.consumeCodePoint();
                return DASH_MATCH_TOKEN;
              }
              if (this.peekCodePoint(0) === VERTICAL_LINE) {
                this.consumeCodePoint();
                return COLUMN_TOKEN;
              }
              break;
            case TILDE:
              if (this.peekCodePoint(0) === EQUALS_SIGN) {
                this.consumeCodePoint();
                return INCLUDE_MATCH_TOKEN;
              }
              break;
            case EOF:
              return EOF_TOKEN;
          }
          if (isWhiteSpace(codePoint)) {
            this.consumeWhiteSpace();
            return WHITESPACE_TOKEN;
          }
          if (isDigit(codePoint)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          if (isNameStartCodePoint(codePoint)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          return { type: 6, value: fromCodePoint$1(codePoint) };
        };
        Tokenizer2.prototype.consumeCodePoint = function() {
          var value = this._value.shift();
          return typeof value === "undefined" ? -1 : value;
        };
        Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
          this._value.unshift(codePoint);
        };
        Tokenizer2.prototype.peekCodePoint = function(delta) {
          if (delta >= this._value.length) {
            return -1;
          }
          return this._value[delta];
        };
        Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
          var digits = [];
          var codePoint = this.consumeCodePoint();
          while (isHex(codePoint) && digits.length < 6) {
            digits.push(codePoint);
            codePoint = this.consumeCodePoint();
          }
          var questionMarks = false;
          while (codePoint === QUESTION_MARK && digits.length < 6) {
            digits.push(codePoint);
            codePoint = this.consumeCodePoint();
            questionMarks = true;
          }
          if (questionMarks) {
            var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
              return digit === QUESTION_MARK ? ZERO : digit;
            })), 16);
            var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
              return digit === QUESTION_MARK ? F : digit;
            })), 16);
            return { type: 30, start: start_1, end };
          }
          var start2 = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
          if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
            this.consumeCodePoint();
            codePoint = this.consumeCodePoint();
            var endDigits = [];
            while (isHex(codePoint) && endDigits.length < 6) {
              endDigits.push(codePoint);
              codePoint = this.consumeCodePoint();
            }
            var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
            return { type: 30, start: start2, end };
          } else {
            return { type: 30, start: start2, end: start2 };
          }
        };
        Tokenizer2.prototype.consumeIdentLikeToken = function() {
          var value = this.consumeName();
          if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
            this.consumeCodePoint();
            return this.consumeUrlToken();
          } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 19, value };
          }
          return { type: 20, value };
        };
        Tokenizer2.prototype.consumeUrlToken = function() {
          var value = [];
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF) {
            return { type: 22, value: "" };
          }
          var next = this.peekCodePoint(0);
          if (next === APOSTROPHE || next === QUOTATION_MARK) {
            var stringToken = this.consumeStringToken(this.consumeCodePoint());
            if (stringToken.type === 0) {
              this.consumeWhiteSpace();
              if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                this.consumeCodePoint();
                return { type: 22, value: stringToken.value };
              }
            }
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          }
          while (true) {
            var codePoint = this.consumeCodePoint();
            if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
              return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
            } else if (isWhiteSpace(codePoint)) {
              this.consumeWhiteSpace();
              if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                this.consumeCodePoint();
                return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
              }
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            } else if (codePoint === REVERSE_SOLIDUS) {
              if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                value.push(this.consumeEscapedCodePoint());
              } else {
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
              }
            } else {
              value.push(codePoint);
            }
          }
        };
        Tokenizer2.prototype.consumeWhiteSpace = function() {
          while (isWhiteSpace(this.peekCodePoint(0))) {
            this.consumeCodePoint();
          }
        };
        Tokenizer2.prototype.consumeBadUrlRemnants = function() {
          while (true) {
            var codePoint = this.consumeCodePoint();
            if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
              return;
            }
            if (isValidEscape(codePoint, this.peekCodePoint(0))) {
              this.consumeEscapedCodePoint();
            }
          }
        };
        Tokenizer2.prototype.consumeStringSlice = function(count) {
          var SLICE_STACK_SIZE = 5e4;
          var value = "";
          while (count > 0) {
            var amount = Math.min(SLICE_STACK_SIZE, count);
            value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
            count -= amount;
          }
          this._value.shift();
          return value;
        };
        Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
          var value = "";
          var i2 = 0;
          do {
            var codePoint = this._value[i2];
            if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
              value += this.consumeStringSlice(i2);
              return { type: 0, value };
            }
            if (codePoint === LINE_FEED) {
              this._value.splice(0, i2);
              return BAD_STRING_TOKEN;
            }
            if (codePoint === REVERSE_SOLIDUS) {
              var next = this._value[i2 + 1];
              if (next !== EOF && next !== void 0) {
                if (next === LINE_FEED) {
                  value += this.consumeStringSlice(i2);
                  i2 = -1;
                  this._value.shift();
                } else if (isValidEscape(codePoint, next)) {
                  value += this.consumeStringSlice(i2);
                  value += fromCodePoint$1(this.consumeEscapedCodePoint());
                  i2 = -1;
                }
              }
            }
            i2++;
          } while (true);
        };
        Tokenizer2.prototype.consumeNumber = function() {
          var repr = [];
          var type = FLAG_INTEGER;
          var c1 = this.peekCodePoint(0);
          if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
            repr.push(this.consumeCodePoint());
          }
          while (isDigit(this.peekCodePoint(0))) {
            repr.push(this.consumeCodePoint());
          }
          c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          if (c1 === FULL_STOP && isDigit(c2)) {
            repr.push(this.consumeCodePoint(), this.consumeCodePoint());
            type = FLAG_NUMBER;
            while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
            }
          }
          c1 = this.peekCodePoint(0);
          c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if ((c1 === E || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
            repr.push(this.consumeCodePoint(), this.consumeCodePoint());
            type = FLAG_NUMBER;
            while (isDigit(this.peekCodePoint(0))) {
              repr.push(this.consumeCodePoint());
            }
          }
          return [stringToNumber(repr), type];
        };
        Tokenizer2.prototype.consumeNumericToken = function() {
          var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isIdentifierStart(c1, c2, c3)) {
            var unit = this.consumeName();
            return { type: 15, number, flags, unit };
          }
          if (c1 === PERCENTAGE_SIGN) {
            this.consumeCodePoint();
            return { type: 16, number, flags };
          }
          return { type: 17, number, flags };
        };
        Tokenizer2.prototype.consumeEscapedCodePoint = function() {
          var codePoint = this.consumeCodePoint();
          if (isHex(codePoint)) {
            var hex2 = fromCodePoint$1(codePoint);
            while (isHex(this.peekCodePoint(0)) && hex2.length < 6) {
              hex2 += fromCodePoint$1(this.consumeCodePoint());
            }
            if (isWhiteSpace(this.peekCodePoint(0))) {
              this.consumeCodePoint();
            }
            var hexCodePoint = parseInt(hex2, 16);
            if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
              return REPLACEMENT_CHARACTER;
            }
            return hexCodePoint;
          }
          if (codePoint === EOF) {
            return REPLACEMENT_CHARACTER;
          }
          return codePoint;
        };
        Tokenizer2.prototype.consumeName = function() {
          var result = "";
          while (true) {
            var codePoint = this.consumeCodePoint();
            if (isNameCodePoint(codePoint)) {
              result += fromCodePoint$1(codePoint);
            } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
              result += fromCodePoint$1(this.consumeEscapedCodePoint());
            } else {
              this.reconsumeCodePoint(codePoint);
              return result;
            }
          }
        };
        return Tokenizer2;
      }()
    );
    var Parser = (
      /** @class */
      function() {
        function Parser2(tokens) {
          this._tokens = tokens;
        }
        Parser2.create = function(value) {
          var tokenizer = new Tokenizer();
          tokenizer.write(value);
          return new Parser2(tokenizer.read());
        };
        Parser2.parseValue = function(value) {
          return Parser2.create(value).parseComponentValue();
        };
        Parser2.parseValues = function(value) {
          return Parser2.create(value).parseComponentValues();
        };
        Parser2.prototype.parseComponentValue = function() {
          var token = this.consumeToken();
          while (token.type === 31) {
            token = this.consumeToken();
          }
          if (token.type === 32) {
            throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
          }
          this.reconsumeToken(token);
          var value = this.consumeComponentValue();
          do {
            token = this.consumeToken();
          } while (token.type === 31);
          if (token.type === 32) {
            return value;
          }
          throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
        };
        Parser2.prototype.parseComponentValues = function() {
          var values = [];
          while (true) {
            var value = this.consumeComponentValue();
            if (value.type === 32) {
              return values;
            }
            values.push(value);
            values.push();
          }
        };
        Parser2.prototype.consumeComponentValue = function() {
          var token = this.consumeToken();
          switch (token.type) {
            case 11:
            case 28:
            case 2:
              return this.consumeSimpleBlock(token.type);
            case 19:
              return this.consumeFunction(token);
          }
          return token;
        };
        Parser2.prototype.consumeSimpleBlock = function(type) {
          var block = { type, values: [] };
          var token = this.consumeToken();
          while (true) {
            if (token.type === 32 || isEndingTokenFor(token, type)) {
              return block;
            }
            this.reconsumeToken(token);
            block.values.push(this.consumeComponentValue());
            token = this.consumeToken();
          }
        };
        Parser2.prototype.consumeFunction = function(functionToken) {
          var cssFunction = {
            name: functionToken.value,
            values: [],
            type: 18
            /* FUNCTION */
          };
          while (true) {
            var token = this.consumeToken();
            if (token.type === 32 || token.type === 3) {
              return cssFunction;
            }
            this.reconsumeToken(token);
            cssFunction.values.push(this.consumeComponentValue());
          }
        };
        Parser2.prototype.consumeToken = function() {
          var token = this._tokens.shift();
          return typeof token === "undefined" ? EOF_TOKEN : token;
        };
        Parser2.prototype.reconsumeToken = function(token) {
          this._tokens.unshift(token);
        };
        return Parser2;
      }()
    );
    var isDimensionToken = function(token) {
      return token.type === 15;
    };
    var isNumberToken = function(token) {
      return token.type === 17;
    };
    var isIdentToken = function(token) {
      return token.type === 20;
    };
    var isStringToken = function(token) {
      return token.type === 0;
    };
    var isIdentWithValue = function(token, value) {
      return isIdentToken(token) && token.value === value;
    };
    var nonWhiteSpace = function(token) {
      return token.type !== 31;
    };
    var nonFunctionArgSeparator = function(token) {
      return token.type !== 31 && token.type !== 4;
    };
    var parseFunctionArgs = function(tokens) {
      var args = [];
      var arg = [];
      tokens.forEach(function(token) {
        if (token.type === 4) {
          if (arg.length === 0) {
            throw new Error("Error parsing function args, zero tokens for arg");
          }
          args.push(arg);
          arg = [];
          return;
        }
        if (token.type !== 31) {
          arg.push(token);
        }
      });
      if (arg.length) {
        args.push(arg);
      }
      return args;
    };
    var isEndingTokenFor = function(token, type) {
      if (type === 11 && token.type === 12) {
        return true;
      }
      if (type === 28 && token.type === 29) {
        return true;
      }
      return type === 2 && token.type === 3;
    };
    var isLength = function(token) {
      return token.type === 17 || token.type === 15;
    };
    var isLengthPercentage = function(token) {
      return token.type === 16 || isLength(token);
    };
    var parseLengthPercentageTuple = function(tokens) {
      return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
    };
    var ZERO_LENGTH = {
      type: 17,
      number: 0,
      flags: FLAG_INTEGER
    };
    var FIFTY_PERCENT = {
      type: 16,
      number: 50,
      flags: FLAG_INTEGER
    };
    var HUNDRED_PERCENT = {
      type: 16,
      number: 100,
      flags: FLAG_INTEGER
    };
    var getAbsoluteValueForTuple = function(tuple, width, height) {
      var x2 = tuple[0], y2 = tuple[1];
      return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y2 !== "undefined" ? y2 : x2, height)];
    };
    var getAbsoluteValue = function(token, parent) {
      if (token.type === 16) {
        return token.number / 100 * parent;
      }
      if (isDimensionToken(token)) {
        switch (token.unit) {
          case "rem":
          case "em":
            return 16 * token.number;
          case "px":
          default:
            return token.number;
        }
      }
      return token.number;
    };
    var DEG = "deg";
    var GRAD = "grad";
    var RAD = "rad";
    var TURN = "turn";
    var angle = {
      name: "angle",
      parse: function(_context, value) {
        if (value.type === 15) {
          switch (value.unit) {
            case DEG:
              return Math.PI * value.number / 180;
            case GRAD:
              return Math.PI / 200 * value.number;
            case RAD:
              return value.number;
            case TURN:
              return Math.PI * 2 * value.number;
          }
        }
        throw new Error("Unsupported angle type");
      }
    };
    var isAngle = function(value) {
      if (value.type === 15) {
        if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
          return true;
        }
      }
      return false;
    };
    var parseNamedSide = function(tokens) {
      var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
        return ident.value;
      }).join(" ");
      switch (sideOrCorner) {
        case "to bottom right":
        case "to right bottom":
        case "left top":
        case "top left":
          return [ZERO_LENGTH, ZERO_LENGTH];
        case "to top":
        case "bottom":
          return deg(0);
        case "to bottom left":
        case "to left bottom":
        case "right top":
        case "top right":
          return [ZERO_LENGTH, HUNDRED_PERCENT];
        case "to right":
        case "left":
          return deg(90);
        case "to top left":
        case "to left top":
        case "right bottom":
        case "bottom right":
          return [HUNDRED_PERCENT, HUNDRED_PERCENT];
        case "to bottom":
        case "top":
          return deg(180);
        case "to top right":
        case "to right top":
        case "left bottom":
        case "bottom left":
          return [HUNDRED_PERCENT, ZERO_LENGTH];
        case "to left":
        case "right":
          return deg(270);
      }
      return 0;
    };
    var deg = function(deg2) {
      return Math.PI * deg2 / 180;
    };
    var color$1 = {
      name: "color",
      parse: function(context, value) {
        if (value.type === 18) {
          var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
          if (typeof colorFunction === "undefined") {
            throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
          }
          return colorFunction(context, value.values);
        }
        if (value.type === 5) {
          if (value.value.length === 3) {
            var r = value.value.substring(0, 1);
            var g = value.value.substring(1, 2);
            var b = value.value.substring(2, 3);
            return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
          }
          if (value.value.length === 4) {
            var r = value.value.substring(0, 1);
            var g = value.value.substring(1, 2);
            var b = value.value.substring(2, 3);
            var a2 = value.value.substring(3, 4);
            return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a2 + a2, 16) / 255);
          }
          if (value.value.length === 6) {
            var r = value.value.substring(0, 2);
            var g = value.value.substring(2, 4);
            var b = value.value.substring(4, 6);
            return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
          }
          if (value.value.length === 8) {
            var r = value.value.substring(0, 2);
            var g = value.value.substring(2, 4);
            var b = value.value.substring(4, 6);
            var a2 = value.value.substring(6, 8);
            return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a2, 16) / 255);
          }
        }
        if (value.type === 20) {
          var namedColor = COLORS[value.value.toUpperCase()];
          if (typeof namedColor !== "undefined") {
            return namedColor;
          }
        }
        return COLORS.TRANSPARENT;
      }
    };
    var isTransparent = function(color2) {
      return (255 & color2) === 0;
    };
    var asString = function(color2) {
      var alpha = 255 & color2;
      var blue = 255 & color2 >> 8;
      var green = 255 & color2 >> 16;
      var red = 255 & color2 >> 24;
      return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
    };
    var pack = function(r, g, b, a2) {
      return (r << 24 | g << 16 | b << 8 | Math.round(a2 * 255) << 0) >>> 0;
    };
    var getTokenColorValue = function(token, i2) {
      if (token.type === 17) {
        return token.number;
      }
      if (token.type === 16) {
        var max = i2 === 3 ? 1 : 255;
        return i2 === 3 ? token.number / 100 * max : Math.round(token.number / 100 * max);
      }
      return 0;
    };
    var rgb = function(_context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      if (tokens.length === 3) {
        var _a2 = tokens.map(getTokenColorValue), r = _a2[0], g = _a2[1], b = _a2[2];
        return pack(r, g, b, 1);
      }
      if (tokens.length === 4) {
        var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a2 = _b[3];
        return pack(r, g, b, a2);
      }
      return 0;
    };
    function hue2rgb(t1, t2, hue2) {
      if (hue2 < 0) {
        hue2 += 1;
      }
      if (hue2 >= 1) {
        hue2 -= 1;
      }
      if (hue2 < 1 / 6) {
        return (t2 - t1) * hue2 * 6 + t1;
      } else if (hue2 < 1 / 2) {
        return t2;
      } else if (hue2 < 2 / 3) {
        return (t2 - t1) * 6 * (2 / 3 - hue2) + t1;
      } else {
        return t1;
      }
    }
    var hsl = function(context, args) {
      var tokens = args.filter(nonFunctionArgSeparator);
      var hue2 = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
      var h2 = (hue2.type === 17 ? deg(hue2.number) : angle.parse(context, hue2)) / (Math.PI * 2);
      var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
      var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
      var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
      if (s === 0) {
        return pack(l * 255, l * 255, l * 255, 1);
      }
      var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var t1 = l * 2 - t2;
      var r = hue2rgb(t1, t2, h2 + 1 / 3);
      var g = hue2rgb(t1, t2, h2);
      var b = hue2rgb(t1, t2, h2 - 1 / 3);
      return pack(r * 255, g * 255, b * 255, a2);
    };
    var SUPPORTED_COLOR_FUNCTIONS = {
      hsl,
      hsla: hsl,
      rgb,
      rgba: rgb
    };
    var parseColor = function(context, value) {
      return color$1.parse(context, Parser.create(value).parseComponentValue());
    };
    var COLORS = {
      ALICEBLUE: 4042850303,
      ANTIQUEWHITE: 4209760255,
      AQUA: 16777215,
      AQUAMARINE: 2147472639,
      AZURE: 4043309055,
      BEIGE: 4126530815,
      BISQUE: 4293182719,
      BLACK: 255,
      BLANCHEDALMOND: 4293643775,
      BLUE: 65535,
      BLUEVIOLET: 2318131967,
      BROWN: 2771004159,
      BURLYWOOD: 3736635391,
      CADETBLUE: 1604231423,
      CHARTREUSE: 2147418367,
      CHOCOLATE: 3530104575,
      CORAL: 4286533887,
      CORNFLOWERBLUE: 1687547391,
      CORNSILK: 4294499583,
      CRIMSON: 3692313855,
      CYAN: 16777215,
      DARKBLUE: 35839,
      DARKCYAN: 9145343,
      DARKGOLDENROD: 3095837695,
      DARKGRAY: 2846468607,
      DARKGREEN: 6553855,
      DARKGREY: 2846468607,
      DARKKHAKI: 3182914559,
      DARKMAGENTA: 2332068863,
      DARKOLIVEGREEN: 1433087999,
      DARKORANGE: 4287365375,
      DARKORCHID: 2570243327,
      DARKRED: 2332033279,
      DARKSALMON: 3918953215,
      DARKSEAGREEN: 2411499519,
      DARKSLATEBLUE: 1211993087,
      DARKSLATEGRAY: 793726975,
      DARKSLATEGREY: 793726975,
      DARKTURQUOISE: 13554175,
      DARKVIOLET: 2483082239,
      DEEPPINK: 4279538687,
      DEEPSKYBLUE: 12582911,
      DIMGRAY: 1768516095,
      DIMGREY: 1768516095,
      DODGERBLUE: 512819199,
      FIREBRICK: 2988581631,
      FLORALWHITE: 4294635775,
      FORESTGREEN: 579543807,
      FUCHSIA: 4278255615,
      GAINSBORO: 3705462015,
      GHOSTWHITE: 4177068031,
      GOLD: 4292280575,
      GOLDENROD: 3668254975,
      GRAY: 2155905279,
      GREEN: 8388863,
      GREENYELLOW: 2919182335,
      GREY: 2155905279,
      HONEYDEW: 4043305215,
      HOTPINK: 4285117695,
      INDIANRED: 3445382399,
      INDIGO: 1258324735,
      IVORY: 4294963455,
      KHAKI: 4041641215,
      LAVENDER: 3873897215,
      LAVENDERBLUSH: 4293981695,
      LAWNGREEN: 2096890111,
      LEMONCHIFFON: 4294626815,
      LIGHTBLUE: 2916673279,
      LIGHTCORAL: 4034953471,
      LIGHTCYAN: 3774873599,
      LIGHTGOLDENRODYELLOW: 4210742015,
      LIGHTGRAY: 3553874943,
      LIGHTGREEN: 2431553791,
      LIGHTGREY: 3553874943,
      LIGHTPINK: 4290167295,
      LIGHTSALMON: 4288707327,
      LIGHTSEAGREEN: 548580095,
      LIGHTSKYBLUE: 2278488831,
      LIGHTSLATEGRAY: 2005441023,
      LIGHTSLATEGREY: 2005441023,
      LIGHTSTEELBLUE: 2965692159,
      LIGHTYELLOW: 4294959359,
      LIME: 16711935,
      LIMEGREEN: 852308735,
      LINEN: 4210091775,
      MAGENTA: 4278255615,
      MAROON: 2147483903,
      MEDIUMAQUAMARINE: 1724754687,
      MEDIUMBLUE: 52735,
      MEDIUMORCHID: 3126187007,
      MEDIUMPURPLE: 2473647103,
      MEDIUMSEAGREEN: 1018393087,
      MEDIUMSLATEBLUE: 2070474495,
      MEDIUMSPRINGGREEN: 16423679,
      MEDIUMTURQUOISE: 1221709055,
      MEDIUMVIOLETRED: 3340076543,
      MIDNIGHTBLUE: 421097727,
      MINTCREAM: 4127193855,
      MISTYROSE: 4293190143,
      MOCCASIN: 4293178879,
      NAVAJOWHITE: 4292783615,
      NAVY: 33023,
      OLDLACE: 4260751103,
      OLIVE: 2155872511,
      OLIVEDRAB: 1804477439,
      ORANGE: 4289003775,
      ORANGERED: 4282712319,
      ORCHID: 3664828159,
      PALEGOLDENROD: 4008225535,
      PALEGREEN: 2566625535,
      PALETURQUOISE: 2951671551,
      PALEVIOLETRED: 3681588223,
      PAPAYAWHIP: 4293907967,
      PEACHPUFF: 4292524543,
      PERU: 3448061951,
      PINK: 4290825215,
      PLUM: 3718307327,
      POWDERBLUE: 2967529215,
      PURPLE: 2147516671,
      REBECCAPURPLE: 1714657791,
      RED: 4278190335,
      ROSYBROWN: 3163525119,
      ROYALBLUE: 1097458175,
      SADDLEBROWN: 2336560127,
      SALMON: 4202722047,
      SANDYBROWN: 4104413439,
      SEAGREEN: 780883967,
      SEASHELL: 4294307583,
      SIENNA: 2689740287,
      SILVER: 3233857791,
      SKYBLUE: 2278484991,
      SLATEBLUE: 1784335871,
      SLATEGRAY: 1887473919,
      SLATEGREY: 1887473919,
      SNOW: 4294638335,
      SPRINGGREEN: 16744447,
      STEELBLUE: 1182971135,
      TAN: 3535047935,
      TEAL: 8421631,
      THISTLE: 3636451583,
      TOMATO: 4284696575,
      TRANSPARENT: 0,
      TURQUOISE: 1088475391,
      VIOLET: 4001558271,
      WHEAT: 4125012991,
      WHITE: 4294967295,
      WHITESMOKE: 4126537215,
      YELLOW: 4294902015,
      YELLOWGREEN: 2597139199
    };
    var backgroundClip = {
      name: "background-clip",
      initialValue: "border-box",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.map(function(token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "padding-box":
                return 1;
              case "content-box":
                return 2;
            }
          }
          return 0;
        });
      }
    };
    var backgroundColor = {
      name: "background-color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
    var parseColorStop = function(context, args) {
      var color2 = color$1.parse(context, args[0]);
      var stop = args[1];
      return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
    };
    var processColorStops = function(stops, lineLength) {
      var first = stops[0];
      var last = stops[stops.length - 1];
      if (first.stop === null) {
        first.stop = ZERO_LENGTH;
      }
      if (last.stop === null) {
        last.stop = HUNDRED_PERCENT;
      }
      var processStops = [];
      var previous = 0;
      for (var i2 = 0; i2 < stops.length; i2++) {
        var stop_1 = stops[i2].stop;
        if (stop_1 !== null) {
          var absoluteValue = getAbsoluteValue(stop_1, lineLength);
          if (absoluteValue > previous) {
            processStops.push(absoluteValue);
          } else {
            processStops.push(previous);
          }
          previous = absoluteValue;
        } else {
          processStops.push(null);
        }
      }
      var gapBegin = null;
      for (var i2 = 0; i2 < processStops.length; i2++) {
        var stop_2 = processStops[i2];
        if (stop_2 === null) {
          if (gapBegin === null) {
            gapBegin = i2;
          }
        } else if (gapBegin !== null) {
          var gapLength = i2 - gapBegin;
          var beforeGap = processStops[gapBegin - 1];
          var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
          for (var g = 1; g <= gapLength; g++) {
            processStops[gapBegin + g - 1] = gapValue * g;
          }
          gapBegin = null;
        }
      }
      return stops.map(function(_a2, i3) {
        var color2 = _a2.color;
        return { color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0) };
      });
    };
    var getAngleFromCorner = function(corner, width, height) {
      var centerX = width / 2;
      var centerY = height / 2;
      var x2 = getAbsoluteValue(corner[0], width) - centerX;
      var y2 = centerY - getAbsoluteValue(corner[1], height);
      return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);
    };
    var calculateGradientDirection = function(angle2, width, height) {
      var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
      var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      var halfLineLength = lineLength / 2;
      var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
      var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
      return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
    };
    var distance = function(a2, b) {
      return Math.sqrt(a2 * a2 + b * b);
    };
    var findCorner = function(width, height, x2, y2, closest) {
      var corners = [
        [0, 0],
        [0, height],
        [width, 0],
        [width, height]
      ];
      return corners.reduce(function(stat, corner) {
        var cx = corner[0], cy = corner[1];
        var d = distance(x2 - cx, y2 - cy);
        if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
          return {
            optimumCorner: corner,
            optimumDistance: d
          };
        }
        return stat;
      }, {
        optimumDistance: closest ? Infinity : -Infinity,
        optimumCorner: null
      }).optimumCorner;
    };
    var calculateRadius = function(gradient, x2, y2, width, height) {
      var rx = 0;
      var ry = 0;
      switch (gradient.size) {
        case 0:
          if (gradient.shape === 0) {
            rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
          } else if (gradient.shape === 1) {
            rx = Math.min(Math.abs(x2), Math.abs(x2 - width));
            ry = Math.min(Math.abs(y2), Math.abs(y2 - height));
          }
          break;
        case 2:
          if (gradient.shape === 0) {
            rx = ry = Math.min(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
          } else if (gradient.shape === 1) {
            var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));
            var _a2 = findCorner(width, height, x2, y2, true), cx = _a2[0], cy = _a2[1];
            rx = distance(cx - x2, (cy - y2) / c2);
            ry = c2 * rx;
          }
          break;
        case 1:
          if (gradient.shape === 0) {
            rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
          } else if (gradient.shape === 1) {
            rx = Math.max(Math.abs(x2), Math.abs(x2 - width));
            ry = Math.max(Math.abs(y2), Math.abs(y2 - height));
          }
          break;
        case 3:
          if (gradient.shape === 0) {
            rx = ry = Math.max(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
          } else if (gradient.shape === 1) {
            var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));
            var _b = findCorner(width, height, x2, y2, false), cx = _b[0], cy = _b[1];
            rx = distance(cx - x2, (cy - y2) / c2);
            ry = c2 * rx;
          }
          break;
      }
      if (Array.isArray(gradient.size)) {
        rx = getAbsoluteValue(gradient.size[0], width);
        ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
      }
      return [rx, ry];
    };
    var linearGradient = function(context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function(arg, i2) {
        if (i2 === 0) {
          var firstToken = arg[0];
          if (firstToken.type === 20 && firstToken.value === "to") {
            angle$1 = parseNamedSide(arg);
            return;
          } else if (isAngle(firstToken)) {
            angle$1 = angle.parse(context, firstToken);
            return;
          }
        }
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      });
      return {
        angle: angle$1,
        stops,
        type: 1
        /* LINEAR_GRADIENT */
      };
    };
    var prefixLinearGradient = function(context, tokens) {
      var angle$1 = deg(180);
      var stops = [];
      parseFunctionArgs(tokens).forEach(function(arg, i2) {
        if (i2 === 0) {
          var firstToken = arg[0];
          if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
            angle$1 = parseNamedSide(arg);
            return;
          } else if (isAngle(firstToken)) {
            angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
            return;
          }
        }
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      });
      return {
        angle: angle$1,
        stops,
        type: 1
        /* LINEAR_GRADIENT */
      };
    };
    var webkitGradient = function(context, tokens) {
      var angle2 = deg(180);
      var stops = [];
      var type = 1;
      var shape = 0;
      var size2 = 3;
      var position2 = [];
      parseFunctionArgs(tokens).forEach(function(arg, i2) {
        var firstToken = arg[0];
        if (i2 === 0) {
          if (isIdentToken(firstToken) && firstToken.value === "linear") {
            type = 1;
            return;
          } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
            type = 2;
            return;
          }
        }
        if (firstToken.type === 18) {
          if (firstToken.name === "from") {
            var color2 = color$1.parse(context, firstToken.values[0]);
            stops.push({ stop: ZERO_LENGTH, color: color2 });
          } else if (firstToken.name === "to") {
            var color2 = color$1.parse(context, firstToken.values[0]);
            stops.push({ stop: HUNDRED_PERCENT, color: color2 });
          } else if (firstToken.name === "color-stop") {
            var values = firstToken.values.filter(nonFunctionArgSeparator);
            if (values.length === 2) {
              var color2 = color$1.parse(context, values[1]);
              var stop_1 = values[0];
              if (isNumberToken(stop_1)) {
                stops.push({
                  stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
                  color: color2
                });
              }
            }
          }
        }
      });
      return type === 1 ? {
        angle: (angle2 + deg(180)) % deg(360),
        stops,
        type
      } : { size: size2, shape, stops, position: position2, type };
    };
    var CLOSEST_SIDE = "closest-side";
    var FARTHEST_SIDE = "farthest-side";
    var CLOSEST_CORNER = "closest-corner";
    var FARTHEST_CORNER = "farthest-corner";
    var CIRCLE = "circle";
    var ELLIPSE = "ellipse";
    var COVER = "cover";
    var CONTAIN = "contain";
    var radialGradient = function(context, tokens) {
      var shape = 0;
      var size2 = 3;
      var stops = [];
      var position2 = [];
      parseFunctionArgs(tokens).forEach(function(arg, i2) {
        var isColorStop = true;
        if (i2 === 0) {
          var isAtPosition_1 = false;
          isColorStop = arg.reduce(function(acc, token) {
            if (isAtPosition_1) {
              if (isIdentToken(token)) {
                switch (token.value) {
                  case "center":
                    position2.push(FIFTY_PERCENT);
                    return acc;
                  case "top":
                  case "left":
                    position2.push(ZERO_LENGTH);
                    return acc;
                  case "right":
                  case "bottom":
                    position2.push(HUNDRED_PERCENT);
                    return acc;
                }
              } else if (isLengthPercentage(token) || isLength(token)) {
                position2.push(token);
              }
            } else if (isIdentToken(token)) {
              switch (token.value) {
                case CIRCLE:
                  shape = 0;
                  return false;
                case ELLIPSE:
                  shape = 1;
                  return false;
                case "at":
                  isAtPosition_1 = true;
                  return false;
                case CLOSEST_SIDE:
                  size2 = 0;
                  return false;
                case COVER:
                case FARTHEST_SIDE:
                  size2 = 1;
                  return false;
                case CONTAIN:
                case CLOSEST_CORNER:
                  size2 = 2;
                  return false;
                case FARTHEST_CORNER:
                  size2 = 3;
                  return false;
              }
            } else if (isLength(token) || isLengthPercentage(token)) {
              if (!Array.isArray(size2)) {
                size2 = [];
              }
              size2.push(token);
              return false;
            }
            return acc;
          }, isColorStop);
        }
        if (isColorStop) {
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        }
      });
      return {
        size: size2,
        shape,
        stops,
        position: position2,
        type: 2
        /* RADIAL_GRADIENT */
      };
    };
    var prefixRadialGradient = function(context, tokens) {
      var shape = 0;
      var size2 = 3;
      var stops = [];
      var position2 = [];
      parseFunctionArgs(tokens).forEach(function(arg, i2) {
        var isColorStop = true;
        if (i2 === 0) {
          isColorStop = arg.reduce(function(acc, token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "center":
                  position2.push(FIFTY_PERCENT);
                  return false;
                case "top":
                case "left":
                  position2.push(ZERO_LENGTH);
                  return false;
                case "right":
                case "bottom":
                  position2.push(HUNDRED_PERCENT);
                  return false;
              }
            } else if (isLengthPercentage(token) || isLength(token)) {
              position2.push(token);
              return false;
            }
            return acc;
          }, isColorStop);
        } else if (i2 === 1) {
          isColorStop = arg.reduce(function(acc, token) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case CIRCLE:
                  shape = 0;
                  return false;
                case ELLIPSE:
                  shape = 1;
                  return false;
                case CONTAIN:
                case CLOSEST_SIDE:
                  size2 = 0;
                  return false;
                case FARTHEST_SIDE:
                  size2 = 1;
                  return false;
                case CLOSEST_CORNER:
                  size2 = 2;
                  return false;
                case COVER:
                case FARTHEST_CORNER:
                  size2 = 3;
                  return false;
              }
            } else if (isLength(token) || isLengthPercentage(token)) {
              if (!Array.isArray(size2)) {
                size2 = [];
              }
              size2.push(token);
              return false;
            }
            return acc;
          }, isColorStop);
        }
        if (isColorStop) {
          var colorStop = parseColorStop(context, arg);
          stops.push(colorStop);
        }
      });
      return {
        size: size2,
        shape,
        stops,
        position: position2,
        type: 2
        /* RADIAL_GRADIENT */
      };
    };
    var isLinearGradient = function(background) {
      return background.type === 1;
    };
    var isRadialGradient = function(background) {
      return background.type === 2;
    };
    var image = {
      name: "image",
      parse: function(context, value) {
        if (value.type === 22) {
          var image_1 = {
            url: value.value,
            type: 0
            /* URL */
          };
          context.cache.addImage(value.value);
          return image_1;
        }
        if (value.type === 18) {
          var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
          if (typeof imageFunction === "undefined") {
            throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
          }
          return imageFunction(context, value.values);
        }
        throw new Error("Unsupported image type " + value.type);
      }
    };
    function isSupportedImage(value) {
      return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
    }
    var SUPPORTED_IMAGE_FUNCTIONS = {
      "linear-gradient": linearGradient,
      "-moz-linear-gradient": prefixLinearGradient,
      "-ms-linear-gradient": prefixLinearGradient,
      "-o-linear-gradient": prefixLinearGradient,
      "-webkit-linear-gradient": prefixLinearGradient,
      "radial-gradient": radialGradient,
      "-moz-radial-gradient": prefixRadialGradient,
      "-ms-radial-gradient": prefixRadialGradient,
      "-o-radial-gradient": prefixRadialGradient,
      "-webkit-radial-gradient": prefixRadialGradient,
      "-webkit-gradient": webkitGradient
    };
    var backgroundImage = {
      name: "background-image",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(context, tokens) {
        if (tokens.length === 0) {
          return [];
        }
        var first = tokens[0];
        if (first.type === 20 && first.value === "none") {
          return [];
        }
        return tokens.filter(function(value) {
          return nonFunctionArgSeparator(value) && isSupportedImage(value);
        }).map(function(value) {
          return image.parse(context, value);
        });
      }
    };
    var backgroundOrigin = {
      name: "background-origin",
      initialValue: "border-box",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.map(function(token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "padding-box":
                return 1;
              case "content-box":
                return 2;
            }
          }
          return 0;
        });
      }
    };
    var backgroundPosition = {
      name: "background-position",
      initialValue: "0% 0%",
      type: 1,
      prefix: false,
      parse: function(_context, tokens) {
        return parseFunctionArgs(tokens).map(function(values) {
          return values.filter(isLengthPercentage);
        }).map(parseLengthPercentageTuple);
      }
    };
    var backgroundRepeat = {
      name: "background-repeat",
      initialValue: "repeat",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return parseFunctionArgs(tokens).map(function(values) {
          return values.filter(isIdentToken).map(function(token) {
            return token.value;
          }).join(" ");
        }).map(parseBackgroundRepeat);
      }
    };
    var parseBackgroundRepeat = function(value) {
      switch (value) {
        case "no-repeat":
          return 1;
        case "repeat-x":
        case "repeat no-repeat":
          return 2;
        case "repeat-y":
        case "no-repeat repeat":
          return 3;
        case "repeat":
        default:
          return 0;
      }
    };
    var BACKGROUND_SIZE;
    (function(BACKGROUND_SIZE2) {
      BACKGROUND_SIZE2["AUTO"] = "auto";
      BACKGROUND_SIZE2["CONTAIN"] = "contain";
      BACKGROUND_SIZE2["COVER"] = "cover";
    })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
    var backgroundSize = {
      name: "background-size",
      initialValue: "0",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return parseFunctionArgs(tokens).map(function(values) {
          return values.filter(isBackgroundSizeInfoToken);
        });
      }
    };
    var isBackgroundSizeInfoToken = function(value) {
      return isIdentToken(value) || isLengthPercentage(value);
    };
    var borderColorForSide = function(side) {
      return {
        name: "border-" + side + "-color",
        initialValue: "transparent",
        prefix: false,
        type: 3,
        format: "color"
      };
    };
    var borderTopColor = borderColorForSide("top");
    var borderRightColor = borderColorForSide("right");
    var borderBottomColor = borderColorForSide("bottom");
    var borderLeftColor = borderColorForSide("left");
    var borderRadiusForSide = function(side) {
      return {
        name: "border-radius-" + side,
        initialValue: "0 0",
        prefix: false,
        type: 1,
        parse: function(_context, tokens) {
          return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
        }
      };
    };
    var borderTopLeftRadius = borderRadiusForSide("top-left");
    var borderTopRightRadius = borderRadiusForSide("top-right");
    var borderBottomRightRadius = borderRadiusForSide("bottom-right");
    var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
    var borderStyleForSide = function(side) {
      return {
        name: "border-" + side + "-style",
        initialValue: "solid",
        prefix: false,
        type: 2,
        parse: function(_context, style) {
          switch (style) {
            case "none":
              return 0;
            case "dashed":
              return 2;
            case "dotted":
              return 3;
            case "double":
              return 4;
          }
          return 1;
        }
      };
    };
    var borderTopStyle = borderStyleForSide("top");
    var borderRightStyle = borderStyleForSide("right");
    var borderBottomStyle = borderStyleForSide("bottom");
    var borderLeftStyle = borderStyleForSide("left");
    var borderWidthForSide = function(side) {
      return {
        name: "border-" + side + "-width",
        initialValue: "0",
        type: 0,
        prefix: false,
        parse: function(_context, token) {
          if (isDimensionToken(token)) {
            return token.number;
          }
          return 0;
        }
      };
    };
    var borderTopWidth = borderWidthForSide("top");
    var borderRightWidth = borderWidthForSide("right");
    var borderBottomWidth = borderWidthForSide("bottom");
    var borderLeftWidth = borderWidthForSide("left");
    var color = {
      name: "color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
    var direction = {
      name: "direction",
      initialValue: "ltr",
      prefix: false,
      type: 2,
      parse: function(_context, direction2) {
        switch (direction2) {
          case "rtl":
            return 1;
          case "ltr":
          default:
            return 0;
        }
      }
    };
    var display = {
      name: "display",
      initialValue: "inline-block",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).reduce(
          function(bit, token) {
            return bit | parseDisplayValue(token.value);
          },
          0
          /* NONE */
        );
      }
    };
    var parseDisplayValue = function(display2) {
      switch (display2) {
        case "block":
        case "-webkit-box":
          return 2;
        case "inline":
          return 4;
        case "run-in":
          return 8;
        case "flow":
          return 16;
        case "flow-root":
          return 32;
        case "table":
          return 64;
        case "flex":
        case "-webkit-flex":
          return 128;
        case "grid":
        case "-ms-grid":
          return 256;
        case "ruby":
          return 512;
        case "subgrid":
          return 1024;
        case "list-item":
          return 2048;
        case "table-row-group":
          return 4096;
        case "table-header-group":
          return 8192;
        case "table-footer-group":
          return 16384;
        case "table-row":
          return 32768;
        case "table-cell":
          return 65536;
        case "table-column-group":
          return 131072;
        case "table-column":
          return 262144;
        case "table-caption":
          return 524288;
        case "ruby-base":
          return 1048576;
        case "ruby-text":
          return 2097152;
        case "ruby-base-container":
          return 4194304;
        case "ruby-text-container":
          return 8388608;
        case "contents":
          return 16777216;
        case "inline-block":
          return 33554432;
        case "inline-list-item":
          return 67108864;
        case "inline-table":
          return 134217728;
        case "inline-flex":
          return 268435456;
        case "inline-grid":
          return 536870912;
      }
      return 0;
    };
    var float = {
      name: "float",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, float2) {
        switch (float2) {
          case "left":
            return 1;
          case "right":
            return 2;
          case "inline-start":
            return 3;
          case "inline-end":
            return 4;
        }
        return 0;
      }
    };
    var letterSpacing = {
      name: "letter-spacing",
      initialValue: "0",
      prefix: false,
      type: 0,
      parse: function(_context, token) {
        if (token.type === 20 && token.value === "normal") {
          return 0;
        }
        if (token.type === 17) {
          return token.number;
        }
        if (token.type === 15) {
          return token.number;
        }
        return 0;
      }
    };
    var LINE_BREAK;
    (function(LINE_BREAK2) {
      LINE_BREAK2["NORMAL"] = "normal";
      LINE_BREAK2["STRICT"] = "strict";
    })(LINE_BREAK || (LINE_BREAK = {}));
    var lineBreak = {
      name: "line-break",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, lineBreak2) {
        switch (lineBreak2) {
          case "strict":
            return LINE_BREAK.STRICT;
          case "normal":
          default:
            return LINE_BREAK.NORMAL;
        }
      }
    };
    var lineHeight = {
      name: "line-height",
      initialValue: "normal",
      prefix: false,
      type: 4
      /* TOKEN_VALUE */
    };
    var computeLineHeight = function(token, fontSize2) {
      if (isIdentToken(token) && token.value === "normal") {
        return 1.2 * fontSize2;
      } else if (token.type === 17) {
        return fontSize2 * token.number;
      } else if (isLengthPercentage(token)) {
        return getAbsoluteValue(token, fontSize2);
      }
      return fontSize2;
    };
    var listStyleImage = {
      name: "list-style-image",
      initialValue: "none",
      type: 0,
      prefix: false,
      parse: function(context, token) {
        if (token.type === 20 && token.value === "none") {
          return null;
        }
        return image.parse(context, token);
      }
    };
    var listStylePosition = {
      name: "list-style-position",
      initialValue: "outside",
      prefix: false,
      type: 2,
      parse: function(_context, position2) {
        switch (position2) {
          case "inside":
            return 0;
          case "outside":
          default:
            return 1;
        }
      }
    };
    var listStyleType = {
      name: "list-style-type",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, type) {
        switch (type) {
          case "disc":
            return 0;
          case "circle":
            return 1;
          case "square":
            return 2;
          case "decimal":
            return 3;
          case "cjk-decimal":
            return 4;
          case "decimal-leading-zero":
            return 5;
          case "lower-roman":
            return 6;
          case "upper-roman":
            return 7;
          case "lower-greek":
            return 8;
          case "lower-alpha":
            return 9;
          case "upper-alpha":
            return 10;
          case "arabic-indic":
            return 11;
          case "armenian":
            return 12;
          case "bengali":
            return 13;
          case "cambodian":
            return 14;
          case "cjk-earthly-branch":
            return 15;
          case "cjk-heavenly-stem":
            return 16;
          case "cjk-ideographic":
            return 17;
          case "devanagari":
            return 18;
          case "ethiopic-numeric":
            return 19;
          case "georgian":
            return 20;
          case "gujarati":
            return 21;
          case "gurmukhi":
            return 22;
          case "hebrew":
            return 22;
          case "hiragana":
            return 23;
          case "hiragana-iroha":
            return 24;
          case "japanese-formal":
            return 25;
          case "japanese-informal":
            return 26;
          case "kannada":
            return 27;
          case "katakana":
            return 28;
          case "katakana-iroha":
            return 29;
          case "khmer":
            return 30;
          case "korean-hangul-formal":
            return 31;
          case "korean-hanja-formal":
            return 32;
          case "korean-hanja-informal":
            return 33;
          case "lao":
            return 34;
          case "lower-armenian":
            return 35;
          case "malayalam":
            return 36;
          case "mongolian":
            return 37;
          case "myanmar":
            return 38;
          case "oriya":
            return 39;
          case "persian":
            return 40;
          case "simp-chinese-formal":
            return 41;
          case "simp-chinese-informal":
            return 42;
          case "tamil":
            return 43;
          case "telugu":
            return 44;
          case "thai":
            return 45;
          case "tibetan":
            return 46;
          case "trad-chinese-formal":
            return 47;
          case "trad-chinese-informal":
            return 48;
          case "upper-armenian":
            return 49;
          case "disclosure-open":
            return 50;
          case "disclosure-closed":
            return 51;
          case "none":
          default:
            return -1;
        }
      }
    };
    var marginForSide = function(side) {
      return {
        name: "margin-" + side,
        initialValue: "0",
        prefix: false,
        type: 4
        /* TOKEN_VALUE */
      };
    };
    var marginTop = marginForSide("top");
    var marginRight = marginForSide("right");
    var marginBottom = marginForSide("bottom");
    var marginLeft = marginForSide("left");
    var overflow = {
      name: "overflow",
      initialValue: "visible",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).map(function(overflow2) {
          switch (overflow2.value) {
            case "hidden":
              return 1;
            case "scroll":
              return 2;
            case "clip":
              return 3;
            case "auto":
              return 4;
            case "visible":
            default:
              return 0;
          }
        });
      }
    };
    var overflowWrap = {
      name: "overflow-wrap",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, overflow2) {
        switch (overflow2) {
          case "break-word":
            return "break-word";
          case "normal":
          default:
            return "normal";
        }
      }
    };
    var paddingForSide = function(side) {
      return {
        name: "padding-" + side,
        initialValue: "0",
        prefix: false,
        type: 3,
        format: "length-percentage"
      };
    };
    var paddingTop = paddingForSide("top");
    var paddingRight = paddingForSide("right");
    var paddingBottom = paddingForSide("bottom");
    var paddingLeft = paddingForSide("left");
    var textAlign = {
      name: "text-align",
      initialValue: "left",
      prefix: false,
      type: 2,
      parse: function(_context, textAlign2) {
        switch (textAlign2) {
          case "right":
            return 2;
          case "center":
          case "justify":
            return 1;
          case "left":
          default:
            return 0;
        }
      }
    };
    var position = {
      name: "position",
      initialValue: "static",
      prefix: false,
      type: 2,
      parse: function(_context, position2) {
        switch (position2) {
          case "relative":
            return 1;
          case "absolute":
            return 2;
          case "fixed":
            return 3;
          case "sticky":
            return 4;
        }
        return 0;
      }
    };
    var textShadow = {
      name: "text-shadow",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(context, tokens) {
        if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
          return [];
        }
        return parseFunctionArgs(tokens).map(function(values) {
          var shadow = {
            color: COLORS.TRANSPARENT,
            offsetX: ZERO_LENGTH,
            offsetY: ZERO_LENGTH,
            blur: ZERO_LENGTH
          };
          var c2 = 0;
          for (var i2 = 0; i2 < values.length; i2++) {
            var token = values[i2];
            if (isLength(token)) {
              if (c2 === 0) {
                shadow.offsetX = token;
              } else if (c2 === 1) {
                shadow.offsetY = token;
              } else {
                shadow.blur = token;
              }
              c2++;
            } else {
              shadow.color = color$1.parse(context, token);
            }
          }
          return shadow;
        });
      }
    };
    var textTransform = {
      name: "text-transform",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, textTransform2) {
        switch (textTransform2) {
          case "uppercase":
            return 2;
          case "lowercase":
            return 1;
          case "capitalize":
            return 3;
        }
        return 0;
      }
    };
    var transform$1 = {
      name: "transform",
      initialValue: "none",
      prefix: true,
      type: 0,
      parse: function(_context, token) {
        if (token.type === 20 && token.value === "none") {
          return null;
        }
        if (token.type === 18) {
          var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
          if (typeof transformFunction === "undefined") {
            throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
          }
          return transformFunction(token.values);
        }
        return null;
      }
    };
    var matrix = function(args) {
      var values = args.filter(function(arg) {
        return arg.type === 17;
      }).map(function(arg) {
        return arg.number;
      });
      return values.length === 6 ? values : null;
    };
    var matrix3d = function(args) {
      var values = args.filter(function(arg) {
        return arg.type === 17;
      }).map(function(arg) {
        return arg.number;
      });
      var a1 = values[0], b1 = values[1];
      values[2];
      values[3];
      var a2 = values[4], b2 = values[5];
      values[6];
      values[7];
      values[8];
      values[9];
      values[10];
      values[11];
      var a4 = values[12], b4 = values[13];
      values[14];
      values[15];
      return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
    };
    var SUPPORTED_TRANSFORM_FUNCTIONS = {
      matrix,
      matrix3d
    };
    var DEFAULT_VALUE = {
      type: 16,
      number: 50,
      flags: FLAG_INTEGER
    };
    var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
    var transformOrigin = {
      name: "transform-origin",
      initialValue: "50% 50%",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        var origins = tokens.filter(isLengthPercentage);
        if (origins.length !== 2) {
          return DEFAULT;
        }
        return [origins[0], origins[1]];
      }
    };
    var visibility = {
      name: "visible",
      initialValue: "none",
      prefix: false,
      type: 2,
      parse: function(_context, visibility2) {
        switch (visibility2) {
          case "hidden":
            return 1;
          case "collapse":
            return 2;
          case "visible":
          default:
            return 0;
        }
      }
    };
    var WORD_BREAK;
    (function(WORD_BREAK2) {
      WORD_BREAK2["NORMAL"] = "normal";
      WORD_BREAK2["BREAK_ALL"] = "break-all";
      WORD_BREAK2["KEEP_ALL"] = "keep-all";
    })(WORD_BREAK || (WORD_BREAK = {}));
    var wordBreak = {
      name: "word-break",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, wordBreak2) {
        switch (wordBreak2) {
          case "break-all":
            return WORD_BREAK.BREAK_ALL;
          case "keep-all":
            return WORD_BREAK.KEEP_ALL;
          case "normal":
          default:
            return WORD_BREAK.NORMAL;
        }
      }
    };
    var zIndex = {
      name: "z-index",
      initialValue: "auto",
      prefix: false,
      type: 0,
      parse: function(_context, token) {
        if (token.type === 20) {
          return { auto: true, order: 0 };
        }
        if (isNumberToken(token)) {
          return { auto: false, order: token.number };
        }
        throw new Error("Invalid z-index number parsed");
      }
    };
    var time = {
      name: "time",
      parse: function(_context, value) {
        if (value.type === 15) {
          switch (value.unit.toLowerCase()) {
            case "s":
              return 1e3 * value.number;
            case "ms":
              return value.number;
          }
        }
        throw new Error("Unsupported time type");
      }
    };
    var opacity = {
      name: "opacity",
      initialValue: "1",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isNumberToken(token)) {
          return token.number;
        }
        return 1;
      }
    };
    var textDecorationColor = {
      name: "text-decoration-color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
    var textDecorationLine = {
      name: "text-decoration-line",
      initialValue: "none",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).map(function(token) {
          switch (token.value) {
            case "underline":
              return 1;
            case "overline":
              return 2;
            case "line-through":
              return 3;
            case "none":
              return 4;
          }
          return 0;
        }).filter(function(line) {
          return line !== 0;
        });
      }
    };
    var fontFamily = {
      name: "font-family",
      initialValue: "",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        var accumulator = [];
        var results = [];
        tokens.forEach(function(token) {
          switch (token.type) {
            case 20:
            case 0:
              accumulator.push(token.value);
              break;
            case 17:
              accumulator.push(token.number.toString());
              break;
            case 4:
              results.push(accumulator.join(" "));
              accumulator.length = 0;
              break;
          }
        });
        if (accumulator.length) {
          results.push(accumulator.join(" "));
        }
        return results.map(function(result) {
          return result.indexOf(" ") === -1 ? result : "'" + result + "'";
        });
      }
    };
    var fontSize = {
      name: "font-size",
      initialValue: "0",
      prefix: false,
      type: 3,
      format: "length"
    };
    var fontWeight = {
      name: "font-weight",
      initialValue: "normal",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isNumberToken(token)) {
          return token.number;
        }
        if (isIdentToken(token)) {
          switch (token.value) {
            case "bold":
              return 700;
            case "normal":
            default:
              return 400;
          }
        }
        return 400;
      }
    };
    var fontVariant = {
      name: "font-variant",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(_context, tokens) {
        return tokens.filter(isIdentToken).map(function(token) {
          return token.value;
        });
      }
    };
    var fontStyle = {
      name: "font-style",
      initialValue: "normal",
      prefix: false,
      type: 2,
      parse: function(_context, overflow2) {
        switch (overflow2) {
          case "oblique":
            return "oblique";
          case "italic":
            return "italic";
          case "normal":
          default:
            return "normal";
        }
      }
    };
    var contains = function(bit, value) {
      return (bit & value) !== 0;
    };
    var content = {
      name: "content",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return [];
        }
        var first = tokens[0];
        if (first.type === 20 && first.value === "none") {
          return [];
        }
        return tokens;
      }
    };
    var counterIncrement = {
      name: "counter-increment",
      initialValue: "none",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return null;
        }
        var first = tokens[0];
        if (first.type === 20 && first.value === "none") {
          return null;
        }
        var increments = [];
        var filtered = tokens.filter(nonWhiteSpace);
        for (var i2 = 0; i2 < filtered.length; i2++) {
          var counter = filtered[i2];
          var next = filtered[i2 + 1];
          if (counter.type === 20) {
            var increment = next && isNumberToken(next) ? next.number : 1;
            increments.push({ counter: counter.value, increment });
          }
        }
        return increments;
      }
    };
    var counterReset = {
      name: "counter-reset",
      initialValue: "none",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return [];
        }
        var resets = [];
        var filtered = tokens.filter(nonWhiteSpace);
        for (var i2 = 0; i2 < filtered.length; i2++) {
          var counter = filtered[i2];
          var next = filtered[i2 + 1];
          if (isIdentToken(counter) && counter.value !== "none") {
            var reset = next && isNumberToken(next) ? next.number : 0;
            resets.push({ counter: counter.value, reset });
          }
        }
        return resets;
      }
    };
    var duration = {
      name: "duration",
      initialValue: "0s",
      prefix: false,
      type: 1,
      parse: function(context, tokens) {
        return tokens.filter(isDimensionToken).map(function(token) {
          return time.parse(context, token);
        });
      }
    };
    var quotes = {
      name: "quotes",
      initialValue: "none",
      prefix: true,
      type: 1,
      parse: function(_context, tokens) {
        if (tokens.length === 0) {
          return null;
        }
        var first = tokens[0];
        if (first.type === 20 && first.value === "none") {
          return null;
        }
        var quotes2 = [];
        var filtered = tokens.filter(isStringToken);
        if (filtered.length % 2 !== 0) {
          return null;
        }
        for (var i2 = 0; i2 < filtered.length; i2 += 2) {
          var open_1 = filtered[i2].value;
          var close_1 = filtered[i2 + 1].value;
          quotes2.push({ open: open_1, close: close_1 });
        }
        return quotes2;
      }
    };
    var getQuote = function(quotes2, depth, open) {
      if (!quotes2) {
        return "";
      }
      var quote = quotes2[Math.min(depth, quotes2.length - 1)];
      if (!quote) {
        return "";
      }
      return open ? quote.open : quote.close;
    };
    var boxShadow = {
      name: "box-shadow",
      initialValue: "none",
      type: 1,
      prefix: false,
      parse: function(context, tokens) {
        if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
          return [];
        }
        return parseFunctionArgs(tokens).map(function(values) {
          var shadow = {
            color: 255,
            offsetX: ZERO_LENGTH,
            offsetY: ZERO_LENGTH,
            blur: ZERO_LENGTH,
            spread: ZERO_LENGTH,
            inset: false
          };
          var c2 = 0;
          for (var i2 = 0; i2 < values.length; i2++) {
            var token = values[i2];
            if (isIdentWithValue(token, "inset")) {
              shadow.inset = true;
            } else if (isLength(token)) {
              if (c2 === 0) {
                shadow.offsetX = token;
              } else if (c2 === 1) {
                shadow.offsetY = token;
              } else if (c2 === 2) {
                shadow.blur = token;
              } else {
                shadow.spread = token;
              }
              c2++;
            } else {
              shadow.color = color$1.parse(context, token);
            }
          }
          return shadow;
        });
      }
    };
    var paintOrder = {
      name: "paint-order",
      initialValue: "normal",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        var DEFAULT_VALUE2 = [
          0,
          1,
          2
          /* MARKERS */
        ];
        var layers = [];
        tokens.filter(isIdentToken).forEach(function(token) {
          switch (token.value) {
            case "stroke":
              layers.push(
                1
                /* STROKE */
              );
              break;
            case "fill":
              layers.push(
                0
                /* FILL */
              );
              break;
            case "markers":
              layers.push(
                2
                /* MARKERS */
              );
              break;
          }
        });
        DEFAULT_VALUE2.forEach(function(value) {
          if (layers.indexOf(value) === -1) {
            layers.push(value);
          }
        });
        return layers;
      }
    };
    var webkitTextStrokeColor = {
      name: "-webkit-text-stroke-color",
      initialValue: "currentcolor",
      prefix: false,
      type: 3,
      format: "color"
    };
    var webkitTextStrokeWidth = {
      name: "-webkit-text-stroke-width",
      initialValue: "0",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isDimensionToken(token)) {
          return token.number;
        }
        return 0;
      }
    };
    var CSSParsedDeclaration = (
      /** @class */
      function() {
        function CSSParsedDeclaration2(context, declaration) {
          var _a2, _b;
          this.animationDuration = parse(context, duration, declaration.animationDuration);
          this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
          this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
          this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
          this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
          this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
          this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
          this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
          this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
          this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
          this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
          this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
          this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
          this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
          this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
          this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
          this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
          this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
          this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
          this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
          this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
          this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
          this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
          this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
          this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
          this.color = parse(context, color, declaration.color);
          this.direction = parse(context, direction, declaration.direction);
          this.display = parse(context, display, declaration.display);
          this.float = parse(context, float, declaration.cssFloat);
          this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
          this.fontSize = parse(context, fontSize, declaration.fontSize);
          this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
          this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
          this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
          this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
          this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
          this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
          this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
          this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
          this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
          this.marginTop = parse(context, marginTop, declaration.marginTop);
          this.marginRight = parse(context, marginRight, declaration.marginRight);
          this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
          this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
          this.opacity = parse(context, opacity, declaration.opacity);
          var overflowTuple = parse(context, overflow, declaration.overflow);
          this.overflowX = overflowTuple[0];
          this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
          this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
          this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
          this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
          this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
          this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
          this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
          this.position = parse(context, position, declaration.position);
          this.textAlign = parse(context, textAlign, declaration.textAlign);
          this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
          this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
          this.textShadow = parse(context, textShadow, declaration.textShadow);
          this.textTransform = parse(context, textTransform, declaration.textTransform);
          this.transform = parse(context, transform$1, declaration.transform);
          this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
          this.visibility = parse(context, visibility, declaration.visibility);
          this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
          this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
          this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
          this.zIndex = parse(context, zIndex, declaration.zIndex);
        }
        CSSParsedDeclaration2.prototype.isVisible = function() {
          return this.display > 0 && this.opacity > 0 && this.visibility === 0;
        };
        CSSParsedDeclaration2.prototype.isTransparent = function() {
          return isTransparent(this.backgroundColor);
        };
        CSSParsedDeclaration2.prototype.isTransformed = function() {
          return this.transform !== null;
        };
        CSSParsedDeclaration2.prototype.isPositioned = function() {
          return this.position !== 0;
        };
        CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
          return this.isPositioned() && !this.zIndex.auto;
        };
        CSSParsedDeclaration2.prototype.isFloating = function() {
          return this.float !== 0;
        };
        CSSParsedDeclaration2.prototype.isInlineLevel = function() {
          return contains(
            this.display,
            4
            /* INLINE */
          ) || contains(
            this.display,
            33554432
            /* INLINE_BLOCK */
          ) || contains(
            this.display,
            268435456
            /* INLINE_FLEX */
          ) || contains(
            this.display,
            536870912
            /* INLINE_GRID */
          ) || contains(
            this.display,
            67108864
            /* INLINE_LIST_ITEM */
          ) || contains(
            this.display,
            134217728
            /* INLINE_TABLE */
          );
        };
        return CSSParsedDeclaration2;
      }()
    );
    var CSSParsedPseudoDeclaration = (
      /** @class */
      function() {
        function CSSParsedPseudoDeclaration2(context, declaration) {
          this.content = parse(context, content, declaration.content);
          this.quotes = parse(context, quotes, declaration.quotes);
        }
        return CSSParsedPseudoDeclaration2;
      }()
    );
    var CSSParsedCounterDeclaration = (
      /** @class */
      function() {
        function CSSParsedCounterDeclaration2(context, declaration) {
          this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
          this.counterReset = parse(context, counterReset, declaration.counterReset);
        }
        return CSSParsedCounterDeclaration2;
      }()
    );
    var parse = function(context, descriptor, style) {
      var tokenizer = new Tokenizer();
      var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
      tokenizer.write(value);
      var parser = new Parser(tokenizer.read());
      switch (descriptor.type) {
        case 2:
          var token = parser.parseComponentValue();
          return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
        case 0:
          return descriptor.parse(context, parser.parseComponentValue());
        case 1:
          return descriptor.parse(context, parser.parseComponentValues());
        case 4:
          return parser.parseComponentValue();
        case 3:
          switch (descriptor.format) {
            case "angle":
              return angle.parse(context, parser.parseComponentValue());
            case "color":
              return color$1.parse(context, parser.parseComponentValue());
            case "image":
              return image.parse(context, parser.parseComponentValue());
            case "length":
              var length_1 = parser.parseComponentValue();
              return isLength(length_1) ? length_1 : ZERO_LENGTH;
            case "length-percentage":
              var value_1 = parser.parseComponentValue();
              return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
            case "time":
              return time.parse(context, parser.parseComponentValue());
          }
          break;
      }
    };
    var elementDebuggerAttribute = "data-html2canvas-debug";
    var getElementDebugType = function(element2) {
      var attribute = element2.getAttribute(elementDebuggerAttribute);
      switch (attribute) {
        case "all":
          return 1;
        case "clone":
          return 2;
        case "parse":
          return 3;
        case "render":
          return 4;
        default:
          return 0;
      }
    };
    var isDebugging = function(element2, type) {
      var elementType = getElementDebugType(element2);
      return elementType === 1 || type === elementType;
    };
    var ElementContainer = (
      /** @class */
      function() {
        function ElementContainer2(context, element2) {
          this.context = context;
          this.textNodes = [];
          this.elements = [];
          this.flags = 0;
          if (isDebugging(
            element2,
            3
            /* PARSE */
          )) {
            debugger;
          }
          this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element2, null));
          if (isHTMLElementNode(element2)) {
            if (this.styles.animationDuration.some(function(duration2) {
              return duration2 > 0;
            })) {
              element2.style.animationDuration = "0s";
            }
            if (this.styles.transform !== null) {
              element2.style.transform = "none";
            }
          }
          this.bounds = parseBounds(this.context, element2);
          if (isDebugging(
            element2,
            4
            /* RENDER */
          )) {
            this.flags |= 16;
          }
        }
        return ElementContainer2;
      }()
    );
    var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
    var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
      lookup$1[chars$1.charCodeAt(i$1)] = i$1;
    }
    var decode = function(base642) {
      var bufferLength = base642.length * 0.75, len = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
      if (base642[base642.length - 1] === "=") {
        bufferLength--;
        if (base642[base642.length - 2] === "=") {
          bufferLength--;
        }
      }
      var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
      var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
      for (i2 = 0; i2 < len; i2 += 4) {
        encoded1 = lookup$1[base642.charCodeAt(i2)];
        encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
        encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
        encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
        bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return buffer;
    };
    var polyUint16Array = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i2 = 0; i2 < length; i2 += 2) {
        bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
      }
      return bytes;
    };
    var polyUint32Array = function(buffer) {
      var length = buffer.length;
      var bytes = [];
      for (var i2 = 0; i2 < length; i2 += 4) {
        bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
      }
      return bytes;
    };
    var UTRIE2_SHIFT_2 = 5;
    var UTRIE2_SHIFT_1 = 6 + 5;
    var UTRIE2_INDEX_SHIFT = 2;
    var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
    var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
    var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
    var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
    var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
    var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
    var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
    var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
    var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
    var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
    var slice16 = function(view, start2, end) {
      if (view.slice) {
        return view.slice(start2, end);
      }
      return new Uint16Array(Array.prototype.slice.call(view, start2, end));
    };
    var slice32 = function(view, start2, end) {
      if (view.slice) {
        return view.slice(start2, end);
      }
      return new Uint32Array(Array.prototype.slice.call(view, start2, end));
    };
    var createTrieFromBase64 = function(base642, _byteLength) {
      var buffer = decode(base642);
      var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
      var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
      var headerLength = 24;
      var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
      var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
      return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data);
    };
    var Trie = (
      /** @class */
      function() {
        function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
          this.initialValue = initialValue;
          this.errorValue = errorValue;
          this.highStart = highStart;
          this.highValueIndex = highValueIndex;
          this.index = index2;
          this.data = data;
        }
        Trie2.prototype.get = function(codePoint) {
          var ix;
          if (codePoint >= 0) {
            if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
              ix = this.index[codePoint >> UTRIE2_SHIFT_2];
              ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
              return this.data[ix];
            }
            if (codePoint <= 65535) {
              ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
              ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
              return this.data[ix];
            }
            if (codePoint < this.highStart) {
              ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
              ix = this.index[ix];
              ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
              ix = this.index[ix];
              ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
              return this.data[ix];
            }
            if (codePoint <= 1114111) {
              return this.data[this.highValueIndex];
            }
          }
          return this.errorValue;
        };
        return Trie2;
      }()
    );
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    var Prepend = 1;
    var CR = 2;
    var LF = 3;
    var Control = 4;
    var Extend = 5;
    var SpacingMark = 7;
    var L = 8;
    var V = 9;
    var T = 10;
    var LV = 11;
    var LVT = 12;
    var ZWJ = 13;
    var Extended_Pictographic = 14;
    var RI = 15;
    var toCodePoints = function(str) {
      var codePoints = [];
      var i2 = 0;
      var length = str.length;
      while (i2 < length) {
        var value = str.charCodeAt(i2++);
        if (value >= 55296 && value <= 56319 && i2 < length) {
          var extra = str.charCodeAt(i2++);
          if ((extra & 64512) === 56320) {
            codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            codePoints.push(value);
            i2--;
          }
        } else {
          codePoints.push(value);
        }
      }
      return codePoints;
    };
    var fromCodePoint = function() {
      var codePoints = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        codePoints[_i] = arguments[_i];
      }
      if (String.fromCodePoint) {
        return String.fromCodePoint.apply(String, codePoints);
      }
      var length = codePoints.length;
      if (!length) {
        return "";
      }
      var codeUnits = [];
      var index2 = -1;
      var result = "";
      while (++index2 < length) {
        var codePoint = codePoints[index2];
        if (codePoint <= 65535) {
          codeUnits.push(codePoint);
        } else {
          codePoint -= 65536;
          codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
        }
        if (index2 + 1 === length || codeUnits.length > 16384) {
          result += String.fromCharCode.apply(String, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
    var UnicodeTrie = createTrieFromBase64(base64);
    var BREAK_NOT_ALLOWED = "×";
    var BREAK_ALLOWED = "÷";
    var codePointToClass = function(codePoint) {
      return UnicodeTrie.get(codePoint);
    };
    var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
      var prevIndex = index2 - 2;
      var prev = classTypes[prevIndex];
      var current = classTypes[index2 - 1];
      var next = classTypes[index2];
      if (current === CR && next === LF) {
        return BREAK_NOT_ALLOWED;
      }
      if (current === CR || current === LF || current === Control) {
        return BREAK_ALLOWED;
      }
      if (next === CR || next === LF || next === Control) {
        return BREAK_ALLOWED;
      }
      if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
      }
      if ((current === LV || current === V) && (next === V || next === T)) {
        return BREAK_NOT_ALLOWED;
      }
      if ((current === LVT || current === T) && next === T) {
        return BREAK_NOT_ALLOWED;
      }
      if (next === ZWJ || next === Extend) {
        return BREAK_NOT_ALLOWED;
      }
      if (next === SpacingMark) {
        return BREAK_NOT_ALLOWED;
      }
      if (current === Prepend) {
        return BREAK_NOT_ALLOWED;
      }
      if (current === ZWJ && next === Extended_Pictographic) {
        while (prev === Extend) {
          prev = classTypes[--prevIndex];
        }
        if (prev === Extended_Pictographic) {
          return BREAK_NOT_ALLOWED;
        }
      }
      if (current === RI && next === RI) {
        var countRI = 0;
        while (prev === RI) {
          countRI++;
          prev = classTypes[--prevIndex];
        }
        if (countRI % 2 === 0) {
          return BREAK_NOT_ALLOWED;
        }
      }
      return BREAK_ALLOWED;
    };
    var GraphemeBreaker = function(str) {
      var codePoints = toCodePoints(str);
      var length = codePoints.length;
      var index2 = 0;
      var lastEnd = 0;
      var classTypes = codePoints.map(codePointToClass);
      return {
        next: function() {
          if (index2 >= length) {
            return { done: true, value: null };
          }
          var graphemeBreak = BREAK_NOT_ALLOWED;
          while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
          }
          if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {
            var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
            lastEnd = index2;
            return { value, done: false };
          }
          return { done: true, value: null };
        }
      };
    };
    var splitGraphemes = function(str) {
      var breaker = GraphemeBreaker(str);
      var graphemes = [];
      var bk;
      while (!(bk = breaker.next()).done) {
        if (bk.value) {
          graphemes.push(bk.value.slice());
        }
      }
      return graphemes;
    };
    var testRangeBounds = function(document2) {
      var TEST_HEIGHT = 123;
      if (document2.createRange) {
        var range = document2.createRange();
        if (range.getBoundingClientRect) {
          var testElement = document2.createElement("boundtest");
          testElement.style.height = TEST_HEIGHT + "px";
          testElement.style.display = "block";
          document2.body.appendChild(testElement);
          range.selectNode(testElement);
          var rangeBounds = range.getBoundingClientRect();
          var rangeHeight = Math.round(rangeBounds.height);
          document2.body.removeChild(testElement);
          if (rangeHeight === TEST_HEIGHT) {
            return true;
          }
        }
      }
      return false;
    };
    var testIOSLineBreak = function(document2) {
      var testElement = document2.createElement("boundtest");
      testElement.style.width = "50px";
      testElement.style.display = "block";
      testElement.style.fontSize = "12px";
      testElement.style.letterSpacing = "0px";
      testElement.style.wordSpacing = "0px";
      document2.body.appendChild(testElement);
      var range = document2.createRange();
      testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
      var node = testElement.firstChild;
      var textList = toCodePoints$1(node.data).map(function(i2) {
        return fromCodePoint$1(i2);
      });
      var offset = 0;
      var prev = {};
      var supports = textList.every(function(text, i2) {
        range.setStart(node, offset);
        range.setEnd(node, offset + text.length);
        var rect = range.getBoundingClientRect();
        offset += text.length;
        var boundAhead = rect.x > prev.x || rect.y > prev.y;
        prev = rect;
        if (i2 === 0) {
          return true;
        }
        return boundAhead;
      });
      document2.body.removeChild(testElement);
      return supports;
    };
    var testCORS = function() {
      return typeof new Image().crossOrigin !== "undefined";
    };
    var testResponseType = function() {
      return typeof new XMLHttpRequest().responseType === "string";
    };
    var testSVG = function(document2) {
      var img = new Image();
      var canvas = document2.createElement("canvas");
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return false;
      }
      img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
        ctx.drawImage(img, 0, 0);
        canvas.toDataURL();
      } catch (e3) {
        return false;
      }
      return true;
    };
    var isGreenPixel = function(data) {
      return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
    };
    var testForeignObject = function(document2) {
      var canvas = document2.createElement("canvas");
      var size2 = 100;
      canvas.width = size2;
      canvas.height = size2;
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return Promise.reject(false);
      }
      ctx.fillStyle = "rgb(0, 255, 0)";
      ctx.fillRect(0, 0, size2, size2);
      var img = new Image();
      var greenImageSrc = canvas.toDataURL();
      img.src = greenImageSrc;
      var svg = createForeignObjectSVG(size2, size2, 0, 0, img);
      ctx.fillStyle = "red";
      ctx.fillRect(0, 0, size2, size2);
      return loadSerializedSVG$1(svg).then(function(img2) {
        ctx.drawImage(img2, 0, 0);
        var data = ctx.getImageData(0, 0, size2, size2).data;
        ctx.fillStyle = "red";
        ctx.fillRect(0, 0, size2, size2);
        var node = document2.createElement("div");
        node.style.backgroundImage = "url(" + greenImageSrc + ")";
        node.style.height = size2 + "px";
        return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size2, size2, 0, 0, node)) : Promise.reject(false);
      }).then(function(img2) {
        ctx.drawImage(img2, 0, 0);
        return isGreenPixel(ctx.getImageData(0, 0, size2, size2).data);
      }).catch(function() {
        return false;
      });
    };
    var createForeignObjectSVG = function(width, height, x2, y2, node) {
      var xmlns = "http://www.w3.org/2000/svg";
      var svg = document.createElementNS(xmlns, "svg");
      var foreignObject = document.createElementNS(xmlns, "foreignObject");
      svg.setAttributeNS(null, "width", width.toString());
      svg.setAttributeNS(null, "height", height.toString());
      foreignObject.setAttributeNS(null, "width", "100%");
      foreignObject.setAttributeNS(null, "height", "100%");
      foreignObject.setAttributeNS(null, "x", x2.toString());
      foreignObject.setAttributeNS(null, "y", y2.toString());
      foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
      svg.appendChild(foreignObject);
      foreignObject.appendChild(node);
      return svg;
    };
    var loadSerializedSVG$1 = function(svg) {
      return new Promise(function(resolve2, reject) {
        var img = new Image();
        img.onload = function() {
          return resolve2(img);
        };
        img.onerror = reject;
        img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
    };
    var FEATURES = {
      get SUPPORT_RANGE_BOUNDS() {
        var value = testRangeBounds(document);
        Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
        return value;
      },
      get SUPPORT_WORD_BREAKING() {
        var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
        Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
        return value;
      },
      get SUPPORT_SVG_DRAWING() {
        var value = testSVG(document);
        Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
        return value;
      },
      get SUPPORT_FOREIGNOBJECT_DRAWING() {
        var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
        Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
        return value;
      },
      get SUPPORT_CORS_IMAGES() {
        var value = testCORS();
        Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
        return value;
      },
      get SUPPORT_RESPONSE_TYPE() {
        var value = testResponseType();
        Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
        return value;
      },
      get SUPPORT_CORS_XHR() {
        var value = "withCredentials" in new XMLHttpRequest();
        Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
        return value;
      },
      get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
        var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
        Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
        return value;
      }
    };
    var TextBounds = (
      /** @class */
      function() {
        function TextBounds2(text, bounds) {
          this.text = text;
          this.bounds = bounds;
        }
        return TextBounds2;
      }()
    );
    var parseTextBounds = function(context, value, styles, node) {
      var textList = breakText(value, styles);
      var textBounds = [];
      var offset = 0;
      textList.forEach(function(text) {
        if (styles.textDecorationLine.length || text.trim().length > 0) {
          if (FEATURES.SUPPORT_RANGE_BOUNDS) {
            var clientRects = createRange(node, offset, text.length).getClientRects();
            if (clientRects.length > 1) {
              var subSegments = segmentGraphemes(text);
              var subOffset_1 = 0;
              subSegments.forEach(function(subSegment) {
                textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
                subOffset_1 += subSegment.length;
              });
            } else {
              textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
            }
          } else {
            var replacementNode = node.splitText(text.length);
            textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
            node = replacementNode;
          }
        } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
          node = node.splitText(text.length);
        }
        offset += text.length;
      });
      return textBounds;
    };
    var getWrapperBounds = function(context, node) {
      var ownerDocument = node.ownerDocument;
      if (ownerDocument) {
        var wrapper = ownerDocument.createElement("html2canvaswrapper");
        wrapper.appendChild(node.cloneNode(true));
        var parentNode = node.parentNode;
        if (parentNode) {
          parentNode.replaceChild(wrapper, node);
          var bounds = parseBounds(context, wrapper);
          if (wrapper.firstChild) {
            parentNode.replaceChild(wrapper.firstChild, wrapper);
          }
          return bounds;
        }
      }
      return Bounds.EMPTY;
    };
    var createRange = function(node, offset, length) {
      var ownerDocument = node.ownerDocument;
      if (!ownerDocument) {
        throw new Error("Node has no owner document");
      }
      var range = ownerDocument.createRange();
      range.setStart(node, offset);
      range.setEnd(node, offset + length);
      return range;
    };
    var segmentGraphemes = function(value) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
        var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
        return Array.from(segmenter.segment(value)).map(function(segment) {
          return segment.segment;
        });
      }
      return splitGraphemes(value);
    };
    var segmentWords = function(value, styles) {
      if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
        var segmenter = new Intl.Segmenter(void 0, {
          granularity: "word"
        });
        return Array.from(segmenter.segment(value)).map(function(segment) {
          return segment.segment;
        });
      }
      return breakWords(value, styles);
    };
    var breakText = function(value, styles) {
      return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
    };
    var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
    var breakWords = function(str, styles) {
      var breaker = LineBreaker(str, {
        lineBreak: styles.lineBreak,
        wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
      });
      var words = [];
      var bk;
      var _loop_1 = function() {
        if (bk.value) {
          var value = bk.value.slice();
          var codePoints = toCodePoints$1(value);
          var word_1 = "";
          codePoints.forEach(function(codePoint) {
            if (wordSeparators.indexOf(codePoint) === -1) {
              word_1 += fromCodePoint$1(codePoint);
            } else {
              if (word_1.length) {
                words.push(word_1);
              }
              words.push(fromCodePoint$1(codePoint));
              word_1 = "";
            }
          });
          if (word_1.length) {
            words.push(word_1);
          }
        }
      };
      while (!(bk = breaker.next()).done) {
        _loop_1();
      }
      return words;
    };
    var TextContainer = (
      /** @class */
      function() {
        function TextContainer2(context, node, styles) {
          this.text = transform(node.data, styles.textTransform);
          this.textBounds = parseTextBounds(context, this.text, styles, node);
        }
        return TextContainer2;
      }()
    );
    var transform = function(text, transform2) {
      switch (transform2) {
        case 1:
          return text.toLowerCase();
        case 3:
          return text.replace(CAPITALIZE, capitalize);
        case 2:
          return text.toUpperCase();
        default:
          return text;
      }
    };
    var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
    var capitalize = function(m2, p1, p2) {
      if (m2.length > 0) {
        return p1 + p2.toUpperCase();
      }
      return m2;
    };
    var ImageElementContainer = (
      /** @class */
      function(_super) {
        __extends(ImageElementContainer2, _super);
        function ImageElementContainer2(context, img) {
          var _this = _super.call(this, context, img) || this;
          _this.src = img.currentSrc || img.src;
          _this.intrinsicWidth = img.naturalWidth;
          _this.intrinsicHeight = img.naturalHeight;
          _this.context.cache.addImage(_this.src);
          return _this;
        }
        return ImageElementContainer2;
      }(ElementContainer)
    );
    var CanvasElementContainer = (
      /** @class */
      function(_super) {
        __extends(CanvasElementContainer2, _super);
        function CanvasElementContainer2(context, canvas) {
          var _this = _super.call(this, context, canvas) || this;
          _this.canvas = canvas;
          _this.intrinsicWidth = canvas.width;
          _this.intrinsicHeight = canvas.height;
          return _this;
        }
        return CanvasElementContainer2;
      }(ElementContainer)
    );
    var SVGElementContainer = (
      /** @class */
      function(_super) {
        __extends(SVGElementContainer2, _super);
        function SVGElementContainer2(context, img) {
          var _this = _super.call(this, context, img) || this;
          var s = new XMLSerializer();
          var bounds = parseBounds(context, img);
          img.setAttribute("width", bounds.width + "px");
          img.setAttribute("height", bounds.height + "px");
          _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
          _this.intrinsicWidth = img.width.baseVal.value;
          _this.intrinsicHeight = img.height.baseVal.value;
          _this.context.cache.addImage(_this.svg);
          return _this;
        }
        return SVGElementContainer2;
      }(ElementContainer)
    );
    var LIElementContainer = (
      /** @class */
      function(_super) {
        __extends(LIElementContainer2, _super);
        function LIElementContainer2(context, element2) {
          var _this = _super.call(this, context, element2) || this;
          _this.value = element2.value;
          return _this;
        }
        return LIElementContainer2;
      }(ElementContainer)
    );
    var OLElementContainer = (
      /** @class */
      function(_super) {
        __extends(OLElementContainer2, _super);
        function OLElementContainer2(context, element2) {
          var _this = _super.call(this, context, element2) || this;
          _this.start = element2.start;
          _this.reversed = typeof element2.reversed === "boolean" && element2.reversed === true;
          return _this;
        }
        return OLElementContainer2;
      }(ElementContainer)
    );
    var CHECKBOX_BORDER_RADIUS = [
      {
        type: 15,
        flags: 0,
        unit: "px",
        number: 3
      }
    ];
    var RADIO_BORDER_RADIUS = [
      {
        type: 16,
        flags: 0,
        number: 50
      }
    ];
    var reformatInputBounds = function(bounds) {
      if (bounds.width > bounds.height) {
        return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
      } else if (bounds.width < bounds.height) {
        return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
      }
      return bounds;
    };
    var getInputValue = function(node) {
      var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("•") : node.value;
      return value.length === 0 ? node.placeholder || "" : value;
    };
    var CHECKBOX = "checkbox";
    var RADIO = "radio";
    var PASSWORD = "password";
    var INPUT_COLOR = 707406591;
    var InputElementContainer = (
      /** @class */
      function(_super) {
        __extends(InputElementContainer2, _super);
        function InputElementContainer2(context, input) {
          var _this = _super.call(this, context, input) || this;
          _this.type = input.type.toLowerCase();
          _this.checked = input.checked;
          _this.value = getInputValue(input);
          if (_this.type === CHECKBOX || _this.type === RADIO) {
            _this.styles.backgroundColor = 3739148031;
            _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
            _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
            _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
            _this.styles.backgroundClip = [
              0
              /* BORDER_BOX */
            ];
            _this.styles.backgroundOrigin = [
              0
              /* BORDER_BOX */
            ];
            _this.bounds = reformatInputBounds(_this.bounds);
          }
          switch (_this.type) {
            case CHECKBOX:
              _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
              break;
            case RADIO:
              _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
              break;
          }
          return _this;
        }
        return InputElementContainer2;
      }(ElementContainer)
    );
    var SelectElementContainer = (
      /** @class */
      function(_super) {
        __extends(SelectElementContainer2, _super);
        function SelectElementContainer2(context, element2) {
          var _this = _super.call(this, context, element2) || this;
          var option = element2.options[element2.selectedIndex || 0];
          _this.value = option ? option.text || "" : "";
          return _this;
        }
        return SelectElementContainer2;
      }(ElementContainer)
    );
    var TextareaElementContainer = (
      /** @class */
      function(_super) {
        __extends(TextareaElementContainer2, _super);
        function TextareaElementContainer2(context, element2) {
          var _this = _super.call(this, context, element2) || this;
          _this.value = element2.value;
          return _this;
        }
        return TextareaElementContainer2;
      }(ElementContainer)
    );
    var IFrameElementContainer = (
      /** @class */
      function(_super) {
        __extends(IFrameElementContainer2, _super);
        function IFrameElementContainer2(context, iframe) {
          var _this = _super.call(this, context, iframe) || this;
          _this.src = iframe.src;
          _this.width = parseInt(iframe.width, 10) || 0;
          _this.height = parseInt(iframe.height, 10) || 0;
          _this.backgroundColor = _this.styles.backgroundColor;
          try {
            if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
              _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
              var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
              var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
              _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
            }
          } catch (e3) {
          }
          return _this;
        }
        return IFrameElementContainer2;
      }(ElementContainer)
    );
    var LIST_OWNERS = ["OL", "UL", "MENU"];
    var parseNodeTree = function(context, node, parent, root2) {
      for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
        nextNode = childNode.nextSibling;
        if (isTextNode(childNode) && childNode.data.trim().length > 0) {
          parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
        } else if (isElementNode(childNode)) {
          if (isSlotElement(childNode) && childNode.assignedNodes) {
            childNode.assignedNodes().forEach(function(childNode2) {
              return parseNodeTree(context, childNode2, parent, root2);
            });
          } else {
            var container = createContainer(context, childNode);
            if (container.styles.isVisible()) {
              if (createsRealStackingContext(childNode, container, root2)) {
                container.flags |= 4;
              } else if (createsStackingContext(container.styles)) {
                container.flags |= 2;
              }
              if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                container.flags |= 8;
              }
              parent.elements.push(container);
              childNode.slot;
              if (childNode.shadowRoot) {
                parseNodeTree(context, childNode.shadowRoot, container, root2);
              } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                parseNodeTree(context, childNode, container, root2);
              }
            }
          }
        }
      }
    };
    var createContainer = function(context, element2) {
      if (isImageElement(element2)) {
        return new ImageElementContainer(context, element2);
      }
      if (isCanvasElement(element2)) {
        return new CanvasElementContainer(context, element2);
      }
      if (isSVGElement(element2)) {
        return new SVGElementContainer(context, element2);
      }
      if (isLIElement(element2)) {
        return new LIElementContainer(context, element2);
      }
      if (isOLElement(element2)) {
        return new OLElementContainer(context, element2);
      }
      if (isInputElement(element2)) {
        return new InputElementContainer(context, element2);
      }
      if (isSelectElement(element2)) {
        return new SelectElementContainer(context, element2);
      }
      if (isTextareaElement(element2)) {
        return new TextareaElementContainer(context, element2);
      }
      if (isIFrameElement(element2)) {
        return new IFrameElementContainer(context, element2);
      }
      return new ElementContainer(context, element2);
    };
    var parseTree = function(context, element2) {
      var container = createContainer(context, element2);
      container.flags |= 4;
      parseNodeTree(context, element2, container, container);
      return container;
    };
    var createsRealStackingContext = function(node, container, root2) {
      return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root2.styles.isTransparent();
    };
    var createsStackingContext = function(styles) {
      return styles.isPositioned() || styles.isFloating();
    };
    var isTextNode = function(node) {
      return node.nodeType === Node.TEXT_NODE;
    };
    var isElementNode = function(node) {
      return node.nodeType === Node.ELEMENT_NODE;
    };
    var isHTMLElementNode = function(node) {
      return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
    };
    var isSVGElementNode = function(element2) {
      return typeof element2.className === "object";
    };
    var isLIElement = function(node) {
      return node.tagName === "LI";
    };
    var isOLElement = function(node) {
      return node.tagName === "OL";
    };
    var isInputElement = function(node) {
      return node.tagName === "INPUT";
    };
    var isHTMLElement = function(node) {
      return node.tagName === "HTML";
    };
    var isSVGElement = function(node) {
      return node.tagName === "svg";
    };
    var isBodyElement = function(node) {
      return node.tagName === "BODY";
    };
    var isCanvasElement = function(node) {
      return node.tagName === "CANVAS";
    };
    var isVideoElement = function(node) {
      return node.tagName === "VIDEO";
    };
    var isImageElement = function(node) {
      return node.tagName === "IMG";
    };
    var isIFrameElement = function(node) {
      return node.tagName === "IFRAME";
    };
    var isStyleElement = function(node) {
      return node.tagName === "STYLE";
    };
    var isScriptElement = function(node) {
      return node.tagName === "SCRIPT";
    };
    var isTextareaElement = function(node) {
      return node.tagName === "TEXTAREA";
    };
    var isSelectElement = function(node) {
      return node.tagName === "SELECT";
    };
    var isSlotElement = function(node) {
      return node.tagName === "SLOT";
    };
    var isCustomElement = function(node) {
      return node.tagName.indexOf("-") > 0;
    };
    var CounterState = (
      /** @class */
      function() {
        function CounterState2() {
          this.counters = {};
        }
        CounterState2.prototype.getCounterValue = function(name) {
          var counter = this.counters[name];
          if (counter && counter.length) {
            return counter[counter.length - 1];
          }
          return 1;
        };
        CounterState2.prototype.getCounterValues = function(name) {
          var counter = this.counters[name];
          return counter ? counter : [];
        };
        CounterState2.prototype.pop = function(counters) {
          var _this = this;
          counters.forEach(function(counter) {
            return _this.counters[counter].pop();
          });
        };
        CounterState2.prototype.parse = function(style) {
          var _this = this;
          var counterIncrement2 = style.counterIncrement;
          var counterReset2 = style.counterReset;
          var canReset = true;
          if (counterIncrement2 !== null) {
            counterIncrement2.forEach(function(entry) {
              var counter = _this.counters[entry.counter];
              if (counter && entry.increment !== 0) {
                canReset = false;
                if (!counter.length) {
                  counter.push(1);
                }
                counter[Math.max(0, counter.length - 1)] += entry.increment;
              }
            });
          }
          var counterNames = [];
          if (canReset) {
            counterReset2.forEach(function(entry) {
              var counter = _this.counters[entry.counter];
              counterNames.push(entry.counter);
              if (!counter) {
                counter = _this.counters[entry.counter] = [];
              }
              counter.push(entry.reset);
            });
          }
          return counterNames;
        };
        return CounterState2;
      }()
    );
    var ROMAN_UPPER = {
      integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
      values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
    };
    var ARMENIAN = {
      integers: [
        9e3,
        8e3,
        7e3,
        6e3,
        5e3,
        4e3,
        3e3,
        2e3,
        1e3,
        900,
        800,
        700,
        600,
        500,
        400,
        300,
        200,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20,
        10,
        9,
        8,
        7,
        6,
        5,
        4,
        3,
        2,
        1
      ],
      values: [
        "Ք",
        "Փ",
        "Ւ",
        "Ց",
        "Ր",
        "Տ",
        "Վ",
        "Ս",
        "Ռ",
        "Ջ",
        "Պ",
        "Չ",
        "Ո",
        "Շ",
        "Ն",
        "Յ",
        "Մ",
        "Ճ",
        "Ղ",
        "Ձ",
        "Հ",
        "Կ",
        "Ծ",
        "Խ",
        "Լ",
        "Ի",
        "Ժ",
        "Թ",
        "Ը",
        "Է",
        "Զ",
        "Ե",
        "Դ",
        "Գ",
        "Բ",
        "Ա"
      ]
    };
    var HEBREW = {
      integers: [
        1e4,
        9e3,
        8e3,
        7e3,
        6e3,
        5e3,
        4e3,
        3e3,
        2e3,
        1e3,
        400,
        300,
        200,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20,
        19,
        18,
        17,
        16,
        15,
        10,
        9,
        8,
        7,
        6,
        5,
        4,
        3,
        2,
        1
      ],
      values: [
        "י׳",
        "ט׳",
        "ח׳",
        "ז׳",
        "ו׳",
        "ה׳",
        "ד׳",
        "ג׳",
        "ב׳",
        "א׳",
        "ת",
        "ש",
        "ר",
        "ק",
        "צ",
        "פ",
        "ע",
        "ס",
        "נ",
        "מ",
        "ל",
        "כ",
        "יט",
        "יח",
        "יז",
        "טז",
        "טו",
        "י",
        "ט",
        "ח",
        "ז",
        "ו",
        "ה",
        "ד",
        "ג",
        "ב",
        "א"
      ]
    };
    var GEORGIAN = {
      integers: [
        1e4,
        9e3,
        8e3,
        7e3,
        6e3,
        5e3,
        4e3,
        3e3,
        2e3,
        1e3,
        900,
        800,
        700,
        600,
        500,
        400,
        300,
        200,
        100,
        90,
        80,
        70,
        60,
        50,
        40,
        30,
        20,
        10,
        9,
        8,
        7,
        6,
        5,
        4,
        3,
        2,
        1
      ],
      values: [
        "ჵ",
        "ჰ",
        "ჯ",
        "ჴ",
        "ხ",
        "ჭ",
        "წ",
        "ძ",
        "ც",
        "ჩ",
        "შ",
        "ყ",
        "ღ",
        "ქ",
        "ფ",
        "ჳ",
        "ტ",
        "ს",
        "რ",
        "ჟ",
        "პ",
        "ო",
        "ჲ",
        "ნ",
        "მ",
        "ლ",
        "კ",
        "ი",
        "თ",
        "ჱ",
        "ზ",
        "ვ",
        "ე",
        "დ",
        "გ",
        "ბ",
        "ა"
      ]
    };
    var createAdditiveCounter = function(value, min, max, symbols, fallback, suffix) {
      if (value < min || value > max) {
        return createCounterText(value, fallback, suffix.length > 0);
      }
      return symbols.integers.reduce(function(string, integer, index2) {
        while (value >= integer) {
          value -= integer;
          string += symbols.values[index2];
        }
        return string;
      }, "") + suffix;
    };
    var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
      var string = "";
      do {
        if (!isNumeric) {
          value--;
        }
        string = resolver(value) + string;
        value /= codePointRangeLength;
      } while (value * codePointRangeLength >= codePointRangeLength);
      return string;
    };
    var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
      var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
      return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
        return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
      }) + suffix);
    };
    var createCounterStyleFromSymbols = function(value, symbols, suffix) {
      if (suffix === void 0) {
        suffix = ". ";
      }
      var codePointRangeLength = symbols.length;
      return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
        return symbols[Math.floor(codePoint % codePointRangeLength)];
      }) + suffix;
    };
    var CJK_ZEROS = 1 << 0;
    var CJK_TEN_COEFFICIENTS = 1 << 1;
    var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
    var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
    var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
      if (value < -9999 || value > 9999) {
        return createCounterText(value, 4, suffix.length > 0);
      }
      var tmp = Math.abs(value);
      var string = suffix;
      if (tmp === 0) {
        return numbers[0] + string;
      }
      for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
        var coefficient = tmp % 10;
        if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
          string = numbers[coefficient] + string;
        } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
          string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
        } else if (coefficient === 1 && digit > 0) {
          string = multipliers[digit - 1] + string;
        }
        tmp = Math.floor(tmp / 10);
      }
      return (value < 0 ? negativeSign : "") + string;
    };
    var CHINESE_INFORMAL_MULTIPLIERS = "十百千萬";
    var CHINESE_FORMAL_MULTIPLIERS = "拾佰仟萬";
    var JAPANESE_NEGATIVE = "マイナス";
    var KOREAN_NEGATIVE = "마이너스";
    var createCounterText = function(value, type, appendSuffix) {
      var defaultSuffix = appendSuffix ? ". " : "";
      var cjkSuffix = appendSuffix ? "、" : "";
      var koreanSuffix = appendSuffix ? ", " : "";
      var spaceSuffix = appendSuffix ? " " : "";
      switch (type) {
        case 0:
          return "•" + spaceSuffix;
        case 1:
          return "◦" + spaceSuffix;
        case 2:
          return "◾" + spaceSuffix;
        case 5:
          var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
          return string.length < 4 ? "0" + string : string;
        case 4:
          return createCounterStyleFromSymbols(value, "〇一二三四五六七八九", cjkSuffix);
        case 6:
          return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
        case 7:
          return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
        case 8:
          return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
        case 9:
          return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
        case 10:
          return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
        case 11:
          return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
        case 12:
        case 49:
          return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
        case 35:
          return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
        case 13:
          return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
        case 14:
        case 30:
          return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
        case 15:
          return createCounterStyleFromSymbols(value, "子丑寅卯辰巳午未申酉戌亥", cjkSuffix);
        case 16:
          return createCounterStyleFromSymbols(value, "甲乙丙丁戊己庚辛壬癸", cjkSuffix);
        case 17:
        case 48:
          return createCJKCounter(value, "零一二三四五六七八九", CHINESE_INFORMAL_MULTIPLIERS, "負", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 47:
          return createCJKCounter(value, "零壹貳參肆伍陸柒捌玖", CHINESE_FORMAL_MULTIPLIERS, "負", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 42:
          return createCJKCounter(value, "零一二三四五六七八九", CHINESE_INFORMAL_MULTIPLIERS, "负", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 41:
          return createCJKCounter(value, "零壹贰叁肆伍陆柒捌玖", CHINESE_FORMAL_MULTIPLIERS, "负", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case 26:
          return createCJKCounter(value, "〇一二三四五六七八九", "十百千万", JAPANESE_NEGATIVE, cjkSuffix, 0);
        case 25:
          return createCJKCounter(value, "零壱弐参四伍六七八九", "拾百千万", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case 31:
          return createCJKCounter(value, "영일이삼사오육칠팔구", "십백천만", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case 33:
          return createCJKCounter(value, "零一二三四五六七八九", "十百千萬", KOREAN_NEGATIVE, koreanSuffix, 0);
        case 32:
          return createCJKCounter(value, "零壹貳參四五六七八九", "拾百千", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case 18:
          return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
        case 20:
          return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
        case 21:
          return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
        case 22:
          return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
        case 22:
          return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
        case 23:
          return createCounterStyleFromSymbols(value, "あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわゐゑをん");
        case 24:
          return createCounterStyleFromSymbols(value, "いろはにほへとちりぬるをわかよたれそつねならむうゐのおくやまけふこえてあさきゆめみしゑひもせす");
        case 27:
          return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
        case 28:
          return createCounterStyleFromSymbols(value, "アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン", cjkSuffix);
        case 29:
          return createCounterStyleFromSymbols(value, "イロハニホヘトチリヌルヲワカヨタレソツネナラムウヰノオクヤマケフコエテアサキユメミシヱヒモセス", cjkSuffix);
        case 34:
          return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
        case 37:
          return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
        case 38:
          return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
        case 39:
          return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
        case 40:
          return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
        case 43:
          return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
        case 44:
          return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
        case 45:
          return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
        case 46:
          return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
        case 3:
        default:
          return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      }
    };
    var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
    var DocumentCloner = (
      /** @class */
      function() {
        function DocumentCloner2(context, element2, options) {
          this.context = context;
          this.options = options;
          this.scrolledElements = [];
          this.referenceElement = element2;
          this.counters = new CounterState();
          this.quoteDepth = 0;
          if (!element2.ownerDocument) {
            throw new Error("Cloned element does not have an owner document");
          }
          this.documentElement = this.cloneNode(element2.ownerDocument.documentElement, false);
        }
        DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
          var _this = this;
          var iframe = createIFrameContainer(ownerDocument, windowSize);
          if (!iframe.contentWindow) {
            return Promise.reject("Unable to find iframe window");
          }
          var scrollX = ownerDocument.defaultView.pageXOffset;
          var scrollY = ownerDocument.defaultView.pageYOffset;
          var cloneWindow = iframe.contentWindow;
          var documentClone = cloneWindow.document;
          var iframeLoad = iframeLoader(iframe).then(function() {
            return __awaiter(_this, void 0, void 0, function() {
              var onclone, referenceElement;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    this.scrolledElements.forEach(restoreNodeScroll);
                    if (cloneWindow) {
                      cloneWindow.scrollTo(windowSize.left, windowSize.top);
                      if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                        this.context.logger.warn("Unable to restore scroll position for cloned document");
                        this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                      }
                    }
                    onclone = this.options.onclone;
                    referenceElement = this.clonedReferenceElement;
                    if (typeof referenceElement === "undefined") {
                      return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                    }
                    if (!(documentClone.fonts && documentClone.fonts.ready))
                      return [3, 2];
                    return [4, documentClone.fonts.ready];
                  case 1:
                    _a2.sent();
                    _a2.label = 2;
                  case 2:
                    if (!/(AppleWebKit)/g.test(navigator.userAgent))
                      return [3, 4];
                    return [4, imagesReady(documentClone)];
                  case 3:
                    _a2.sent();
                    _a2.label = 4;
                  case 4:
                    if (typeof onclone === "function") {
                      return [2, Promise.resolve().then(function() {
                        return onclone(documentClone, referenceElement);
                      }).then(function() {
                        return iframe;
                      })];
                    }
                    return [2, iframe];
                }
              });
            });
          });
          documentClone.open();
          documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
          restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
          documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
          documentClone.close();
          return iframeLoad;
        };
        DocumentCloner2.prototype.createElementClone = function(node) {
          if (isDebugging(
            node,
            2
            /* CLONE */
          )) {
            debugger;
          }
          if (isCanvasElement(node)) {
            return this.createCanvasClone(node);
          }
          if (isVideoElement(node)) {
            return this.createVideoClone(node);
          }
          if (isStyleElement(node)) {
            return this.createStyleClone(node);
          }
          var clone = node.cloneNode(false);
          if (isImageElement(clone)) {
            if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
              clone.src = node.currentSrc;
              clone.srcset = "";
            }
            if (clone.loading === "lazy") {
              clone.loading = "eager";
            }
          }
          if (isCustomElement(clone)) {
            return this.createCustomElementClone(clone);
          }
          return clone;
        };
        DocumentCloner2.prototype.createCustomElementClone = function(node) {
          var clone = document.createElement("html2canvascustomelement");
          copyCSSStyles(node.style, clone);
          return clone;
        };
        DocumentCloner2.prototype.createStyleClone = function(node) {
          try {
            var sheet = node.sheet;
            if (sheet && sheet.cssRules) {
              var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
                if (rule && typeof rule.cssText === "string") {
                  return css2 + rule.cssText;
                }
                return css2;
              }, "");
              var style = node.cloneNode(false);
              style.textContent = css;
              return style;
            }
          } catch (e3) {
            this.context.logger.error("Unable to access cssRules property", e3);
            if (e3.name !== "SecurityError") {
              throw e3;
            }
          }
          return node.cloneNode(false);
        };
        DocumentCloner2.prototype.createCanvasClone = function(canvas) {
          var _a2;
          if (this.options.inlineImages && canvas.ownerDocument) {
            var img = canvas.ownerDocument.createElement("img");
            try {
              img.src = canvas.toDataURL();
              return img;
            } catch (e3) {
              this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
            }
          }
          var clonedCanvas = canvas.cloneNode(false);
          try {
            clonedCanvas.width = canvas.width;
            clonedCanvas.height = canvas.height;
            var ctx = canvas.getContext("2d");
            var clonedCtx = clonedCanvas.getContext("2d");
            if (clonedCtx) {
              if (!this.options.allowTaint && ctx) {
                clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
              } else {
                var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
                if (gl) {
                  var attribs = gl.getContextAttributes();
                  if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                    this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                  }
                }
                clonedCtx.drawImage(canvas, 0, 0);
              }
            }
            return clonedCanvas;
          } catch (e3) {
            this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
          }
          return clonedCanvas;
        };
        DocumentCloner2.prototype.createVideoClone = function(video) {
          var canvas = video.ownerDocument.createElement("canvas");
          canvas.width = video.offsetWidth;
          canvas.height = video.offsetHeight;
          var ctx = canvas.getContext("2d");
          try {
            if (ctx) {
              ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
              if (!this.options.allowTaint) {
                ctx.getImageData(0, 0, canvas.width, canvas.height);
              }
            }
            return canvas;
          } catch (e3) {
            this.context.logger.info("Unable to clone video as it is tainted", video);
          }
          var blankCanvas = video.ownerDocument.createElement("canvas");
          blankCanvas.width = video.offsetWidth;
          blankCanvas.height = video.offsetHeight;
          return blankCanvas;
        };
        DocumentCloner2.prototype.appendChildNode = function(clone, child, copyStyles) {
          if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
            if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
              clone.appendChild(this.cloneNode(child, copyStyles));
            }
          }
        };
        DocumentCloner2.prototype.cloneChildNodes = function(node, clone, copyStyles) {
          var _this = this;
          for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
            if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
              var assignedNodes = child.assignedNodes();
              if (assignedNodes.length) {
                assignedNodes.forEach(function(assignedNode) {
                  return _this.appendChildNode(clone, assignedNode, copyStyles);
                });
              }
            } else {
              this.appendChildNode(clone, child, copyStyles);
            }
          }
        };
        DocumentCloner2.prototype.cloneNode = function(node, copyStyles) {
          if (isTextNode(node)) {
            return document.createTextNode(node.data);
          }
          if (!node.ownerDocument) {
            return node.cloneNode(false);
          }
          var window2 = node.ownerDocument.defaultView;
          if (window2 && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
            var clone = this.createElementClone(node);
            clone.style.transitionProperty = "none";
            var style = window2.getComputedStyle(node);
            var styleBefore = window2.getComputedStyle(node, ":before");
            var styleAfter = window2.getComputedStyle(node, ":after");
            if (this.referenceElement === node && isHTMLElementNode(clone)) {
              this.clonedReferenceElement = clone;
            }
            if (isBodyElement(clone)) {
              createPseudoHideStyles(clone);
            }
            var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
            var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
            if (isCustomElement(node)) {
              copyStyles = true;
            }
            if (!isVideoElement(node)) {
              this.cloneChildNodes(node, clone, copyStyles);
            }
            if (before) {
              clone.insertBefore(before, clone.firstChild);
            }
            var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
            if (after) {
              clone.appendChild(after);
            }
            this.counters.pop(counters);
            if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node) || copyStyles) {
              copyCSSStyles(style, clone);
            }
            if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
              this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
            }
            if ((isTextareaElement(node) || isSelectElement(node)) && (isTextareaElement(clone) || isSelectElement(clone))) {
              clone.value = node.value;
            }
            return clone;
          }
          return node.cloneNode(false);
        };
        DocumentCloner2.prototype.resolvePseudoContent = function(node, clone, style, pseudoElt) {
          var _this = this;
          if (!style) {
            return;
          }
          var value = style.content;
          var document2 = clone.ownerDocument;
          if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
            return;
          }
          this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
          var declaration = new CSSParsedPseudoDeclaration(this.context, style);
          var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
          copyCSSStyles(style, anonymousReplacedElement);
          declaration.content.forEach(function(token) {
            if (token.type === 0) {
              anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
            } else if (token.type === 22) {
              var img = document2.createElement("img");
              img.src = token.value;
              img.style.opacity = "1";
              anonymousReplacedElement.appendChild(img);
            } else if (token.type === 18) {
              if (token.name === "attr") {
                var attr = token.values.filter(isIdentToken);
                if (attr.length) {
                  anonymousReplacedElement.appendChild(document2.createTextNode(node.getAttribute(attr[0].value) || ""));
                }
              } else if (token.name === "counter") {
                var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
                if (counter && isIdentToken(counter)) {
                  var counterState = _this.counters.getCounterValue(counter.value);
                  var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                  anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
                }
              } else if (token.name === "counters") {
                var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
                if (counter && isIdentToken(counter)) {
                  var counterStates = _this.counters.getCounterValues(counter.value);
                  var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                  var separator = delim && delim.type === 0 ? delim.value : "";
                  var text = counterStates.map(function(value2) {
                    return createCounterText(value2, counterType_1, false);
                  }).join(separator);
                  anonymousReplacedElement.appendChild(document2.createTextNode(text));
                }
              } else
                ;
            } else if (token.type === 20) {
              switch (token.value) {
                case "open-quote":
                  anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                  break;
                case "close-quote":
                  anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                  break;
                default:
                  anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
              }
            }
          });
          anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
          if (isSVGElementNode(clone)) {
            clone.className.baseValue += newClassName;
          } else {
            clone.className += newClassName;
          }
          return anonymousReplacedElement;
        };
        DocumentCloner2.destroy = function(container) {
          if (container.parentNode) {
            container.parentNode.removeChild(container);
            return true;
          }
          return false;
        };
        return DocumentCloner2;
      }()
    );
    var PseudoElementType;
    (function(PseudoElementType2) {
      PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
      PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
    })(PseudoElementType || (PseudoElementType = {}));
    var createIFrameContainer = function(ownerDocument, bounds) {
      var cloneIframeContainer = ownerDocument.createElement("iframe");
      cloneIframeContainer.className = "html2canvas-container";
      cloneIframeContainer.style.visibility = "hidden";
      cloneIframeContainer.style.position = "fixed";
      cloneIframeContainer.style.left = "-10000px";
      cloneIframeContainer.style.top = "0px";
      cloneIframeContainer.style.border = "0";
      cloneIframeContainer.width = bounds.width.toString();
      cloneIframeContainer.height = bounds.height.toString();
      cloneIframeContainer.scrolling = "no";
      cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
      ownerDocument.body.appendChild(cloneIframeContainer);
      return cloneIframeContainer;
    };
    var imageReady = function(img) {
      return new Promise(function(resolve2) {
        if (img.complete) {
          resolve2();
          return;
        }
        if (!img.src) {
          resolve2();
          return;
        }
        img.onload = resolve2;
        img.onerror = resolve2;
      });
    };
    var imagesReady = function(document2) {
      return Promise.all([].slice.call(document2.images, 0).map(imageReady));
    };
    var iframeLoader = function(iframe) {
      return new Promise(function(resolve2, reject) {
        var cloneWindow = iframe.contentWindow;
        if (!cloneWindow) {
          return reject("No window assigned for iframe");
        }
        var documentClone = cloneWindow.document;
        cloneWindow.onload = iframe.onload = function() {
          cloneWindow.onload = iframe.onload = null;
          var interval2 = setInterval(function() {
            if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
              clearInterval(interval2);
              resolve2(iframe);
            }
          }, 50);
        };
      });
    };
    var ignoredStyleProperties = [
      "all",
      "d",
      "content"
      // Safari shows pseudoelements if content is set
    ];
    var copyCSSStyles = function(style, target) {
      for (var i2 = style.length - 1; i2 >= 0; i2--) {
        var property = style.item(i2);
        if (ignoredStyleProperties.indexOf(property) === -1) {
          target.style.setProperty(property, style.getPropertyValue(property));
        }
      }
      return target;
    };
    var serializeDoctype = function(doctype) {
      var str = "";
      if (doctype) {
        str += "<!DOCTYPE ";
        if (doctype.name) {
          str += doctype.name;
        }
        if (doctype.internalSubset) {
          str += doctype.internalSubset;
        }
        if (doctype.publicId) {
          str += '"' + doctype.publicId + '"';
        }
        if (doctype.systemId) {
          str += '"' + doctype.systemId + '"';
        }
        str += ">";
      }
      return str;
    };
    var restoreOwnerScroll = function(ownerDocument, x2, y2) {
      if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y2 !== ownerDocument.defaultView.pageYOffset)) {
        ownerDocument.defaultView.scrollTo(x2, y2);
      }
    };
    var restoreNodeScroll = function(_a2) {
      var element2 = _a2[0], x2 = _a2[1], y2 = _a2[2];
      element2.scrollLeft = x2;
      element2.scrollTop = y2;
    };
    var PSEUDO_BEFORE = ":before";
    var PSEUDO_AFTER = ":after";
    var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
    var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
    var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
    var createPseudoHideStyles = function(body) {
      createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
    };
    var createStyles = function(body, styles) {
      var document2 = body.ownerDocument;
      if (document2) {
        var style = document2.createElement("style");
        style.textContent = styles;
        body.appendChild(style);
      }
    };
    var CacheStorage = (
      /** @class */
      function() {
        function CacheStorage2() {
        }
        CacheStorage2.getOrigin = function(url) {
          var link2 = CacheStorage2._link;
          if (!link2) {
            return "about:blank";
          }
          link2.href = url;
          link2.href = link2.href;
          return link2.protocol + link2.hostname + link2.port;
        };
        CacheStorage2.isSameOrigin = function(src) {
          return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
        };
        CacheStorage2.setContext = function(window2) {
          CacheStorage2._link = window2.document.createElement("a");
          CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
        };
        CacheStorage2._origin = "about:blank";
        return CacheStorage2;
      }()
    );
    var Cache = (
      /** @class */
      function() {
        function Cache2(context, _options) {
          this.context = context;
          this._options = _options;
          this._cache = {};
        }
        Cache2.prototype.addImage = function(src) {
          var result = Promise.resolve();
          if (this.has(src)) {
            return result;
          }
          if (isBlobImage(src) || isRenderable(src)) {
            (this._cache[src] = this.loadImage(src)).catch(function() {
            });
            return result;
          }
          return result;
        };
        Cache2.prototype.match = function(src) {
          return this._cache[src];
        };
        Cache2.prototype.loadImage = function(key) {
          return __awaiter(this, void 0, void 0, function() {
            var isSameOrigin, useCORS, useProxy, src;
            var _this = this;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  isSameOrigin = CacheStorage.isSameOrigin(key);
                  useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                  useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                  if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  src = key;
                  if (!useProxy)
                    return [3, 2];
                  return [4, this.proxy(src)];
                case 1:
                  src = _a2.sent();
                  _a2.label = 2;
                case 2:
                  this.context.logger.debug("Added image " + key.substring(0, 256));
                  return [4, new Promise(function(resolve2, reject) {
                    var img = new Image();
                    img.onload = function() {
                      return resolve2(img);
                    };
                    img.onerror = reject;
                    if (isInlineBase64Image(src) || useCORS) {
                      img.crossOrigin = "anonymous";
                    }
                    img.src = src;
                    if (img.complete === true) {
                      setTimeout(function() {
                        return resolve2(img);
                      }, 500);
                    }
                    if (_this._options.imageTimeout > 0) {
                      setTimeout(function() {
                        return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                      }, _this._options.imageTimeout);
                    }
                  })];
                case 3:
                  return [2, _a2.sent()];
              }
            });
          });
        };
        Cache2.prototype.has = function(key) {
          return typeof this._cache[key] !== "undefined";
        };
        Cache2.prototype.keys = function() {
          return Promise.resolve(Object.keys(this._cache));
        };
        Cache2.prototype.proxy = function(src) {
          var _this = this;
          var proxy = this._options.proxy;
          if (!proxy) {
            throw new Error("No proxy defined");
          }
          var key = src.substring(0, 256);
          return new Promise(function(resolve2, reject) {
            var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
            var xhr = new XMLHttpRequest();
            xhr.onload = function() {
              if (xhr.status === 200) {
                if (responseType === "text") {
                  resolve2(xhr.response);
                } else {
                  var reader_1 = new FileReader();
                  reader_1.addEventListener("load", function() {
                    return resolve2(reader_1.result);
                  }, false);
                  reader_1.addEventListener("error", function(e3) {
                    return reject(e3);
                  }, false);
                  reader_1.readAsDataURL(xhr.response);
                }
              } else {
                reject("Failed to proxy resource " + key + " with status code " + xhr.status);
              }
            };
            xhr.onerror = reject;
            var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
            xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
            if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
              xhr.responseType = responseType;
            }
            if (_this._options.imageTimeout) {
              var timeout_1 = _this._options.imageTimeout;
              xhr.timeout = timeout_1;
              xhr.ontimeout = function() {
                return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
              };
            }
            xhr.send();
          });
        };
        return Cache2;
      }()
    );
    var INLINE_SVG = /^data:image\/svg\+xml/i;
    var INLINE_BASE64 = /^data:image\/.*;base64,/i;
    var INLINE_IMG = /^data:image\/.*/i;
    var isRenderable = function(src) {
      return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
    };
    var isInlineImage = function(src) {
      return INLINE_IMG.test(src);
    };
    var isInlineBase64Image = function(src) {
      return INLINE_BASE64.test(src);
    };
    var isBlobImage = function(src) {
      return src.substr(0, 4) === "blob";
    };
    var isSVG = function(src) {
      return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
    };
    var Vector = (
      /** @class */
      function() {
        function Vector2(x2, y2) {
          this.type = 0;
          this.x = x2;
          this.y = y2;
        }
        Vector2.prototype.add = function(deltaX, deltaY) {
          return new Vector2(this.x + deltaX, this.y + deltaY);
        };
        return Vector2;
      }()
    );
    var lerp = function(a2, b, t) {
      return new Vector(a2.x + (b.x - a2.x) * t, a2.y + (b.y - a2.y) * t);
    };
    var BezierCurve = (
      /** @class */
      function() {
        function BezierCurve2(start2, startControl, endControl, end) {
          this.type = 1;
          this.start = start2;
          this.startControl = startControl;
          this.endControl = endControl;
          this.end = end;
        }
        BezierCurve2.prototype.subdivide = function(t, firstHalf) {
          var ab = lerp(this.start, this.startControl, t);
          var bc = lerp(this.startControl, this.endControl, t);
          var cd = lerp(this.endControl, this.end, t);
          var abbc = lerp(ab, bc, t);
          var bccd = lerp(bc, cd, t);
          var dest = lerp(abbc, bccd, t);
          return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
        };
        BezierCurve2.prototype.add = function(deltaX, deltaY) {
          return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
        };
        BezierCurve2.prototype.reverse = function() {
          return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
        };
        return BezierCurve2;
      }()
    );
    var isBezierCurve = function(path) {
      return path.type === 1;
    };
    var BoundCurves = (
      /** @class */
      function() {
        function BoundCurves2(element2) {
          var styles = element2.styles;
          var bounds = element2.bounds;
          var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
          var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
          var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
          var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
          var factors = [];
          factors.push((tlh + trh) / bounds.width);
          factors.push((blh + brh) / bounds.width);
          factors.push((tlv + blv) / bounds.height);
          factors.push((trv + brv) / bounds.height);
          var maxFactor = Math.max.apply(Math, factors);
          if (maxFactor > 1) {
            tlh /= maxFactor;
            tlv /= maxFactor;
            trh /= maxFactor;
            trv /= maxFactor;
            brh /= maxFactor;
            brv /= maxFactor;
            blh /= maxFactor;
            blv /= maxFactor;
          }
          var topWidth = bounds.width - trh;
          var rightHeight = bounds.height - brv;
          var bottomWidth = bounds.width - brh;
          var leftHeight = bounds.height - blv;
          var borderTopWidth2 = styles.borderTopWidth;
          var borderRightWidth2 = styles.borderRightWidth;
          var borderBottomWidth2 = styles.borderBottomWidth;
          var borderLeftWidth2 = styles.borderLeftWidth;
          var paddingTop2 = getAbsoluteValue(styles.paddingTop, element2.bounds.width);
          var paddingRight2 = getAbsoluteValue(styles.paddingRight, element2.bounds.width);
          var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element2.bounds.width);
          var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element2.bounds.width);
          this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
          this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
          this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
          this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
          this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
          this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
          this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
          this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
          this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
          this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
          this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
          this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
          this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
          this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
          this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
          this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
          this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
          this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
          this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
          this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
          this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
          this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
          this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
          this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
        }
        return BoundCurves2;
      }()
    );
    var CORNER;
    (function(CORNER2) {
      CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
      CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
      CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
      CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
    })(CORNER || (CORNER = {}));
    var getCurvePoints = function(x2, y2, r1, r2, position2) {
      var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
      var ox = r1 * kappa;
      var oy = r2 * kappa;
      var xm = x2 + r1;
      var ym = y2 + r2;
      switch (position2) {
        case CORNER.TOP_LEFT:
          return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));
        case CORNER.TOP_RIGHT:
          return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));
        case CORNER.BOTTOM_RIGHT:
          return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
        case CORNER.BOTTOM_LEFT:
        default:
          return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));
      }
    };
    var calculateBorderBoxPath = function(curves) {
      return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
    };
    var calculateContentBoxPath = function(curves) {
      return [
        curves.topLeftContentBox,
        curves.topRightContentBox,
        curves.bottomRightContentBox,
        curves.bottomLeftContentBox
      ];
    };
    var calculatePaddingBoxPath = function(curves) {
      return [
        curves.topLeftPaddingBox,
        curves.topRightPaddingBox,
        curves.bottomRightPaddingBox,
        curves.bottomLeftPaddingBox
      ];
    };
    var TransformEffect = (
      /** @class */
      function() {
        function TransformEffect2(offsetX, offsetY, matrix2) {
          this.offsetX = offsetX;
          this.offsetY = offsetY;
          this.matrix = matrix2;
          this.type = 0;
          this.target = 2 | 4;
        }
        return TransformEffect2;
      }()
    );
    var ClipEffect = (
      /** @class */
      function() {
        function ClipEffect2(path, target) {
          this.path = path;
          this.target = target;
          this.type = 1;
        }
        return ClipEffect2;
      }()
    );
    var OpacityEffect = (
      /** @class */
      function() {
        function OpacityEffect2(opacity2) {
          this.opacity = opacity2;
          this.type = 2;
          this.target = 2 | 4;
        }
        return OpacityEffect2;
      }()
    );
    var isTransformEffect = function(effect) {
      return effect.type === 0;
    };
    var isClipEffect = function(effect) {
      return effect.type === 1;
    };
    var isOpacityEffect = function(effect) {
      return effect.type === 2;
    };
    var equalPath = function(a2, b) {
      if (a2.length === b.length) {
        return a2.some(function(v, i2) {
          return v === b[i2];
        });
      }
      return false;
    };
    var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
      return path.map(function(point, index2) {
        switch (index2) {
          case 0:
            return point.add(deltaX, deltaY);
          case 1:
            return point.add(deltaX + deltaW, deltaY);
          case 2:
            return point.add(deltaX + deltaW, deltaY + deltaH);
          case 3:
            return point.add(deltaX, deltaY + deltaH);
        }
        return point;
      });
    };
    var StackingContext = (
      /** @class */
      function() {
        function StackingContext2(container) {
          this.element = container;
          this.inlineLevel = [];
          this.nonInlineLevel = [];
          this.negativeZIndex = [];
          this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
          this.positiveZIndex = [];
          this.nonPositionedFloats = [];
          this.nonPositionedInlineLevel = [];
        }
        return StackingContext2;
      }()
    );
    var ElementPaint = (
      /** @class */
      function() {
        function ElementPaint2(container, parent) {
          this.container = container;
          this.parent = parent;
          this.effects = [];
          this.curves = new BoundCurves(this.container);
          if (this.container.styles.opacity < 1) {
            this.effects.push(new OpacityEffect(this.container.styles.opacity));
          }
          if (this.container.styles.transform !== null) {
            var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
            var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
            var matrix2 = this.container.styles.transform;
            this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
          }
          if (this.container.styles.overflowX !== 0) {
            var borderBox = calculateBorderBoxPath(this.curves);
            var paddingBox2 = calculatePaddingBoxPath(this.curves);
            if (equalPath(borderBox, paddingBox2)) {
              this.effects.push(new ClipEffect(
                borderBox,
                2 | 4
                /* CONTENT */
              ));
            } else {
              this.effects.push(new ClipEffect(
                borderBox,
                2
                /* BACKGROUND_BORDERS */
              ));
              this.effects.push(new ClipEffect(
                paddingBox2,
                4
                /* CONTENT */
              ));
            }
          }
        }
        ElementPaint2.prototype.getEffects = function(target) {
          var inFlow = [
            2,
            3
            /* FIXED */
          ].indexOf(this.container.styles.position) === -1;
          var parent = this.parent;
          var effects = this.effects.slice(0);
          while (parent) {
            var croplessEffects = parent.effects.filter(function(effect) {
              return !isClipEffect(effect);
            });
            if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
              effects.unshift.apply(effects, croplessEffects);
              inFlow = [
                2,
                3
                /* FIXED */
              ].indexOf(parent.container.styles.position) === -1;
              if (parent.container.styles.overflowX !== 0) {
                var borderBox = calculateBorderBoxPath(parent.curves);
                var paddingBox2 = calculatePaddingBoxPath(parent.curves);
                if (!equalPath(borderBox, paddingBox2)) {
                  effects.unshift(new ClipEffect(
                    paddingBox2,
                    2 | 4
                    /* CONTENT */
                  ));
                }
              }
            } else {
              effects.unshift.apply(effects, croplessEffects);
            }
            parent = parent.parent;
          }
          return effects.filter(function(effect) {
            return contains(effect.target, target);
          });
        };
        return ElementPaint2;
      }()
    );
    var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
      parent.container.elements.forEach(function(child) {
        var treatAsRealStackingContext = contains(
          child.flags,
          4
          /* CREATES_REAL_STACKING_CONTEXT */
        );
        var createsStackingContext2 = contains(
          child.flags,
          2
          /* CREATES_STACKING_CONTEXT */
        );
        var paintContainer = new ElementPaint(child, parent);
        if (contains(
          child.styles.display,
          2048
          /* LIST_ITEM */
        )) {
          listItems.push(paintContainer);
        }
        var listOwnerItems = contains(
          child.flags,
          8
          /* IS_LIST_OWNER */
        ) ? [] : listItems;
        if (treatAsRealStackingContext || createsStackingContext2) {
          var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
          var stack = new StackingContext(paintContainer);
          if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
            var order_1 = child.styles.zIndex.order;
            if (order_1 < 0) {
              var index_1 = 0;
              parentStack.negativeZIndex.some(function(current, i2) {
                if (order_1 > current.element.container.styles.zIndex.order) {
                  index_1 = i2;
                  return false;
                } else if (index_1 > 0) {
                  return true;
                }
                return false;
              });
              parentStack.negativeZIndex.splice(index_1, 0, stack);
            } else if (order_1 > 0) {
              var index_2 = 0;
              parentStack.positiveZIndex.some(function(current, i2) {
                if (order_1 >= current.element.container.styles.zIndex.order) {
                  index_2 = i2 + 1;
                  return false;
                } else if (index_2 > 0) {
                  return true;
                }
                return false;
              });
              parentStack.positiveZIndex.splice(index_2, 0, stack);
            } else {
              parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
            }
          } else {
            if (child.styles.isFloating()) {
              parentStack.nonPositionedFloats.push(stack);
            } else {
              parentStack.nonPositionedInlineLevel.push(stack);
            }
          }
          parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
        } else {
          if (child.styles.isInlineLevel()) {
            stackingContext.inlineLevel.push(paintContainer);
          } else {
            stackingContext.nonInlineLevel.push(paintContainer);
          }
          parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
        }
        if (contains(
          child.flags,
          8
          /* IS_LIST_OWNER */
        )) {
          processListItems(child, listOwnerItems);
        }
      });
    };
    var processListItems = function(owner, elements) {
      var numbering = owner instanceof OLElementContainer ? owner.start : 1;
      var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
      for (var i2 = 0; i2 < elements.length; i2++) {
        var item = elements[i2];
        if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
          numbering = item.container.value;
        }
        item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
        numbering += reversed ? -1 : 1;
      }
    };
    var parseStackingContexts = function(container) {
      var paintContainer = new ElementPaint(container, null);
      var root2 = new StackingContext(paintContainer);
      var listItems = [];
      parseStackTree(paintContainer, root2, root2, listItems);
      processListItems(paintContainer.container, listItems);
      return root2;
    };
    var parsePathForBorder = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
        case 1:
          return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
        case 2:
          return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
        case 3:
        default:
          return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
      }
    };
    var parsePathForBorderDoubleOuter = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
        case 1:
          return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
        case 2:
          return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
        case 3:
        default:
          return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
      }
    };
    var parsePathForBorderDoubleInner = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
        case 1:
          return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
        case 2:
          return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
        case 3:
        default:
          return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
      }
    };
    var parsePathForBorderStroke = function(curves, borderSide) {
      switch (borderSide) {
        case 0:
          return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
        case 1:
          return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
        case 2:
          return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
        case 3:
        default:
          return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
      }
    };
    var createStrokePathFromCurves = function(outer1, outer2) {
      var path = [];
      if (isBezierCurve(outer1)) {
        path.push(outer1.subdivide(0.5, false));
      } else {
        path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
        path.push(outer2.subdivide(0.5, true));
      } else {
        path.push(outer2);
      }
      return path;
    };
    var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
      var path = [];
      if (isBezierCurve(outer1)) {
        path.push(outer1.subdivide(0.5, false));
      } else {
        path.push(outer1);
      }
      if (isBezierCurve(outer2)) {
        path.push(outer2.subdivide(0.5, true));
      } else {
        path.push(outer2);
      }
      if (isBezierCurve(inner2)) {
        path.push(inner2.subdivide(0.5, true).reverse());
      } else {
        path.push(inner2);
      }
      if (isBezierCurve(inner1)) {
        path.push(inner1.subdivide(0.5, false).reverse());
      } else {
        path.push(inner1);
      }
      return path;
    };
    var paddingBox = function(element2) {
      var bounds = element2.bounds;
      var styles = element2.styles;
      return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
    };
    var contentBox = function(element2) {
      var styles = element2.styles;
      var bounds = element2.bounds;
      var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
      var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
      var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
      var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
      return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
    };
    var calculateBackgroundPositioningArea = function(backgroundOrigin2, element2) {
      if (backgroundOrigin2 === 0) {
        return element2.bounds;
      }
      if (backgroundOrigin2 === 2) {
        return contentBox(element2);
      }
      return paddingBox(element2);
    };
    var calculateBackgroundPaintingArea = function(backgroundClip2, element2) {
      if (backgroundClip2 === 0) {
        return element2.bounds;
      }
      if (backgroundClip2 === 2) {
        return contentBox(element2);
      }
      return paddingBox(element2);
    };
    var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
      var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
      var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
      var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
      var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
      var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
      var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
      var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
      var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
      return [path, offsetX, offsetY, sizeWidth, sizeHeight];
    };
    var isAuto = function(token) {
      return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
    };
    var hasIntrinsicValue = function(value) {
      return typeof value === "number";
    };
    var calculateBackgroundSize = function(size2, _a2, bounds) {
      var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
      var first = size2[0], second = size2[1];
      if (!first) {
        return [0, 0];
      }
      if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
        return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
      }
      var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
      if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
        if (hasIntrinsicValue(intrinsicProportion)) {
          var targetRatio = bounds.width / bounds.height;
          return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
        }
        return [bounds.width, bounds.height];
      }
      var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
      var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
      var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
      if (isAuto(first) && (!second || isAuto(second))) {
        if (hasIntrinsicWidth && hasIntrinsicHeight) {
          return [intrinsicWidth, intrinsicHeight];
        }
        if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
          return [bounds.width, bounds.height];
        }
        if (hasIntrinsicDimensions && hasIntrinsicProportion) {
          var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
          var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
          return [width_1, height_1];
        }
        var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
        var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
        return [width_2, height_2];
      }
      if (hasIntrinsicProportion) {
        var width_3 = 0;
        var height_3 = 0;
        if (isLengthPercentage(first)) {
          width_3 = getAbsoluteValue(first, bounds.width);
        } else if (isLengthPercentage(second)) {
          height_3 = getAbsoluteValue(second, bounds.height);
        }
        if (isAuto(first)) {
          width_3 = height_3 * intrinsicProportion;
        } else if (!second || isAuto(second)) {
          height_3 = width_3 / intrinsicProportion;
        }
        return [width_3, height_3];
      }
      var width = null;
      var height = null;
      if (isLengthPercentage(first)) {
        width = getAbsoluteValue(first, bounds.width);
      } else if (second && isLengthPercentage(second)) {
        height = getAbsoluteValue(second, bounds.height);
      }
      if (width !== null && (!second || isAuto(second))) {
        height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
      }
      if (height !== null && isAuto(first)) {
        width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
      }
      if (width !== null && height !== null) {
        return [width, height];
      }
      throw new Error("Unable to calculate background-size for element");
    };
    var getBackgroundValueForIndex = function(values, index2) {
      var value = values[index2];
      if (typeof value === "undefined") {
        return values[0];
      }
      return value;
    };
    var calculateBackgroundRepeatPath = function(repeat, _a2, _b, backgroundPositioningArea, backgroundPaintingArea) {
      var x2 = _a2[0], y2 = _a2[1];
      var width = _b[0], height = _b[1];
      switch (repeat) {
        case 2:
          return [
            new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)),
            new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)),
            new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y2)),
            new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y2))
          ];
        case 3:
          return [
            new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
            new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)),
            new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
            new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
          ];
        case 1:
          return [
            new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)),
            new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2)),
            new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2 + height)),
            new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height))
          ];
        default:
          return [
            new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
            new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
            new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
            new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
          ];
      }
    };
    var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    var SAMPLE_TEXT = "Hidden Text";
    var FontMetrics = (
      /** @class */
      function() {
        function FontMetrics2(document2) {
          this._data = {};
          this._document = document2;
        }
        FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
          var container = this._document.createElement("div");
          var img = this._document.createElement("img");
          var span = this._document.createElement("span");
          var body = this._document.body;
          container.style.visibility = "hidden";
          container.style.fontFamily = fontFamily2;
          container.style.fontSize = fontSize2;
          container.style.margin = "0";
          container.style.padding = "0";
          container.style.whiteSpace = "nowrap";
          body.appendChild(container);
          img.src = SMALL_IMAGE;
          img.width = 1;
          img.height = 1;
          img.style.margin = "0";
          img.style.padding = "0";
          img.style.verticalAlign = "baseline";
          span.style.fontFamily = fontFamily2;
          span.style.fontSize = fontSize2;
          span.style.margin = "0";
          span.style.padding = "0";
          span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
          container.appendChild(span);
          container.appendChild(img);
          var baseline = img.offsetTop - span.offsetTop + 2;
          container.removeChild(span);
          container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
          container.style.lineHeight = "normal";
          img.style.verticalAlign = "super";
          var middle = img.offsetTop - container.offsetTop + 2;
          body.removeChild(container);
          return { baseline, middle };
        };
        FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
          var key = fontFamily2 + " " + fontSize2;
          if (typeof this._data[key] === "undefined") {
            this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
          }
          return this._data[key];
        };
        return FontMetrics2;
      }()
    );
    var Renderer = (
      /** @class */
      function() {
        function Renderer2(context, options) {
          this.context = context;
          this.options = options;
        }
        return Renderer2;
      }()
    );
    var MASK_OFFSET = 1e4;
    var CanvasRenderer = (
      /** @class */
      function(_super) {
        __extends(CanvasRenderer2, _super);
        function CanvasRenderer2(context, options) {
          var _this = _super.call(this, context, options) || this;
          _this._activeEffects = [];
          _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
          _this.ctx = _this.canvas.getContext("2d");
          if (!options.canvas) {
            _this.canvas.width = Math.floor(options.width * options.scale);
            _this.canvas.height = Math.floor(options.height * options.scale);
            _this.canvas.style.width = options.width + "px";
            _this.canvas.style.height = options.height + "px";
          }
          _this.fontMetrics = new FontMetrics(document);
          _this.ctx.scale(_this.options.scale, _this.options.scale);
          _this.ctx.translate(-options.x, -options.y);
          _this.ctx.textBaseline = "bottom";
          _this._activeEffects = [];
          _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
          return _this;
        }
        CanvasRenderer2.prototype.applyEffects = function(effects) {
          var _this = this;
          while (this._activeEffects.length) {
            this.popEffect();
          }
          effects.forEach(function(effect) {
            return _this.applyEffect(effect);
          });
        };
        CanvasRenderer2.prototype.applyEffect = function(effect) {
          this.ctx.save();
          if (isOpacityEffect(effect)) {
            this.ctx.globalAlpha = effect.opacity;
          }
          if (isTransformEffect(effect)) {
            this.ctx.translate(effect.offsetX, effect.offsetY);
            this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
            this.ctx.translate(-effect.offsetX, -effect.offsetY);
          }
          if (isClipEffect(effect)) {
            this.path(effect.path);
            this.ctx.clip();
          }
          this._activeEffects.push(effect);
        };
        CanvasRenderer2.prototype.popEffect = function() {
          this._activeEffects.pop();
          this.ctx.restore();
        };
        CanvasRenderer2.prototype.renderStack = function(stack) {
          return __awaiter(this, void 0, void 0, function() {
            var styles;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  styles = stack.element.container.styles;
                  if (!styles.isVisible())
                    return [3, 2];
                  return [4, this.renderStackContent(stack)];
                case 1:
                  _a2.sent();
                  _a2.label = 2;
                case 2:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        CanvasRenderer2.prototype.renderNode = function(paint) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (contains(
                    paint.container.flags,
                    16
                    /* DEBUG_RENDER */
                  )) {
                    debugger;
                  }
                  if (!paint.container.styles.isVisible())
                    return [3, 3];
                  return [4, this.renderNodeBackgroundAndBorders(paint)];
                case 1:
                  _a2.sent();
                  return [4, this.renderNodeContent(paint)];
                case 2:
                  _a2.sent();
                  _a2.label = 3;
                case 3:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
          var _this = this;
          if (letterSpacing2 === 0) {
            this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
          } else {
            var letters = segmentGraphemes(text.text);
            letters.reduce(function(left, letter) {
              _this.ctx.fillText(letter, left, text.bounds.top + baseline);
              return left + _this.ctx.measureText(letter).width;
            }, text.bounds.left);
          }
        };
        CanvasRenderer2.prototype.createFontStyle = function(styles) {
          var fontVariant2 = styles.fontVariant.filter(function(variant) {
            return variant === "normal" || variant === "small-caps";
          }).join("");
          var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
          var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
          return [
            [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
            fontFamily2,
            fontSize2
          ];
        };
        CanvasRenderer2.prototype.renderTextNode = function(text, styles) {
          return __awaiter(this, void 0, void 0, function() {
            var _a2, font, fontFamily2, fontSize2, _b, baseline, middle, paintOrder2;
            var _this = this;
            return __generator(this, function(_c) {
              _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
              this.ctx.font = font;
              this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
              this.ctx.textAlign = "left";
              this.ctx.textBaseline = "alphabetic";
              _b = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b.baseline, middle = _b.middle;
              paintOrder2 = styles.paintOrder;
              text.textBounds.forEach(function(text2) {
                paintOrder2.forEach(function(paintOrderLayer) {
                  switch (paintOrderLayer) {
                    case 0:
                      _this.ctx.fillStyle = asString(styles.color);
                      _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                      var textShadows = styles.textShadow;
                      if (textShadows.length && text2.text.trim().length) {
                        textShadows.slice(0).reverse().forEach(function(textShadow2) {
                          _this.ctx.shadowColor = asString(textShadow2.color);
                          _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                          _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                          _this.ctx.shadowBlur = textShadow2.blur.number;
                          _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                        });
                        _this.ctx.shadowColor = "";
                        _this.ctx.shadowOffsetX = 0;
                        _this.ctx.shadowOffsetY = 0;
                        _this.ctx.shadowBlur = 0;
                      }
                      if (styles.textDecorationLine.length) {
                        _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                        styles.textDecorationLine.forEach(function(textDecorationLine2) {
                          switch (textDecorationLine2) {
                            case 1:
                              _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                              break;
                            case 2:
                              _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                              break;
                            case 3:
                              _this.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                              break;
                          }
                        });
                      }
                      break;
                    case 1:
                      if (styles.webkitTextStrokeWidth && text2.text.trim().length) {
                        _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                        _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                        _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                        _this.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                      }
                      _this.ctx.strokeStyle = "";
                      _this.ctx.lineWidth = 0;
                      _this.ctx.lineJoin = "miter";
                      break;
                  }
                });
              });
              return [
                2
                /*return*/
              ];
            });
          });
        };
        CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
          if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
            var box = contentBox(container);
            var path = calculatePaddingBoxPath(curves);
            this.path(path);
            this.ctx.save();
            this.ctx.clip();
            this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
            this.ctx.restore();
          }
        };
        CanvasRenderer2.prototype.renderNodeContent = function(paint) {
          return __awaiter(this, void 0, void 0, function() {
            var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size2, _b, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  this.applyEffects(paint.getEffects(
                    4
                    /* CONTENT */
                  ));
                  container = paint.container;
                  curves = paint.curves;
                  styles = container.styles;
                  _i = 0, _a2 = container.textNodes;
                  _c.label = 1;
                case 1:
                  if (!(_i < _a2.length))
                    return [3, 4];
                  child = _a2[_i];
                  return [4, this.renderTextNode(child, styles)];
                case 2:
                  _c.sent();
                  _c.label = 3;
                case 3:
                  _i++;
                  return [3, 1];
                case 4:
                  if (!(container instanceof ImageElementContainer))
                    return [3, 8];
                  _c.label = 5;
                case 5:
                  _c.trys.push([5, 7, , 8]);
                  return [4, this.context.cache.match(container.src)];
                case 6:
                  image2 = _c.sent();
                  this.renderReplacedElement(container, curves, image2);
                  return [3, 8];
                case 7:
                  _c.sent();
                  this.context.logger.error("Error loading image " + container.src);
                  return [3, 8];
                case 8:
                  if (container instanceof CanvasElementContainer) {
                    this.renderReplacedElement(container, curves, container.canvas);
                  }
                  if (!(container instanceof SVGElementContainer))
                    return [3, 12];
                  _c.label = 9;
                case 9:
                  _c.trys.push([9, 11, , 12]);
                  return [4, this.context.cache.match(container.svg)];
                case 10:
                  image2 = _c.sent();
                  this.renderReplacedElement(container, curves, image2);
                  return [3, 12];
                case 11:
                  _c.sent();
                  this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                  return [3, 12];
                case 12:
                  if (!(container instanceof IFrameElementContainer && container.tree))
                    return [3, 14];
                  iframeRenderer = new CanvasRenderer2(this.context, {
                    scale: this.options.scale,
                    backgroundColor: container.backgroundColor,
                    x: 0,
                    y: 0,
                    width: container.width,
                    height: container.height
                  });
                  return [4, iframeRenderer.render(container.tree)];
                case 13:
                  canvas = _c.sent();
                  if (container.width && container.height) {
                    this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                  }
                  _c.label = 14;
                case 14:
                  if (container instanceof InputElementContainer) {
                    size2 = Math.min(container.bounds.width, container.bounds.height);
                    if (container.type === CHECKBOX) {
                      if (container.checked) {
                        this.ctx.save();
                        this.path([
                          new Vector(container.bounds.left + size2 * 0.39363, container.bounds.top + size2 * 0.79),
                          new Vector(container.bounds.left + size2 * 0.16, container.bounds.top + size2 * 0.5549),
                          new Vector(container.bounds.left + size2 * 0.27347, container.bounds.top + size2 * 0.44071),
                          new Vector(container.bounds.left + size2 * 0.39694, container.bounds.top + size2 * 0.5649),
                          new Vector(container.bounds.left + size2 * 0.72983, container.bounds.top + size2 * 0.23),
                          new Vector(container.bounds.left + size2 * 0.84, container.bounds.top + size2 * 0.34085),
                          new Vector(container.bounds.left + size2 * 0.39363, container.bounds.top + size2 * 0.79)
                        ]);
                        this.ctx.fillStyle = asString(INPUT_COLOR);
                        this.ctx.fill();
                        this.ctx.restore();
                      }
                    } else if (container.type === RADIO) {
                      if (container.checked) {
                        this.ctx.save();
                        this.ctx.beginPath();
                        this.ctx.arc(container.bounds.left + size2 / 2, container.bounds.top + size2 / 2, size2 / 4, 0, Math.PI * 2, true);
                        this.ctx.fillStyle = asString(INPUT_COLOR);
                        this.ctx.fill();
                        this.ctx.restore();
                      }
                    }
                  }
                  if (isTextInputElement(container) && container.value.length) {
                    _b = this.createFontStyle(styles), fontFamily2 = _b[0], fontSize2 = _b[1];
                    baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                    this.ctx.font = fontFamily2;
                    this.ctx.fillStyle = asString(styles.color);
                    this.ctx.textBaseline = "alphabetic";
                    this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                    bounds = contentBox(container);
                    x2 = 0;
                    switch (container.styles.textAlign) {
                      case 1:
                        x2 += bounds.width / 2;
                        break;
                      case 2:
                        x2 += bounds.width;
                        break;
                    }
                    textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                    this.ctx.save();
                    this.path([
                      new Vector(bounds.left, bounds.top),
                      new Vector(bounds.left + bounds.width, bounds.top),
                      new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                      new Vector(bounds.left, bounds.top + bounds.height)
                    ]);
                    this.ctx.clip();
                    this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                    this.ctx.restore();
                    this.ctx.textBaseline = "alphabetic";
                    this.ctx.textAlign = "left";
                  }
                  if (!contains(
                    container.styles.display,
                    2048
                    /* LIST_ITEM */
                  ))
                    return [3, 20];
                  if (!(container.styles.listStyleImage !== null))
                    return [3, 19];
                  img = container.styles.listStyleImage;
                  if (!(img.type === 0))
                    return [3, 18];
                  image2 = void 0;
                  url = img.url;
                  _c.label = 15;
                case 15:
                  _c.trys.push([15, 17, , 18]);
                  return [4, this.context.cache.match(url)];
                case 16:
                  image2 = _c.sent();
                  this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                  return [3, 18];
                case 17:
                  _c.sent();
                  this.context.logger.error("Error loading list-style-image " + url);
                  return [3, 18];
                case 18:
                  return [3, 20];
                case 19:
                  if (paint.listValue && container.styles.listStyleType !== -1) {
                    fontFamily2 = this.createFontStyle(styles)[0];
                    this.ctx.font = fontFamily2;
                    this.ctx.fillStyle = asString(styles.color);
                    this.ctx.textBaseline = "middle";
                    this.ctx.textAlign = "right";
                    bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                    this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                    this.ctx.textBaseline = "bottom";
                    this.ctx.textAlign = "left";
                  }
                  _c.label = 20;
                case 20:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        CanvasRenderer2.prototype.renderStackContent = function(stack) {
          return __awaiter(this, void 0, void 0, function() {
            var _i, _a2, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
            return __generator(this, function(_p) {
              switch (_p.label) {
                case 0:
                  if (contains(
                    stack.element.container.flags,
                    16
                    /* DEBUG_RENDER */
                  )) {
                    debugger;
                  }
                  return [4, this.renderNodeBackgroundAndBorders(stack.element)];
                case 1:
                  _p.sent();
                  _i = 0, _a2 = stack.negativeZIndex;
                  _p.label = 2;
                case 2:
                  if (!(_i < _a2.length))
                    return [3, 5];
                  child = _a2[_i];
                  return [4, this.renderStack(child)];
                case 3:
                  _p.sent();
                  _p.label = 4;
                case 4:
                  _i++;
                  return [3, 2];
                case 5:
                  return [4, this.renderNodeContent(stack.element)];
                case 6:
                  _p.sent();
                  _b = 0, _c = stack.nonInlineLevel;
                  _p.label = 7;
                case 7:
                  if (!(_b < _c.length))
                    return [3, 10];
                  child = _c[_b];
                  return [4, this.renderNode(child)];
                case 8:
                  _p.sent();
                  _p.label = 9;
                case 9:
                  _b++;
                  return [3, 7];
                case 10:
                  _d = 0, _e = stack.nonPositionedFloats;
                  _p.label = 11;
                case 11:
                  if (!(_d < _e.length))
                    return [3, 14];
                  child = _e[_d];
                  return [4, this.renderStack(child)];
                case 12:
                  _p.sent();
                  _p.label = 13;
                case 13:
                  _d++;
                  return [3, 11];
                case 14:
                  _f = 0, _g = stack.nonPositionedInlineLevel;
                  _p.label = 15;
                case 15:
                  if (!(_f < _g.length))
                    return [3, 18];
                  child = _g[_f];
                  return [4, this.renderStack(child)];
                case 16:
                  _p.sent();
                  _p.label = 17;
                case 17:
                  _f++;
                  return [3, 15];
                case 18:
                  _h = 0, _j = stack.inlineLevel;
                  _p.label = 19;
                case 19:
                  if (!(_h < _j.length))
                    return [3, 22];
                  child = _j[_h];
                  return [4, this.renderNode(child)];
                case 20:
                  _p.sent();
                  _p.label = 21;
                case 21:
                  _h++;
                  return [3, 19];
                case 22:
                  _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                  _p.label = 23;
                case 23:
                  if (!(_k < _l.length))
                    return [3, 26];
                  child = _l[_k];
                  return [4, this.renderStack(child)];
                case 24:
                  _p.sent();
                  _p.label = 25;
                case 25:
                  _k++;
                  return [3, 23];
                case 26:
                  _m = 0, _o = stack.positiveZIndex;
                  _p.label = 27;
                case 27:
                  if (!(_m < _o.length))
                    return [3, 30];
                  child = _o[_m];
                  return [4, this.renderStack(child)];
                case 28:
                  _p.sent();
                  _p.label = 29;
                case 29:
                  _m++;
                  return [3, 27];
                case 30:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        CanvasRenderer2.prototype.mask = function(paths) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, 0);
          this.ctx.lineTo(this.canvas.width, 0);
          this.ctx.lineTo(this.canvas.width, this.canvas.height);
          this.ctx.lineTo(0, this.canvas.height);
          this.ctx.lineTo(0, 0);
          this.formatPath(paths.slice(0).reverse());
          this.ctx.closePath();
        };
        CanvasRenderer2.prototype.path = function(paths) {
          this.ctx.beginPath();
          this.formatPath(paths);
          this.ctx.closePath();
        };
        CanvasRenderer2.prototype.formatPath = function(paths) {
          var _this = this;
          paths.forEach(function(point, index2) {
            var start2 = isBezierCurve(point) ? point.start : point;
            if (index2 === 0) {
              _this.ctx.moveTo(start2.x, start2.y);
            } else {
              _this.ctx.lineTo(start2.x, start2.y);
            }
            if (isBezierCurve(point)) {
              _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
            }
          });
        };
        CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
          this.path(path);
          this.ctx.fillStyle = pattern;
          this.ctx.translate(offsetX, offsetY);
          this.ctx.fill();
          this.ctx.translate(-offsetX, -offsetY);
        };
        CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
          var _a2;
          if (image2.width === width && image2.height === height) {
            return image2;
          }
          var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
          var canvas = ownerDocument.createElement("canvas");
          canvas.width = Math.max(1, width);
          canvas.height = Math.max(1, height);
          var ctx = canvas.getContext("2d");
          ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
          return canvas;
        };
        CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
          return __awaiter(this, void 0, void 0, function() {
            var index2, _loop_1, this_1, _i, _a2, backgroundImage2;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  index2 = container.styles.backgroundImage.length - 1;
                  _loop_1 = function(backgroundImage3) {
                    var image2, url, _c, path, x2, y2, width, height, pattern, _d, path, x2, y2, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                    return __generator(this, function(_h) {
                      switch (_h.label) {
                        case 0:
                          if (!(backgroundImage3.type === 0))
                            return [3, 5];
                          image2 = void 0;
                          url = backgroundImage3.url;
                          _h.label = 1;
                        case 1:
                          _h.trys.push([1, 3, , 4]);
                          return [4, this_1.context.cache.match(url)];
                        case 2:
                          image2 = _h.sent();
                          return [3, 4];
                        case 3:
                          _h.sent();
                          this_1.context.logger.error("Error loading background-image " + url);
                          return [3, 4];
                        case 4:
                          if (image2) {
                            _c = calculateBackgroundRendering(container, index2, [
                              image2.width,
                              image2.height,
                              image2.width / image2.height
                            ]), path = _c[0], x2 = _c[1], y2 = _c[2], width = _c[3], height = _c[4];
                            pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                            this_1.renderRepeat(path, pattern, x2, y2);
                          }
                          return [3, 6];
                        case 5:
                          if (isLinearGradient(backgroundImage3)) {
                            _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x2 = _d[1], y2 = _d[2], width = _d[3], height = _d[4];
                            _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                            canvas = document.createElement("canvas");
                            canvas.width = width;
                            canvas.height = height;
                            ctx = canvas.getContext("2d");
                            gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                            processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                              return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                            });
                            ctx.fillStyle = gradient_1;
                            ctx.fillRect(0, 0, width, height);
                            if (width > 0 && height > 0) {
                              pattern = this_1.ctx.createPattern(canvas, "repeat");
                              this_1.renderRepeat(path, pattern, x2, y2);
                            }
                          } else if (isRadialGradient(backgroundImage3)) {
                            _f = calculateBackgroundRendering(container, index2, [
                              null,
                              null,
                              null
                            ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                            position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                            x2 = getAbsoluteValue(position2[0], width);
                            y2 = getAbsoluteValue(position2[position2.length - 1], height);
                            _g = calculateRadius(backgroundImage3, x2, y2, width, height), rx = _g[0], ry = _g[1];
                            if (rx > 0 && ry > 0) {
                              radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y2, 0, left + x2, top_1 + y2, rx);
                              processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                                return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                              });
                              this_1.path(path);
                              this_1.ctx.fillStyle = radialGradient_1;
                              if (rx !== ry) {
                                midX = container.bounds.left + 0.5 * container.bounds.width;
                                midY = container.bounds.top + 0.5 * container.bounds.height;
                                f2 = ry / rx;
                                invF = 1 / f2;
                                this_1.ctx.save();
                                this_1.ctx.translate(midX, midY);
                                this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                                this_1.ctx.translate(-midX, -midY);
                                this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                this_1.ctx.restore();
                              } else {
                                this_1.ctx.fill();
                              }
                            }
                          }
                          _h.label = 6;
                        case 6:
                          index2--;
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  };
                  this_1 = this;
                  _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                  _b.label = 1;
                case 1:
                  if (!(_i < _a2.length))
                    return [3, 4];
                  backgroundImage2 = _a2[_i];
                  return [5, _loop_1(backgroundImage2)];
                case 2:
                  _b.sent();
                  _b.label = 3;
                case 3:
                  _i++;
                  return [3, 1];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              this.path(parsePathForBorder(curvePoints, side));
              this.ctx.fillStyle = asString(color2);
              this.ctx.fill();
              return [
                2
                /*return*/
              ];
            });
          });
        };
        CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
          return __awaiter(this, void 0, void 0, function() {
            var outerPaths, innerPaths;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (!(width < 3))
                    return [3, 2];
                  return [4, this.renderSolidBorder(color2, side, curvePoints)];
                case 1:
                  _a2.sent();
                  return [
                    2
                    /*return*/
                  ];
                case 2:
                  outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                  this.path(outerPaths);
                  this.ctx.fillStyle = asString(color2);
                  this.ctx.fill();
                  innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                  this.path(innerPaths);
                  this.ctx.fill();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
          return __awaiter(this, void 0, void 0, function() {
            var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
            var _this = this;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.applyEffects(paint.getEffects(
                    2
                    /* BACKGROUND_BORDERS */
                  ));
                  styles = paint.container.styles;
                  hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                  borders = [
                    { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                    { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                    { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                    { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                  ];
                  backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                  if (!(hasBackground || styles.boxShadow.length))
                    return [3, 2];
                  this.ctx.save();
                  this.path(backgroundPaintingArea);
                  this.ctx.clip();
                  if (!isTransparent(styles.backgroundColor)) {
                    this.ctx.fillStyle = asString(styles.backgroundColor);
                    this.ctx.fill();
                  }
                  return [4, this.renderBackgroundImage(paint.container)];
                case 1:
                  _a2.sent();
                  this.ctx.restore();
                  styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                    _this.ctx.save();
                    var borderBoxArea = calculateBorderBoxPath(paint.curves);
                    var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                    var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                    if (shadow.inset) {
                      _this.path(borderBoxArea);
                      _this.ctx.clip();
                      _this.mask(shadowPaintingArea);
                    } else {
                      _this.mask(borderBoxArea);
                      _this.ctx.clip();
                      _this.path(shadowPaintingArea);
                    }
                    _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                    _this.ctx.shadowOffsetY = shadow.offsetY.number;
                    _this.ctx.shadowColor = asString(shadow.color);
                    _this.ctx.shadowBlur = shadow.blur.number;
                    _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                    _this.ctx.fill();
                    _this.ctx.restore();
                  });
                  _a2.label = 2;
                case 2:
                  side = 0;
                  _i = 0, borders_1 = borders;
                  _a2.label = 3;
                case 3:
                  if (!(_i < borders_1.length))
                    return [3, 13];
                  border = borders_1[_i];
                  if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))
                    return [3, 11];
                  if (!(border.style === 2))
                    return [3, 5];
                  return [4, this.renderDashedDottedBorder(
                    border.color,
                    border.width,
                    side,
                    paint.curves,
                    2
                    /* DASHED */
                  )];
                case 4:
                  _a2.sent();
                  return [3, 11];
                case 5:
                  if (!(border.style === 3))
                    return [3, 7];
                  return [4, this.renderDashedDottedBorder(
                    border.color,
                    border.width,
                    side,
                    paint.curves,
                    3
                    /* DOTTED */
                  )];
                case 6:
                  _a2.sent();
                  return [3, 11];
                case 7:
                  if (!(border.style === 4))
                    return [3, 9];
                  return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
                case 8:
                  _a2.sent();
                  return [3, 11];
                case 9:
                  return [4, this.renderSolidBorder(border.color, side, paint.curves)];
                case 10:
                  _a2.sent();
                  _a2.label = 11;
                case 11:
                  side++;
                  _a2.label = 12;
                case 12:
                  _i++;
                  return [3, 3];
                case 13:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
          return __awaiter(this, void 0, void 0, function() {
            var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
            return __generator(this, function(_a2) {
              this.ctx.save();
              strokePaths = parsePathForBorderStroke(curvePoints, side);
              boxPaths = parsePathForBorder(curvePoints, side);
              if (style === 2) {
                this.path(boxPaths);
                this.ctx.clip();
              }
              if (isBezierCurve(boxPaths[0])) {
                startX = boxPaths[0].start.x;
                startY = boxPaths[0].start.y;
              } else {
                startX = boxPaths[0].x;
                startY = boxPaths[0].y;
              }
              if (isBezierCurve(boxPaths[1])) {
                endX = boxPaths[1].end.x;
                endY = boxPaths[1].end.y;
              } else {
                endX = boxPaths[1].x;
                endY = boxPaths[1].y;
              }
              if (side === 0 || side === 2) {
                length = Math.abs(startX - endX);
              } else {
                length = Math.abs(startY - endY);
              }
              this.ctx.beginPath();
              if (style === 3) {
                this.formatPath(strokePaths);
              } else {
                this.formatPath(boxPaths.slice(0, 2));
              }
              dashLength = width < 3 ? width * 3 : width * 2;
              spaceLength = width < 3 ? width * 2 : width;
              if (style === 3) {
                dashLength = width;
                spaceLength = width;
              }
              useLineDash = true;
              if (length <= dashLength * 2) {
                useLineDash = false;
              } else if (length <= dashLength * 2 + spaceLength) {
                multiplier = length / (2 * dashLength + spaceLength);
                dashLength *= multiplier;
                spaceLength *= multiplier;
              } else {
                numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
                minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
                maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
                spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
              }
              if (useLineDash) {
                if (style === 3) {
                  this.ctx.setLineDash([0, dashLength + spaceLength]);
                } else {
                  this.ctx.setLineDash([dashLength, spaceLength]);
                }
              }
              if (style === 3) {
                this.ctx.lineCap = "round";
                this.ctx.lineWidth = width;
              } else {
                this.ctx.lineWidth = width * 2 + 1.1;
              }
              this.ctx.strokeStyle = asString(color2);
              this.ctx.stroke();
              this.ctx.setLineDash([]);
              if (style === 2) {
                if (isBezierCurve(boxPaths[0])) {
                  path1 = boxPaths[3];
                  path2 = boxPaths[0];
                  this.ctx.beginPath();
                  this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                  this.ctx.stroke();
                }
                if (isBezierCurve(boxPaths[1])) {
                  path1 = boxPaths[1];
                  path2 = boxPaths[2];
                  this.ctx.beginPath();
                  this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                  this.ctx.stroke();
                }
              }
              this.ctx.restore();
              return [
                2
                /*return*/
              ];
            });
          });
        };
        CanvasRenderer2.prototype.render = function(element2) {
          return __awaiter(this, void 0, void 0, function() {
            var stack;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  if (this.options.backgroundColor) {
                    this.ctx.fillStyle = asString(this.options.backgroundColor);
                    this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                  }
                  stack = parseStackingContexts(element2);
                  return [4, this.renderStack(stack)];
                case 1:
                  _a2.sent();
                  this.applyEffects([]);
                  return [2, this.canvas];
              }
            });
          });
        };
        return CanvasRenderer2;
      }(Renderer)
    );
    var isTextInputElement = function(container) {
      if (container instanceof TextareaElementContainer) {
        return true;
      } else if (container instanceof SelectElementContainer) {
        return true;
      } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
        return true;
      }
      return false;
    };
    var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
      switch (clip) {
        case 0:
          return calculateBorderBoxPath(curves);
        case 2:
          return calculateContentBoxPath(curves);
        case 1:
        default:
          return calculatePaddingBoxPath(curves);
      }
    };
    var canvasTextAlign = function(textAlign2) {
      switch (textAlign2) {
        case 1:
          return "center";
        case 2:
          return "right";
        case 0:
        default:
          return "left";
      }
    };
    var iOSBrokenFonts = ["-apple-system", "system-ui"];
    var fixIOSSystemFonts = function(fontFamilies) {
      return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
        return iOSBrokenFonts.indexOf(fontFamily2) === -1;
      }) : fontFamilies;
    };
    var ForeignObjectRenderer = (
      /** @class */
      function(_super) {
        __extends(ForeignObjectRenderer2, _super);
        function ForeignObjectRenderer2(context, options) {
          var _this = _super.call(this, context, options) || this;
          _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
          _this.ctx = _this.canvas.getContext("2d");
          _this.options = options;
          _this.canvas.width = Math.floor(options.width * options.scale);
          _this.canvas.height = Math.floor(options.height * options.scale);
          _this.canvas.style.width = options.width + "px";
          _this.canvas.style.height = options.height + "px";
          _this.ctx.scale(_this.options.scale, _this.options.scale);
          _this.ctx.translate(-options.x, -options.y);
          _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
          return _this;
        }
        ForeignObjectRenderer2.prototype.render = function(element2) {
          return __awaiter(this, void 0, void 0, function() {
            var svg, img;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element2);
                  return [4, loadSerializedSVG(svg)];
                case 1:
                  img = _a2.sent();
                  if (this.options.backgroundColor) {
                    this.ctx.fillStyle = asString(this.options.backgroundColor);
                    this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                  }
                  this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                  return [2, this.canvas];
              }
            });
          });
        };
        return ForeignObjectRenderer2;
      }(Renderer)
    );
    var loadSerializedSVG = function(svg) {
      return new Promise(function(resolve2, reject) {
        var img = new Image();
        img.onload = function() {
          resolve2(img);
        };
        img.onerror = reject;
        img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
      });
    };
    var Logger = (
      /** @class */
      function() {
        function Logger2(_a2) {
          var id2 = _a2.id, enabled = _a2.enabled;
          this.id = id2;
          this.enabled = enabled;
          this.start = Date.now();
        }
        Logger2.prototype.debug = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (this.enabled) {
            if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
              console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
            } else {
              this.info.apply(this, args);
            }
          }
        };
        Logger2.prototype.getTime = function() {
          return Date.now() - this.start;
        };
        Logger2.prototype.info = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (this.enabled) {
            if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
              console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
            }
          }
        };
        Logger2.prototype.warn = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (this.enabled) {
            if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
              console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
            } else {
              this.info.apply(this, args);
            }
          }
        };
        Logger2.prototype.error = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (this.enabled) {
            if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
              console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
            } else {
              this.info.apply(this, args);
            }
          }
        };
        Logger2.instances = {};
        return Logger2;
      }()
    );
    var Context = (
      /** @class */
      function() {
        function Context2(options, windowBounds) {
          var _a2;
          this.windowBounds = windowBounds;
          this.instanceName = "#" + Context2.instanceCount++;
          this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
          this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
        }
        Context2.instanceCount = 1;
        return Context2;
      }()
    );
    var html2canvas = function(element2, options) {
      if (options === void 0) {
        options = {};
      }
      return renderElement(element2, options);
    };
    if (typeof window !== "undefined") {
      CacheStorage.setContext(window);
    }
    var renderElement = function(element2, opts) {
      return __awaiter(void 0, void 0, void 0, function() {
        var ownerDocument, defaultView2, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer2, root2, renderer2;
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
        return __generator(this, function(_u) {
          switch (_u.label) {
            case 0:
              if (!element2 || typeof element2 !== "object") {
                return [2, Promise.reject("Invalid element provided as first argument")];
              }
              ownerDocument = element2.ownerDocument;
              if (!ownerDocument) {
                throw new Error("Element is not attached to a Document");
              }
              defaultView2 = ownerDocument.defaultView;
              if (!defaultView2) {
                throw new Error("Document is not attached to a Window");
              }
              resourceOptions = {
                allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
                imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
                proxy: opts.proxy,
                useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
              };
              contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
              windowOptions = {
                windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView2.innerWidth,
                windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView2.innerHeight,
                scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView2.pageXOffset,
                scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView2.pageYOffset
              };
              windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
              context = new Context(contextOptions, windowBounds);
              foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
              cloneOptions = {
                allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
                onclone: opts.onclone,
                ignoreElements: opts.ignoreElements,
                inlineImages: foreignObjectRendering,
                copyStyles: foreignObjectRendering
              };
              context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
              documentCloner = new DocumentCloner(context, element2, cloneOptions);
              clonedElement = documentCloner.clonedReferenceElement;
              if (!clonedElement) {
                return [2, Promise.reject("Unable to find element in cloned iframe")];
              }
              return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
            case 1:
              container = _u.sent();
              _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
              backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
              renderOptions = {
                canvas: opts.canvas,
                backgroundColor: backgroundColor2,
                scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView2.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
                x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
                y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
                width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
                height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
              };
              if (!foreignObjectRendering)
                return [3, 3];
              context.logger.debug("Document cloned, using foreign object rendering");
              renderer2 = new ForeignObjectRenderer(context, renderOptions);
              return [4, renderer2.render(clonedElement)];
            case 2:
              canvas = _u.sent();
              return [3, 5];
            case 3:
              context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
              context.logger.debug("Starting DOM parsing");
              root2 = parseTree(context, clonedElement);
              if (backgroundColor2 === root2.styles.backgroundColor) {
                root2.styles.backgroundColor = COLORS.TRANSPARENT;
              }
              context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
              renderer2 = new CanvasRenderer(context, renderOptions);
              return [4, renderer2.render(root2)];
            case 4:
              canvas = _u.sent();
              _u.label = 5;
            case 5:
              if ((_t2 = opts.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {
                if (!DocumentCloner.destroy(container)) {
                  context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
                }
              }
              context.logger.debug("Finished rendering");
              return [2, canvas];
          }
        });
      });
    };
    var parseBackgroundColor = function(context, element2, backgroundColorOverride) {
      var ownerDocument = element2.ownerDocument;
      var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
      var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
      var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
      return element2 === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
    };
    function bind(fn2, thisArg) {
      return function wrap() {
        return fn2.apply(thisArg, arguments);
      };
    }
    const { toString } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    const typeOfTest = (type) => (thing) => typeof thing === type;
    const { isArray } = Array;
    const isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    const isString = typeOfTest("string");
    const isFunction = typeOfTest("function");
    const isNumber = typeOfTest("number");
    const isObject = (thing) => thing !== null && typeof thing === "object";
    const isBoolean = (thing) => thing === true || thing === false;
    const isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject(val) && isFunction(val.pipe);
    const isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn2, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i2;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i2 = 0, l = obj.length; i2 < l; i2++) {
          fn2.call(null, obj[i2], i2, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i2 = 0; i2 < len; i2++) {
          key = keys2[i2];
          fn2.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i2 = keys2.length;
      let _key;
      while (i2-- > 0) {
        _key = keys2[i2];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue2 = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
        arguments[i2] && forEach(arguments[i2], assignValue2);
      }
      return result;
    }
    const extend = (a2, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a2[key] = bind(val, thisArg);
        } else {
          a2[key] = val;
        }
      }, { allOwnKeys });
      return a2;
    };
    const stripBOM = (content2) => {
      if (content2.charCodeAt(0) === 65279) {
        content2 = content2.slice(1);
      }
      return content2;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i2;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position2) => {
      str = String(str);
      if (position2 === void 0 || position2 > str.length) {
        position2 = str.length;
      }
      position2 -= searchString.length;
      const lastIndex = str.indexOf(searchString, position2);
      return lastIndex !== -1 && lastIndex === position2;
    };
    const toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i2 = thing.length;
      if (!isNumber(i2))
        return null;
      const arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    };
    const isTypedArray = ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn2) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn2.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer2(m2, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        if (reducer(descriptor, name, obj) !== false) {
          reducedDescriptors[name] = descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    const noop = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    const ALPHA = "abcdefghijklmnopqrstuvwxyz";
    const DIGIT = "0123456789";
    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size2--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    const toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i2) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i2] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i2 + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i2] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    const isAsyncFn = kindOfTest("AsyncFunction");
    const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    const utils = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message2, code, config, request2, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message2;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request2 && (this.request = request2);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request2, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request2, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils.isPlainObject(thing) || utils.isArray(thing);
    }
    function removeBrackets(key) {
      return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i2) {
        token = removeBrackets(token);
        return !dots && i2 ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils.toFlatObject(utils, {}, null, function filter2(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils.isSpecCompliantForm(formData);
      if (!utils.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index2) {
              !(utils.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils.forEach(value, function each(el, key) {
          const result = !(utils.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id2) {
        if (this.handlers[id2]) {
          this.handlers[id2] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn2) {
        utils.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn2(h2);
          }
        });
      }
    }
    const InterceptorManager$1 = InterceptorManager;
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    const isStandardBrowserEnv = (() => {
      let product;
      if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    })();
    const isStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const platform = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      isStandardBrowserEnv,
      isStandardBrowserWebWorkerEnv,
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i2;
      const len = keys2.length;
      let key;
      for (i2 = 0; i2 < len; i2++) {
        key = keys2[i2];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index2) {
        let name = path[index2++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index2 >= path.length;
        name = !name && utils.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index2);
        if (result && utils.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
        const obj = {};
        utils.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    const DEFAULT_CONTENT_TYPE = {
      "Content-Type": void 0
    };
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e3) {
          if (e3.name !== "SyntaxError") {
            throw e3;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils.isObject(data);
        if (isObjectPayload && utils.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils.isFormData(data);
        if (isFormData2) {
          if (!hasJSONContentType) {
            return data;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e3) {
            if (strictJSONParsing) {
              if (e3.name === "SyntaxError") {
                throw AxiosError.from(e3, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e3;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    const defaults$1 = defaults;
    const ignoreDuplicateOf = utils.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i2;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i2 = line.indexOf(":");
        key = line.substring(0, i2).trim().toLowerCase();
        val = line.substring(i2 + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
      if (utils.isFunction(filter2)) {
        return filter2.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils.isString(value))
        return;
      if (utils.isString(filter2)) {
        return value.indexOf(filter2) !== -1;
      }
      if (utils.isRegExp(filter2)) {
        return filter2.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher2) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher2 || matchHeaderValue(this, this[key], key, matcher2)));
        }
        return false;
      }
      delete(header, matcher2) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils.findKey(self2, _header);
            if (key && (!matcher2 || matchHeaderValue(self2, self2[key], key, matcher2))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher2) {
        const keys2 = Object.keys(this);
        let i2 = keys2.length;
        let deleted = false;
        while (i2--) {
          const key = keys2[i2];
          if (!matcher2 || matchHeaderValue(this, this[key], key, matcher2, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils.forEach(this, (value, header) => {
          const key = utils.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed2 = new this(first);
        targets.forEach((target) => computed2.set(target));
        return computed2;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils.freezeMethods(AxiosHeaders.prototype);
    utils.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils.forEach(fns, function transform2(fn2) {
        data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message2, config, request2) {
      AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED, config, request2);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve2, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    const cookies = platform.isStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            const cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove2(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove2() {
          }
        };
      }()
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const isURLSameOrigin = platform.isStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i2 = tail;
        let bytesCount = 0;
        while (i2 !== head) {
          bytesCount += bytes[i2++];
          i2 = i2 % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e3) => {
        const loaded = e3.loaded;
        const total = e3.lengthComputable ? e3.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e3
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else {
            requestHeaders.setContentType("multipart/form-data;", false);
          }
        }
        let request2 = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request2.timeout = config.timeout;
        function onloadend() {
          if (!request2) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
          const response = {
            data: responseData,
            status: request2.status,
            statusText: request2.statusText,
            headers: responseHeaders,
            config,
            request: request2
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request2 = null;
        }
        if ("onloadend" in request2) {
          request2.onloadend = onloadend;
        } else {
          request2.onreadystatechange = function handleLoad() {
            if (!request2 || request2.readyState !== 4) {
              return;
            }
            if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request2.onabort = function handleAbort() {
          if (!request2) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
          request2 = null;
        };
        request2.onerror = function handleError2() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2));
          request2 = null;
        };
        request2.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request2
          ));
          request2 = null;
        };
        if (platform.isStandardBrowserEnv) {
          const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
          if (xsrfValue) {
            requestHeaders.set(config.xsrfHeaderName, xsrfValue);
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request2) {
          utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request2.setRequestHeader(key, val);
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request2.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request2.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request2.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request2.upload) {
          request2.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request2) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request2) : cancel);
            request2.abort();
            request2 = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request2.send(requestData || null);
      });
    };
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils.forEach(knownAdapters, (fn2, value) => {
      if (fn2) {
        try {
          Object.defineProperty(fn2, "name", { value });
        } catch (e3) {
        }
        Object.defineProperty(fn2, "adapterName", { value });
      }
    });
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        for (let i2 = 0; i2 < length; i2++) {
          nameOrAdapter = adapters2[i2];
          if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
            break;
          }
        }
        if (!adapter) {
          if (adapter === false) {
            throw new AxiosError(
              `Adapter ${nameOrAdapter} is not supported by the environment`,
              "ERR_NOT_SUPPORT"
            );
          }
          throw new Error(
            utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
          );
        }
        if (!utils.isFunction(adapter)) {
          throw new TypeError("adapter is not a function");
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge.call({ caseless }, target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a2, b, caseless) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(a2, b, caseless);
        } else if (!utils.isUndefined(a2)) {
          return getMergedValue(void 0, a2, caseless);
        }
      }
      function valueFromConfig2(a2, b) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a2, b) {
        if (!utils.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils.isUndefined(a2)) {
          return getMergedValue(void 0, a2);
        }
      }
      function mergeDirectKeys(a2, b, prop) {
        if (prop in config2) {
          return getMergedValue(a2, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a2);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a2, b) => mergeDeepProperties(headersToObject(a2), headersToObject(b), true)
      };
      utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    const VERSION = "1.4.0";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message2) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i2 = keys2.length;
      while (i2-- > 0) {
        const opt = keys2[i2];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders;
        contextHeaders = headers && utils.merge(
          headers.common,
          headers[config.method]
        );
        contextHeaders && utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i2 = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i2 < len) {
            promise = promise.then(chain[i2++], chain[i2++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i2 = 0;
        while (i2 < len) {
          const onFulfilled = requestInterceptorChain[i2++];
          const onRejected = requestInterceptorChain[i2++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i2 = 0;
        len = responseInterceptorChain.length;
        while (i2 < len) {
          promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    }
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    const Axios$1 = Axios;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i2 = token._listeners.length;
          while (i2-- > 0) {
            token._listeners[i2](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve2) => {
            token.subscribe(resolve2);
            _resolve = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message2, config, request2) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message2, config, request2);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    const axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    const axios$1 = axios;
    const request = axios$1.create({
      baseURL: "http://127.0.0.1:50000"
      // baseURL: 'http://localhost:5173/api',
      // baseURL: "https://www.fastmock.site/mock/ecf8883ff9dc69f1a831283178b60acd/test/",
    });
    request.interceptors.request.use((config) => {
      return config;
    }, (err) => {
      return Promise.reject(new Error(err));
    });
    request.interceptors.response.use((response) => {
      return response.data;
    }, (error) => {
      return Promise.reject(error);
    });
    const getDepGraph = (name, depth) => {
      return request({
        url: `/depgraph/${encodeURIComponent(name)}/${depth}`,
        method: "get"
      });
    };
    const getNodeDetail = (name) => {
      return request({
        url: `/depgraph-simple/${encodeURIComponent(name)}`,
        method: "get"
      });
    };
    const elDescriptions = "";
    const elDescriptionsItem = "";
    const elLink = "";
    const elTag = "";
    const _withScopeId$2 = (n) => (pushScopeId("data-v-dc81d695"), n = n(), popScopeId(), n);
    const _hoisted_1$2 = { key: 0 };
    const _hoisted_2$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("h4", { class: "desc-title" }, "项目多版本依赖详情", -1));
    const _hoisted_3$2 = { class: "links-box" };
    const _sfc_main$2 = /* @__PURE__ */ defineComponent({
      __name: "PkgDetail",
      props: {
        data: {}
      },
      emits: ["refresh"],
      setup(__props, { emit: emit2 }) {
        const showMulPackage = ref(false);
        function handleClickLink(item) {
          emit2("refresh", item);
        }
        return (_ctx, _cache) => {
          const _component_el_descriptions_item = ElDescriptionsItem;
          const _component_el_tag = ElTag;
          const _component_el_link = ElLink;
          const _component_el_descriptions = ElDescriptions;
          const _component_el_scrollbar = ElScrollbar;
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_component_el_descriptions, {
              title: "依赖详情",
              column: 1,
              border: ""
            }, {
              default: withCtx(() => [
                createVNode(_component_el_descriptions_item, {
                  label: "包名",
                  "min-width": "150"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.data.entryPackageName), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_descriptions_item, { label: "版本" }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.data.entryVersion), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_descriptions_item, { label: "是否有循环依赖" }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      type: _ctx.data.isCircle ? "danger" : "info"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.data.isCircle ? "是" : "否"), 1)
                      ]),
                      _: 1
                    }, 8, ["type"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_descriptions_item, { label: "依赖下是否多版本" }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      type: _ctx.data.isMulPackage ? "danger" : "info"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.data.isMulPackage ? "是" : "否"), 1)
                      ]),
                      _: 1
                    }, 8, ["type"]),
                    _ctx.data.isMulPackage ? (openBlock(), createElementBlock("span", _hoisted_1$2, [
                      createTextVNode("   "),
                      createVNode(_component_el_link, {
                        type: "success",
                        onClick: _cache[0] || (_cache[0] = ($event) => showMulPackage.value = !showMulPackage.value),
                        underline: false
                      }, {
                        default: withCtx(() => [
                          createTextVNode("查看")
                        ]),
                        _: 1
                      })
                    ])) : createCommentVNode("", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            withDirectives(createBaseVNode("div", null, [
              _hoisted_2$2,
              createVNode(_component_el_scrollbar, { "max-height": "150px" }, {
                default: withCtx(() => [
                  createVNode(_component_el_descriptions, {
                    column: 1,
                    border: ""
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data.mulPackageList, (packageArray) => {
                        return openBlock(), createBlock(_component_el_descriptions_item, {
                          label: packageArray[0] != void 0 && packageArray[0].split("&")[0]
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("div", _hoisted_3$2, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(packageArray, (node) => {
                                return openBlock(), createBlock(_component_el_link, {
                                  type: "primary",
                                  onClick: ($event) => handleClickLink(node),
                                  underline: false,
                                  key: node
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(node.split("&")[1]), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"]);
                              }), 128))
                            ])
                          ]),
                          _: 2
                        }, 1032, ["label"]);
                      }), 256))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ], 512), [
              [vShow, showMulPackage.value && _ctx.data.mulPackageList.length > 0]
            ])
          ], 64);
        };
      }
    });
    const PkgDetail_vue_vue_type_style_index_0_scoped_dc81d695_lang = "";
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const PkgDetail = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-dc81d695"]]);
    const elOption = "";
    const elOptionGroup = "";
    const elSelect = "";
    const _withScopeId$1 = (n) => (pushScopeId("data-v-74fed4cb"), n = n(), popScopeId(), n);
    const _hoisted_1$1 = { key: 0 };
    const _hoisted_2$1 = {
      key: 0,
      class: "desc-link"
    };
    const _hoisted_3$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h4", { class: "desc-title" }, "项目多版本依赖详情", -1));
    const _hoisted_4$1 = { class: "links-box" };
    const _hoisted_5$1 = { class: "links" };
    const _hoisted_6$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, "[", -1));
    const _hoisted_7$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, "]", -1));
    const _sfc_main$1 = /* @__PURE__ */ defineComponent({
      __name: "ProjectDetail",
      props: {
        data: {},
        isLocalFile: { type: Boolean }
      },
      emits: ["refresh", "hilightCirleLinks", "searchNode"],
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const showCirleDep = ref(false);
        const showMulPackage = ref(false);
        const changeSelect = (selectedDepth) => {
          emit2("refresh", selectedDepth);
        };
        const handleHightCirleLinks = () => {
          emit2("hilightCirleLinks");
        };
        function handleClickLink(item) {
          emit2("searchNode", item);
        }
        const getRootProjectFullname = () => {
          return props.data.entryPackageName + "&" + props.data.entryVersion;
        };
        return (_ctx, _cache) => {
          const _component_el_link = ElLink;
          const _component_el_descriptions_item = ElDescriptionsItem;
          const _component_el_option = ElOption;
          const _component_el_select = ElSelect;
          const _component_el_tag = ElTag;
          const _component_el_descriptions = ElDescriptions;
          const _component_el_scrollbar = ElScrollbar;
          return openBlock(), createElementBlock(Fragment, null, [
            createVNode(_component_el_descriptions, {
              title: "根项目详情",
              column: 1,
              border: ""
            }, {
              default: withCtx(() => [
                createVNode(_component_el_descriptions_item, {
                  label: "项目名称",
                  "min-width": "150"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_el_link, {
                      type: "primary",
                      onClick: _cache[0] || (_cache[0] = ($event) => handleClickLink(getRootProjectFullname())),
                      underline: false
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.data.entryPackageName), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(_component_el_descriptions_item, { label: "版本" }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.data.entryVersion), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_descriptions_item, { label: "分析依赖层数" }, {
                  default: withCtx(() => [
                    createVNode(_component_el_select, {
                      modelValue: _ctx.data.depth,
                      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.data.depth = $event),
                      class: "m-2",
                      placeholder: "Select",
                      size: "small",
                      disabled: _ctx.isLocalFile,
                      onChange: changeSelect
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_option, {
                          key: "all",
                          label: "all",
                          value: "-1"
                        }),
                        (openBlock(), createElementBlock(Fragment, null, renderList(20, (i2) => {
                          return createVNode(_component_el_option, {
                            key: i2,
                            label: i2,
                            value: i2
                          }, null, 8, ["label", "value"]);
                        }), 64))
                      ]),
                      _: 1
                    }, 8, ["modelValue", "disabled"])
                  ]),
                  _: 1
                }),
                createVNode(_component_el_descriptions_item, { label: "分析节点数" }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.data.nodeCount), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_descriptions_item, { label: "是否有多版本依赖" }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      type: _ctx.data.isMulPackage ? "danger" : "info"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.data.isMulPackage ? "是" : "否"), 1)
                      ]),
                      _: 1
                    }, 8, ["type"]),
                    _ctx.data.isMulPackage ? (openBlock(), createElementBlock("span", _hoisted_1$1, [
                      createTextVNode("   "),
                      createVNode(_component_el_link, {
                        type: "success",
                        onClick: _cache[2] || (_cache[2] = ($event) => showMulPackage.value = !showMulPackage.value),
                        underline: false
                      }, {
                        default: withCtx(() => [
                          createTextVNode("查看")
                        ]),
                        _: 1
                      })
                    ])) : createCommentVNode("", true)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_descriptions_item, { label: "是否有循环依赖" }, {
                  default: withCtx(() => [
                    createVNode(_component_el_tag, {
                      type: _ctx.data.isCircle ? "danger" : "info"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.data.isCircle ? "是" : "否"), 1)
                      ]),
                      _: 1
                    }, 8, ["type"]),
                    _ctx.data.isCircle ? (openBlock(), createElementBlock("span", _hoisted_2$1, [
                      createTextVNode("   "),
                      createVNode(_component_el_link, {
                        type: "success",
                        onClick: _cache[3] || (_cache[3] = ($event) => showCirleDep.value = !showCirleDep.value),
                        underline: false
                      }, {
                        default: withCtx(() => [
                          createTextVNode("查看")
                        ]),
                        _: 1
                      }),
                      createTextVNode("     "),
                      createVNode(_component_el_link, {
                        type: "success",
                        onClick: handleHightCirleLinks,
                        underline: false
                      }, {
                        default: withCtx(() => [
                          createTextVNode("图像")
                        ]),
                        _: 1
                      })
                    ])) : createCommentVNode("", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            withDirectives(createBaseVNode("div", null, [
              _hoisted_3$1,
              createVNode(_component_el_scrollbar, { "max-height": "150px" }, {
                default: withCtx(() => [
                  createVNode(_component_el_descriptions, {
                    column: 1,
                    border: ""
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data.mulPackageList, (packageArray) => {
                        return openBlock(), createBlock(_component_el_descriptions_item, {
                          label: packageArray[0] != void 0 && packageArray[0].split("&")[0]
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("div", _hoisted_4$1, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(packageArray, (node) => {
                                return openBlock(), createBlock(_component_el_link, {
                                  type: "primary",
                                  onClick: ($event) => handleClickLink(node),
                                  underline: false,
                                  key: node
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString(node.split("&")[1]), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["onClick"]);
                              }), 128))
                            ])
                          ]),
                          _: 2
                        }, 1032, ["label"]);
                      }), 256))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ], 512), [
              [vShow, showMulPackage.value && _ctx.data.mulPackageList.length > 0]
            ]),
            withDirectives(createBaseVNode("div", null, [
              createVNode(_component_el_descriptions, {
                direction: "vertical",
                column: 1,
                border: ""
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_descriptions_item, { label: "循环依赖详情" }, {
                    default: withCtx(() => [
                      createVNode(_component_el_scrollbar, { "max-height": "150px" }, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data.circleDepList, (circle) => {
                            return openBlock(), createElementBlock("div", null, [
                              createBaseVNode("div", _hoisted_5$1, [
                                _hoisted_6$1,
                                (openBlock(true), createElementBlock(Fragment, null, renderList(circle, (node, index2) => {
                                  return openBlock(), createBlock(_component_el_link, {
                                    type: "primary",
                                    class: normalizeClass(index2 > 0 ? "arrow" : ""),
                                    onClick: ($event) => handleClickLink(node.toString()),
                                    underline: false,
                                    key: node
                                  }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString(node), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["class", "onClick"]);
                                }), 128)),
                                _hoisted_7$1
                              ])
                            ]);
                          }), 256))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ], 512), [
              [vShow, showCirleDep.value && _ctx.data.isMulPackage]
            ])
          ], 64);
        };
      }
    });
    const ProjectDetail_vue_vue_type_style_index_0_scoped_74fed4cb_lang = "";
    const ProjectDetail = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-74fed4cb"]]);
    const _withScopeId = (n) => (pushScopeId("data-v-cc4f6a6a"), n = n(), popScopeId(), n);
    const _hoisted_1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("h1", null, "Dep-Analyze-Cli Insights", -1));
    const _hoisted_2 = { class: "search-box" };
    const _hoisted_3 = { class: "switch-box" };
    const _hoisted_4 = { class: "switch" };
    const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "展示名字", -1));
    const _hoisted_6 = { class: "switch" };
    const _hoisted_7 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "展示箭头", -1));
    const _hoisted_8 = { class: "switch" };
    const _hoisted_9 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, "定位到中心点", -1));
    const _hoisted_10 = { class: "upload-btn" };
    const _hoisted_11 = { class: "container" };
    const _hoisted_12 = { class: "svg-box" };
    const _hoisted_13 = { class: "svg-tools-box" };
    const _hoisted_14 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("svg", {
      id: "mainsvg",
      class: "svg",
      width: "75vw",
      height: "78vh"
    }, [
      /* @__PURE__ */ createBaseVNode("defs", null, [
        /* @__PURE__ */ createBaseVNode("marker", {
          id: "triangle-gray",
          viewBox: "0 0 10 20",
          refX: "17",
          refY: "5",
          markerUnits: "strokeWidth",
          markerWidth: "10",
          markerHeight: "20",
          orient: "auto-start-reverse"
        }, [
          /* @__PURE__ */ createBaseVNode("path", {
            d: "M 0 0 L 10 5 L 0 10 z",
            fill: "gray"
          })
        ]),
        /* @__PURE__ */ createBaseVNode("marker", {
          id: "triangle-red",
          viewBox: "0 0 10 20",
          refX: "17",
          refY: "5",
          markerUnits: "strokeWidth",
          markerWidth: "10",
          markerHeight: "20",
          orient: "auto-start-reverse"
        }, [
          /* @__PURE__ */ createBaseVNode("path", {
            d: "M 0 0 L 10 5 L 0 10 z",
            fill: "red"
          })
        ])
      ])
    ], -1));
    const _hoisted_15 = [
      _hoisted_14
    ];
    const _hoisted_16 = { class: "detail-box" };
    const _sfc_main = /* @__PURE__ */ defineComponent({
      __name: "App",
      setup(__props) {
        const searchKeyWords = ref("");
        const showName = ref(true);
        const showArrow = ref(true);
        const isCenter = ref(true);
        const loading = ref(true);
        const isLocalFile = ref(false);
        const nodeDetail = ref({
          entryPackageName: "",
          entryVersion: "",
          isCircle: false,
          isMulPackage: false,
          mulPackageList: []
        });
        const projectDetail = ref({
          entryPackageName: "",
          entryVersion: "",
          depth: 0,
          isCircle: false,
          isMulPackage: false,
          nodeCount: 0,
          circleDepList: [[]],
          mulPackageList: [[]]
        });
        const dependenciesList = ref([]);
        let data = {
          entryPackageName: "",
          entryVersion: "",
          nodes: [],
          links: []
        };
        let graph;
        onMounted(() => __async(this, null, function* () {
          getDepGraph("default", 10).then((resp) => {
            dependenciesList.value = resp.nodes.map((node) => {
              return { value: node.name };
            });
            data = __spreadValues({}, resp);
            projectDetail.value = __spreadValues({}, resp);
            graph = render2(data);
            loading.value = false;
          });
        }));
        function render2(data2) {
          const svg2 = select$1("svg");
          const container = svg2.append("g");
          const width = parseInt(window.getComputedStyle(mainSvgRef.value).width);
          const height = parseInt(window.getComputedStyle(mainSvgRef.value).height);
          container.attr("viewBox", `0 0 ${width} ${height}`);
          const nodes = data2.nodes;
          const links = data2.links;
          const color2 = sequential(rainbow).domain([0, 100]);
          const simulation$1 = simulation(nodes);
          simulation$1.force(
            "link",
            link(links).id((d) => d.name)
          ).force("charge", manyBody().strength(50)).force("manyBody", manyBody().strength(-600)).force("center", center(width / 2, height / 2)).force("x", x()).force("y", y());
          const tipStyle = `display: inline-block;background-color: white;padding: 5px 10px;border: 1px solid #ccc;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-size: 14px;`;
          const tip = d3tip().attr("class", "d3-tip").html(
            (event, d) => `<span style="${tipStyle}">${d.name}</span>`
          );
          svg2.call(tip);
          const link$1 = container.append("g").attr("fill", "none").attr("stroke-width", 1).selectAll("path").data(links).join("path").attr("stroke", "gray").attr("marker-end", "url(#triangle-gray)");
          const node = container.append("g").attr("stroke-linecap", "round").attr("stroke-linejoin", "round").selectAll("g").data(nodes).join("g").call(drag$1(simulation$1));
          const handleClickNode = (event) => {
            const sourceName = select$1(event.currentTarget)["_groups"][0][0]["__data__"].name;
            const _name = "#" + sourceName.replace(/[^a-zA-Z0-9]/g, "");
            const circle = select$1(_name);
            const r = circle.attr("r");
            circle.transition().duration(100).attr("r", 4).transition().duration(100).attr("r", r);
            if (!isLocalFile.value) {
              getNodeDetail(sourceName).then((resp) => {
                nodeDetail.value = __spreadValues({}, resp);
              });
            }
            hightlightLinks(sourceName);
          };
          function hightlightLinks(sourceName) {
            const linksArray = link$1["_groups"][0];
            for (let i2 = 0; i2 < linksArray.length; i2++) {
              linksArray[i2].setAttribute("stroke", "gray");
              if (showArrow.value) {
                linksArray[i2].setAttribute("marker-end", "url(#triangle-gray)");
              }
              if (linksArray[i2]["__data__"]["source"]["name"] === sourceName) {
                linksArray[i2].setAttribute("stroke", "red");
                if (showArrow.value) {
                  linksArray[i2].setAttribute("marker-end", "url(#triangle-red)");
                }
              }
            }
          }
          function hightlightCircleLinks(targetLinks) {
            const linksArray = link$1["_groups"][0];
            for (let i2 = 0; i2 < linksArray.length; i2++) {
              linksArray[i2].setAttribute("stroke", "gray");
              if (showArrow.value) {
                linksArray[i2].setAttribute("marker-end", "url(#triangle-gray)");
              }
              const sourceAndTarget = linksArray[i2]["__data__"]["source"]["name"] + linksArray[i2]["__data__"]["target"]["name"];
              if (targetLinks.includes(sourceAndTarget)) {
                linksArray[i2].setAttribute("stroke", "red");
                if (showArrow.value) {
                  linksArray[i2].setAttribute("marker-end", "url(#triangle-red)");
                }
              }
            }
          }
          node.append("circle").attr("stroke", "white").attr("stroke-width", 1.5).attr("r", (d) => 5.5 + d.count % 7).attr("fill", (d) => color2(Math.random() * 100)).attr("id", (d) => d.name.replace(/[^a-zA-Z0-9]/g, "")).on("click", handleClickNode).on("contextmenu", (e3) => {
            e3.preventDefault();
            container.append("polygon ").attr("points", "65,5 100,35 85,75 35,75 20,35").attr("fill", "red");
          }).on("mouseover", tip.show).on("mouseout", tip.hide);
          node.append("text").attr("x", (d) => -d.name.length * 3).attr("y", 15).text((d) => d.name).attr("font-size", 10).clone(true).lower().attr("fill", "none");
          const rootName = data2.entryPackageName + "&" + data2.entryVersion;
          const rootPoint = select$1("#" + rootName.replace(/[^a-zA-Z0-9]/g, ""));
          rootPoint.attr("fill", "red");
          setInterval(() => {
            rootPoint.transition().duration(500).attr("r", 20).transition().duration(500).attr("r", 10);
          }, 1500);
          let zoom$1 = zoom().scaleExtent([0.1, 10]).on("zoom", (e3) => {
            container.attr("transform", e3.transform);
          });
          svg2.call(zoom$1).call(zoom$1.transform, identity.scale(1));
          simulation$1.on("tick", () => {
            link$1.attr("d", linkArc);
            node.attr(
              "transform",
              (d) => `translate(${d.x},${d.y})`
            );
          });
          function linkArc(d) {
            return `
    M${d.source.x},${d.source.y}
     ${d.target.x},${d.target.y}
  `;
          }
          function drag$1(simulation2) {
            function dragstarted(event, d) {
              if (!event.active)
                simulation2.alphaTarget(0.05).restart();
              d.fx = d.x;
              d.fy = d.y;
            }
            function dragged(event, d) {
              d.fx = event.x;
              d.fy = event.y;
            }
            function dragended(event, d) {
              if (!event.active)
                simulation2.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            }
            return drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
          }
          function getNodePositionByName(nodeName) {
            const name = "#" + nodeName.replace(/[^a-zA-Z0-9]/g, "");
            const selectResult = select$1(name)["_groups"][0];
            if (selectResult.length > 0) {
              const node2 = selectResult[0]["__data__"];
              const { x: x2, y: y2 } = node2;
              return { x: x2, y: y2 };
            }
          }
          let previousTaget = null;
          let previousRadius = 0;
          function scaleAndCenterNode(packageName, x2, y2) {
            const isRootPoint = packageName === rootName;
            if (previousTaget !== null && !isRootPoint) {
              previousTaget.interrupt();
              previousTaget.attr("r", previousRadius);
            }
            const name = "#" + packageName.replace(/[^a-zA-Z0-9]/g, "");
            const circle = svg2.select(name);
            const r = circle.attr("r");
            previousTaget = circle;
            previousRadius = r;
            if (isCenter.value) {
              container.transition().duration(1e3).attr(
                "transform",
                `translate(${width / 2 - x2}, ${height / 2 - y2}) scale(1)`
              );
              svg2.node().__zoom.k = 1;
              svg2.node().__zoom.x = width / 2 - x2;
              svg2.node().__zoom.y = height / 2 - y2;
            }
            if (isRootPoint)
              return;
            circle.transition().duration(500).attr("r", 30).transition().duration(500).attr("r", r);
          }
          return {
            simulation: simulation$1,
            hightlightLinks,
            getNodePositionByName,
            scaleAndCenterNode,
            hightlightCircleLinks
          };
        }
        function search(packageName) {
          if (!(packageName.length > 0))
            return;
          if (!dependenciesList.value.find((obj) => obj.value === packageName)) {
            ElMessage({
              message: "查询的依赖不存在该项目, 或检查版本是否正确",
              type: "error",
              offset: 50
            });
            return;
          }
          graph.hightlightLinks(packageName);
          const { x: x2, y: y2 } = graph.getNodePositionByName(packageName);
          graph.scaleAndCenterNode(packageName, x2, y2);
          if (!isLocalFile.value) {
            getNodeDetail(packageName).then((resp) => {
              nodeDetail.value = __spreadValues({}, resp);
            });
          }
        }
        const querySearch = (queryString, cb) => {
          const results = queryString ? dependenciesList.value.filter(createFilter(queryString)) : dependenciesList.value;
          cb(results);
        };
        const createFilter = (queryString) => {
          return (item) => {
            return item.value.toLowerCase().indexOf(queryString.toLowerCase()) === 0;
          };
        };
        const handleSelect = (item) => {
          search(item.value);
        };
        watch(showName, (newValue, oldValue) => {
          selectAll("text").attr(
            "display",
            `${newValue === true ? "inherit" : "none"}`
          );
        });
        watch(showArrow, (newValue, oldValue) => {
          selectAll("path").attr(
            "marker-end",
            `${newValue === true ? "url(#triangle-gray)" : "none"}`
          );
        });
        const toggleFullscreen = () => {
          const ele = document.getElementById("mainsvg");
          if (screenfull$1.isEnabled) {
            screenfull$1.request(ele);
          }
        };
        const changeDepth = (depth) => {
          reLoad();
          const pkg = data.entryPackageName + "&" + data.entryVersion;
          getDepGraph(pkg, depth).then((resp) => {
            dependenciesList.value = resp.nodes.map((node) => {
              return { value: node.name };
            });
            data = __spreadValues({}, resp);
            projectDetail.value = __spreadValues({}, resp);
            graph = render2(data);
            loading.value = false;
          });
        };
        const handleViewCircleDep = () => {
          const circleDepLinks = [];
          const map2 = /* @__PURE__ */ new Map();
          projectDetail.value.circleDepList.map((circleArr) => {
            for (let i2 = 0; i2 < circleArr.length - 1; i2++) {
              const node1 = circleArr[i2];
              const node2 = circleArr[i2 + 1];
              const key = "" + node1 + node2;
              if (!map2.has(key)) {
                map2.set(key, true);
                circleDepLinks.push(key);
              }
            }
          }).flat(1);
          graph.hightlightCircleLinks(circleDepLinks);
        };
        const uploadRef = ref();
        const renderFile = (uploadFile) => {
          isLocalFile.value = true;
          try {
            const reader = new FileReader();
            reader.onload = function() {
              if (reader.result) {
                reLoad();
                const data2 = JSON.parse(reader.result.toString());
                dependenciesList.value = data2.nodes.map((node) => {
                  return { value: node.name };
                });
                projectDetail.value = __spreadValues({}, data2);
                graph = render2(data2);
                loading.value = false;
              }
            };
            reader.readAsText(uploadFile.raw);
          } catch (err) {
            console.log(err);
            ElMessage({
              message: "文件错误",
              type: "error",
              offset: 50
            });
          }
        };
        const handleUpdloadSuccess = (uploadFile, uploadFiles) => {
          renderFile(uploadFile);
          uploadRef.value.clearFiles();
        };
        const handleExceed = (files, uploadFiles) => {
          ElMessage({
            message: "文件数量不能多于1个",
            type: "error",
            offset: 50
          });
          uploadRef.value.clearFiles();
        };
        const mainSvgRef = ref();
        const downloadSvg = () => {
          html2canvas(mainSvgRef.value).then((canvas) => {
            var imageURL = canvas.toDataURL("image/png");
            var link2 = document.createElement("a");
            link2.href = imageURL;
            link2.download = `${data.entryPackageName}Graph.png`;
            link2.click();
          });
        };
        const reLoad = () => {
          selectAll("g").remove();
          loading.value = true;
          const svg2 = select$1("svg");
          svg2.node().__zoom.k = 1;
          svg2.node().__zoom.x = 0;
          svg2.node().__zoom.y = 0;
          nodeDetail.value.entryPackageName = "";
          searchKeyWords.value = "";
        };
        return (_ctx, _cache) => {
          const _component_el_header = ElHeader;
          const _component_el_col = ElCol;
          const _component_el_autocomplete = ElAutocomplete;
          const _component_el_button = ElButton;
          const _component_el_switch = ElSwitch;
          const _component_el_upload = ElUpload;
          const _component_el_row = ElRow;
          const _component_el_aside = ElAside;
          const _component_el_main = ElMain;
          const _component_el_container = ElContainer;
          const _directive_loading = vLoading;
          return openBlock(), createBlock(_component_el_container, null, {
            default: withCtx(() => [
              createVNode(_component_el_header, null, {
                default: withCtx(() => [
                  _hoisted_1
                ]),
                _: 1
              }),
              createVNode(_component_el_container, null, {
                default: withCtx(() => [
                  createVNode(_component_el_main, null, {
                    default: withCtx(() => [
                      createVNode(_component_el_row, null, {
                        default: withCtx(() => [
                          createVNode(_component_el_col, { span: 8 }),
                          createVNode(_component_el_col, { span: 8 }, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_2, [
                                createVNode(_component_el_autocomplete, {
                                  modelValue: searchKeyWords.value,
                                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchKeyWords.value = $event),
                                  "fetch-suggestions": querySearch,
                                  clearable: "",
                                  style: { "width": "100%" },
                                  placeholder: "Please Input",
                                  onSelect: handleSelect
                                }, null, 8, ["modelValue"]),
                                createVNode(_component_el_button, {
                                  type: "primary",
                                  onClick: _cache[1] || (_cache[1] = ($event) => search(searchKeyWords.value))
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode("查找")
                                  ]),
                                  _: 1
                                })
                              ])
                            ]),
                            _: 1
                          }),
                          createVNode(_component_el_col, { span: 8 }, {
                            default: withCtx(() => [
                              createBaseVNode("div", _hoisted_3, [
                                createBaseVNode("div", _hoisted_4, [
                                  _hoisted_5,
                                  createVNode(_component_el_switch, {
                                    size: "small",
                                    modelValue: showName.value,
                                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => showName.value = $event)
                                  }, null, 8, ["modelValue"])
                                ]),
                                createBaseVNode("div", _hoisted_6, [
                                  _hoisted_7,
                                  createVNode(_component_el_switch, {
                                    size: "small",
                                    modelValue: showArrow.value,
                                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => showArrow.value = $event)
                                  }, null, 8, ["modelValue"])
                                ]),
                                createBaseVNode("div", _hoisted_8, [
                                  _hoisted_9,
                                  createVNode(_component_el_switch, {
                                    size: "small",
                                    modelValue: isCenter.value,
                                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isCenter.value = $event)
                                  }, null, 8, ["modelValue"])
                                ]),
                                createBaseVNode("div", _hoisted_10, [
                                  createVNode(_component_el_upload, {
                                    ref_key: "uploadRef",
                                    ref: uploadRef,
                                    action: "#",
                                    accept: "application/json",
                                    "on-change": handleUpdloadSuccess,
                                    "show-file-list": false,
                                    "auto-upload": false,
                                    "on-exceed": handleExceed,
                                    limit: 1
                                  }, {
                                    trigger: withCtx(() => [
                                      createVNode(_component_el_button, {
                                        size: "small",
                                        type: "success"
                                      }, {
                                        default: withCtx(() => [
                                          createTextVNode("上传JSON")
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  }, 512)
                                ])
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      withDirectives((openBlock(), createElementBlock("div", _hoisted_11, [
                        createBaseVNode("div", _hoisted_12, [
                          createBaseVNode("div", _hoisted_13, [
                            createVNode(_component_el_button, {
                              onClick: toggleFullscreen,
                              title: "全屏"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("全屏")
                              ]),
                              _: 1
                            }),
                            createVNode(_component_el_button, {
                              onClick: downloadSvg,
                              title: "下载"
                            }, {
                              default: withCtx(() => [
                                createTextVNode("下载")
                              ]),
                              _: 1
                            })
                          ]),
                          createBaseVNode("div", {
                            ref_key: "mainSvgRef",
                            ref: mainSvgRef
                          }, _hoisted_15, 512)
                        ]),
                        createVNode(_component_el_aside, { width: "20vw" }, {
                          default: withCtx(() => [
                            createBaseVNode("div", _hoisted_16, [
                              createVNode(ProjectDetail, {
                                data: projectDetail.value,
                                isLocalFile: isLocalFile.value,
                                onRefresh: changeDepth,
                                onHilightCirleLinks: handleViewCircleDep,
                                onSearchNode: search
                              }, null, 8, ["data", "isLocalFile"]),
                              withDirectives(createBaseVNode("div", null, [
                                createVNode(PkgDetail, {
                                  data: nodeDetail.value,
                                  onRefresh: search
                                }, null, 8, ["data"])
                              ], 512), [
                                [
                                  vShow,
                                  nodeDetail.value.entryPackageName && !isLocalFile.value && nodeDetail.value.entryPackageName !== unref(data).entryPackageName
                                ]
                              ])
                            ])
                          ]),
                          _: 1
                        })
                      ])), [
                        [_directive_loading, loading.value]
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          });
        };
      }
    });
    const App_vue_vue_type_style_index_0_scoped_cc4f6a6a_lang = "";
    const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-cc4f6a6a"]]);
    const index = "";
    createApp(App).mount("#app");
  }
});
export default require_index_001();
